<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DeriveGeneric #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE GADTs #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE InstanceSigs #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE OverloadedStrings #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE PatternSynonyms #-}</span><span>
</span><span id="line-12"></span><span class="hs-pragma">{-# LANGUAGE RankNTypes #-}</span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving #-}</span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell #-}</span><span>
</span><span id="line-15"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-16"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><span id="line-17"></span><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-orphans #-}</span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="hs-comment">-- {-# OPTIONS_GHC -ddump-splices #-}</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-comment">-- | Free foil implementation of the \(\lambda)-calculus (with pairs).</span><span>
</span><span id="line-22"></span><span class="hs-comment">--</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- Free foil provides __general__ definitions or implementations for the</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- following:</span><span>
</span><span id="line-25"></span><span class="hs-comment">--</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- 1. Freely generated (from a simple signature) scope-safe AST.</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- 2. Correct capture-avoiding substitution (see 'substitute').</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- 3. Correct &#945;-equivalence checks (see 'alphaEquiv' and 'alphaEquivRefreshed')</span><span>
</span><span id="line-29"></span><span class="hs-comment">--    as well as &#945;-normalization (see 'refreshAST').</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- 4. Conversion helpers (see 'convertToAST' and 'convertFromAST').</span><span>
</span><span id="line-31"></span><span class="hs-comment">--</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- The following is __generated__ using Template Haskell:</span><span>
</span><span id="line-33"></span><span class="hs-comment">--</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- 1. Convenient pattern synonyms.</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- 2. 'ZipMatch' instances (enabling general &#945;-equivalence).</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- 3. Conversion between scope-safe and raw term representation.</span><span>
</span><span id="line-37"></span><span class="hs-comment">--</span><span>
</span><span id="line-38"></span><span class="hs-comment">-- The following is implemented __manually__ in this module:</span><span>
</span><span id="line-39"></span><span class="hs-comment">--</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- 1. Computation of weak head normal form (WHNF), see 'whnf'.</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- 2. Entry point, gluing everything together. See 'defaultMain'.</span><span>
</span><span id="line-42"></span><span class="hs-comment">--</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- __Note:__ free foil does not (easily) support patterns at the moment, so only</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- wildcard patterns and variable patterns are handled in this implementation.</span><span>
</span><span id="line-45"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Lambda.Impl</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Foil</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Foil</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Foil.Internal</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">FoilInternal</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Foil.TH</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Free.Foil</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Free.Foil.TH</span></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Biapplicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Bifunctor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">bimap</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">first</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Bifunctor.Sum</span></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Bifunctor.TH</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">partitionEithers</span></span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Map</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.SOAS.html"><span class="hs-identifier">Data.SOAS</span></a></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IsString</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Text</span></span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">TIO</span></span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.ZipMatchK</span></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.ZipMatchK.Bifunctor</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">GHC</span></span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Generics.Kind.TH</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">deriveGenericK</span></span><span class="hs-special">)</span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html"><span class="hs-identifier">Language.Lambda.Syntax.Abs</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-68"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Layout.html"><span class="hs-identifier">Language.Lambda.Syntax.Layout</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Par.html"><span class="hs-identifier">Language.Lambda.Syntax.Par</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Print.html"><span class="hs-identifier">Language.Lambda.Syntax.Print</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Raw</span></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Toml</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">TomlCodec</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(.=)</span></span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Toml</span></span><span>
</span><span id="line-73"></span><span>
</span><span id="line-74"></span><span class="hs-comment">-- $setup</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- &gt;&gt;&gt; :set -XOverloadedStrings</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- &gt;&gt;&gt; :set -XDataKinds</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- &gt;&gt;&gt; import qualified Control.Monad.Foil as Foil</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- &gt;&gt;&gt; import Control.Monad.Free.Foil</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- &gt;&gt;&gt; import Data.String (fromString)</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="annot"><span class="hs-comment">-- * Generated code</span></span><span>
</span><span id="line-82"></span><span>
</span><span id="line-83"></span><span class="annot"><span class="hs-comment">-- ** Signature</span></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span id="TermSig"><span id="local-6989586621679244777"><span id="local-6989586621679244778"><span id="local-6989586621679245501"><span id="local-6989586621679245505"><span id="local-6989586621679245508"><span id="local-6989586621679245514"><span id="local-6989586621679245521"><span id="local-6989586621679245526"><span id="local-6989586621679245529"><span id="local-6989586621679245532"><span id="local-6989586621679245535"><span id="local-6989586621679245538"><span id="local-6989586621679245541"><span id="local-6989586621679245544"><span id="local-6989586621679245547"><span id="local-6989586621679245550"><span id="local-6989586621679245553"><span id="local-6989586621679245558"><span id="local-6989586621679245563"><span id="local-6989586621679245568"><span id="local-6989586621679245573"><span id="local-6989586621679245583"><span id="local-6989586621679245594"><span id="local-6989586621679245600"><span id="local-6989586621679245605"><span id="LamSig"><span id="LetSig"><span id="AppSig"><span id="MetaVarSig"><span class="hs-identifier">mkSignature</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Term</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.ScopedTerm</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-86"></span><span id="local-6989586621679245620"><span id="local-6989586621679245623"><span id="local-6989586621679245627"><span class="hs-identifier">deriveBifunctor</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">TermSig</span></span></span></span><span>
</span><span id="line-87"></span><span id="local-6989586621679245643"><span id="local-6989586621679245649"><span id="local-6989586621679245656"><span id="local-6989586621679245659"><span class="hs-identifier">deriveBifoldable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">TermSig</span></span></span></span></span><span>
</span><span id="line-88"></span><span id="local-6989586621679245698"><span class="hs-identifier">deriveBitraversable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">TermSig</span></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="annot"><span class="hs-comment">-- ** Pattern synonyms</span></span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span id="local-6989586621679244834"><span id="local-6989586621679244835"><span id="local-6989586621679244839"><span id="local-6989586621679244840"><span id="local-6989586621679244843"><span id="local-6989586621679244844"><span id="local-6989586621679244845"><span id="local-6989586621679244848"><span id="local-6989586621679244849"><span id="local-6989586621679244850"><span id="local-6989586621679245730"><span id="local-6989586621679245731"><span id="local-6989586621679245732"><span id="local-6989586621679245733"><span id="local-6989586621679245734"><span id="local-6989586621679245735"><span id="local-6989586621679245736"><span id="local-6989586621679245737"><span id="local-6989586621679245738"><span id="local-6989586621679245739"><span id="MetaVar"><span id="App"><span id="Let"><span id="Lam"><span id="%24mMetaVar"><span id="%24bMetaVar"><span id="%24mApp"><span id="%24bApp"><span id="%24mLet"><span id="%24bLet"><span id="%24mLam"><span id="%24bLam"><span class="hs-identifier">mkPatternSynonyms</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">TermSig</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="annot"><span class="hs-comment">-- ** Conversion helpers</span></span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span id="convertToTermSig"><span id="getPatternBinder"><span id="getTermFromScopedTerm"><span class="hs-identifier">mkConvertToFreeFoil</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Term</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.ScopedTerm</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span></span></span><span>
</span><span id="line-97"></span><span id="convertFromTermSig"><span class="hs-identifier">mkConvertFromFreeFoil</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Term</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.ScopedTerm</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span class="annot"><span class="hs-comment">-- ** Scope-safe patterns</span></span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span id="FoilPattern"><span id="local-6989586621679244935"><span id="local-6989586621679244936"><span id="local-6989586621679245007"><span id="FoilAPattern"><span class="hs-identifier">mkFoilPattern</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span></span></span></span></span><span>
</span><span id="line-102"></span><span id="local-6989586621679245791"><span id="local-6989586621679245795"><span class="hs-identifier">deriveCoSinkable</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span></span><span>
</span><span id="line-103"></span><span id="local-6989586621679244946"><span id="local-6989586621679244948"><span id="local-6989586621679244949"><span id="toFoilPattern"><span class="hs-identifier">mkToFoilPattern</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span></span></span></span><span>
</span><span id="line-104"></span><span id="local-6989586621679244970"><span id="local-6989586621679244971"><span id="fromFoilPattern"><span class="hs-identifier">mkFromFoilPattern</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span></span></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span id="local-6989586621679245872"><span class="hs-identifier">deriveUnifiablePattern</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.VarIdent</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">Raw.Pattern</span></span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span id="local-6989586621679244935"><span id="RepK"><span id="local-6989586621679245007"><span id="local-6989586621679245891"><span id="local-6989586621679245893"><span id="local-6989586621679245895"><span id="local-6989586621679245897"><span id="local-6989586621679245899"><span id="local-6989586621679245901"><span class="hs-identifier">deriveGenericK</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">FoilPattern</span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679245923"><span class="annot"><span class="hs-identifier hs-type">Foil.SinkableK</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span></span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span id="local-6989586621679245063"><span id="local-6989586621679245064"><span id="local-6989586621679245943"><span id="local-6989586621679245945"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">GHC.Generic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245063"><span class="hs-identifier hs-type">scope</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245064"><span class="hs-identifier hs-type">term</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span id="local-6989586621679244777"><span id="local-6989586621679244778"><span id="RepK"><span id="local-6989586621679245949"><span id="local-6989586621679245951"><span id="local-6989586621679245953"><span id="local-6989586621679245955"><span id="local-6989586621679245957"><span id="local-6989586621679245959"><span class="hs-identifier">deriveGenericK</span><span> </span><span class="hs-special">''</span><span class="hs-identifier">TermSig</span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679246021"><span class="annot"><span class="hs-identifier hs-type">ZipMatchK</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="annot"><span class="hs-comment">-- | Match 'Raw.Ident' via 'Eq'.</span></span><span>
</span><span id="line-119"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ZipMatchK</span></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679246084"><span class="annot"><span class="annottext">zipMatchWithK :: forall (as :: LoT (*)) (bs :: LoT (*)) (cs :: LoT (*)).
Mappings as bs cs
-&gt; (VarIdent :@@: as)
-&gt; (VarIdent :@@: bs)
-&gt; Maybe (VarIdent :@@: cs)
</span><a href="#local-6989586621679246084"><span class="hs-identifier hs-var hs-var hs-var hs-var">zipMatchWithK</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Mappings as bs cs
-&gt; (VarIdent :@@: as)
-&gt; (VarIdent :@@: bs)
-&gt; Maybe (VarIdent :@@: cs)
Mappings as bs cs -&gt; VarIdent -&gt; VarIdent -&gt; Maybe VarIdent
forall {k} a (as :: LoT k) (bs :: LoT k) (cs :: LoT k).
Eq a =&gt;
Mappings as bs cs -&gt; a -&gt; a -&gt; Maybe a
</span><span class="hs-identifier hs-var">zipMatchViaEq</span></span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ZipMatchK</span></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679246090"><span class="annot"><span class="annottext">zipMatchWithK :: forall (as :: LoT (*)) (bs :: LoT (*)) (cs :: LoT (*)).
Mappings as bs cs
-&gt; (MetaVarIdent :@@: as)
-&gt; (MetaVarIdent :@@: bs)
-&gt; Maybe (MetaVarIdent :@@: cs)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">zipMatchWithK</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Mappings as bs cs
-&gt; (MetaVarIdent :@@: as)
-&gt; (MetaVarIdent :@@: bs)
-&gt; Maybe (MetaVarIdent :@@: cs)
Mappings as bs cs
-&gt; MetaVarIdent -&gt; MetaVarIdent -&gt; Maybe MetaVarIdent
forall {k} a (as :: LoT k) (bs :: LoT k) (cs :: LoT k).
Eq a =&gt;
Mappings as bs cs -&gt; a -&gt; a -&gt; Maybe a
</span><span class="hs-identifier hs-var">zipMatchViaEq</span></span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ZipMatchK</span></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span> </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679246094"><span class="annot"><span class="annottext">zipMatchWithK :: forall (as :: LoT (*)) (bs :: LoT (*)) (cs :: LoT (*)).
Mappings as bs cs
-&gt; (Type :@@: as) -&gt; (Type :@@: bs) -&gt; Maybe (Type :@@: cs)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">zipMatchWithK</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Mappings as bs cs
-&gt; (Type :@@: as) -&gt; (Type :@@: bs) -&gt; Maybe (Type :@@: cs)
Mappings as bs cs -&gt; Type -&gt; Type -&gt; Maybe Type
forall {k} a (as :: LoT k) (bs :: LoT k) (cs :: LoT k).
Eq a =&gt;
Mappings as bs cs -&gt; a -&gt; a -&gt; Maybe a
</span><span class="hs-identifier hs-var">zipMatchViaEq</span></span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="annot"><span class="hs-comment">-- ** Pattern synonyms</span></span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#App%27"><span class="hs-identifier hs-type">App'</span></a></span><span>
</span><span id="line-128"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245134"><span id="local-6989586621679245135"><span id="local-6989586621679245137"><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245134"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245135"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245137"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245134"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245135"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245137"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245134"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245135"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245137"><span class="hs-identifier hs-type">n</span></a></span></span></span></span><span>
</span><span id="line-131"></span><span class="hs-keyword">pattern</span><span> </span><span id="App%27"><span id="%24mApp%27"><span id="%24bApp%27"><span class="annot"><span class="annottext">$mApp' :: forall {r} {binder :: S -&gt; S -&gt; *} {q :: * -&gt; * -&gt; *} {n :: S}.
AST binder (Sum TermSig q) n
-&gt; (AST binder (Sum TermSig q) n
    -&gt; AST binder (Sum TermSig q) n -&gt; r)
-&gt; ((# #) -&gt; r)
-&gt; r
$bApp' :: forall (binder :: S -&gt; S -&gt; *) (q :: * -&gt; * -&gt; *) (n :: S).
AST binder (Sum TermSig q) n
-&gt; AST binder (Sum TermSig q) n -&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#App%27"><span class="hs-identifier hs-var hs-var hs-var">App'</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246098"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246099"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#AppSig"><span class="hs-identifier hs-type">AppSig</span></a></span><span> </span><span id="local-6989586621679246098"><span class="annot"><a href="#local-6989586621679246098"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679246099"><span class="annot"><a href="#local-6989586621679246099"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-identifier hs-type">Lam'</span></a></span><span>
</span><span id="line-134"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245149"><span id="local-6989586621679245150"><span id="local-6989586621679245151"><span id="local-6989586621679245152"><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-135"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679245149"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245151"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245152"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-136"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245149"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245150"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245152"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-137"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245149"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245150"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245151"><span class="hs-identifier hs-type">n</span></a></span></span></span></span></span><span>
</span><span id="line-138"></span><span class="hs-keyword">pattern</span><span> </span><span id="Lam%27"><span id="%24mLam%27"><span id="%24bLam%27"><span class="annot"><span class="annottext">$mLam' :: forall {r} {binder :: S -&gt; S -&gt; *} {n :: S} {q :: * -&gt; * -&gt; *}.
AST binder (Sum TermSig q) n
-&gt; (forall {l :: S}.
    Type -&gt; binder n l -&gt; AST binder (Sum TermSig q) l -&gt; r)
-&gt; ((# #) -&gt; r)
-&gt; r
$bLam' :: forall (binder :: S -&gt; S -&gt; *) (n :: S) (q :: * -&gt; * -&gt; *)
       (l :: S).
Type
-&gt; binder n l
-&gt; AST binder (Sum TermSig q) l
-&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-identifier hs-var hs-var hs-var">Lam'</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246104"><span class="hs-identifier hs-type">typ</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246105"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246106"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#LamSig"><span class="hs-identifier hs-type">LamSig</span></a></span><span> </span><span id="local-6989586621679246104"><span class="annot"><a href="#local-6989586621679246104"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ScopedAST</span></span><span> </span><span id="local-6989586621679246105"><span class="annot"><a href="#local-6989586621679246105"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246106"><span class="annot"><a href="#local-6989586621679246106"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Let%27"><span class="hs-identifier hs-type">Let'</span></a></span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245160"><span id="local-6989586621679245161"><span id="local-6989586621679245162"><span id="local-6989586621679245163"><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245160"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245161"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245162"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679245160"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245162"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245163"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245160"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245161"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245163"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245160"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245161"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245162"><span class="hs-identifier hs-type">n</span></a></span></span></span></span></span><span>
</span><span id="line-145"></span><span class="hs-keyword">pattern</span><span> </span><span id="Let%27"><span id="%24mLet%27"><span id="%24bLet%27"><span class="annot"><span class="annottext">$mLet' :: forall {r} {binder :: S -&gt; S -&gt; *} {q :: * -&gt; * -&gt; *} {n :: S}.
AST binder (Sum TermSig q) n
-&gt; (forall {l :: S}.
    AST binder (Sum TermSig q) n
    -&gt; binder n l -&gt; AST binder (Sum TermSig q) l -&gt; r)
-&gt; ((# #) -&gt; r)
-&gt; r
$bLet' :: forall (binder :: S -&gt; S -&gt; *) (q :: * -&gt; * -&gt; *) (n :: S)
       (l :: S).
AST binder (Sum TermSig q) n
-&gt; binder n l
-&gt; AST binder (Sum TermSig q) l
-&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#Let%27"><span class="hs-identifier hs-var hs-var hs-var">Let'</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246110"><span class="hs-identifier hs-type">term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246111"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246112"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#LetSig"><span class="hs-identifier hs-type">LetSig</span></a></span><span> </span><span id="local-6989586621679246110"><span class="annot"><a href="#local-6989586621679246110"><span class="hs-identifier hs-var">term</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ScopedAST</span></span><span> </span><span id="local-6989586621679246111"><span class="annot"><a href="#local-6989586621679246111"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246112"><span class="annot"><a href="#local-6989586621679246112"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaVar%27"><span class="hs-identifier hs-type">MetaVar'</span></a></span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679245171"><span id="local-6989586621679245172"><span id="local-6989586621679245173"><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245171"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245172"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245173"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="#local-6989586621679245171"><span class="hs-identifier hs-type">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245172"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679245173"><span class="hs-identifier hs-type">n</span></a></span></span></span></span><span>
</span><span id="line-151"></span><span class="hs-keyword">pattern</span><span> </span><span id="MetaVar%27"><span id="%24mMetaVar%27"><span id="%24bMetaVar%27"><span class="annot"><span class="annottext">$mMetaVar' :: forall {r} {binder :: S -&gt; S -&gt; *} {q :: * -&gt; * -&gt; *} {n :: S}.
AST binder (Sum TermSig q) n
-&gt; (MetaVarIdent -&gt; [AST binder (Sum TermSig q) n] -&gt; r)
-&gt; ((# #) -&gt; r)
-&gt; r
$bMetaVar' :: forall (binder :: S -&gt; S -&gt; *) (q :: * -&gt; * -&gt; *) (n :: S).
MetaVarIdent
-&gt; [AST binder (Sum TermSig q) n] -&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#MetaVar%27"><span class="hs-identifier hs-var hs-var hs-var">MetaVar'</span></a></span></span></span></span><span> </span><span class="annot"><a href="#local-6989586621679246116"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246117"><span class="hs-identifier hs-type">args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#MetaVarSig"><span class="hs-identifier hs-type">MetaVarSig</span></a></span><span> </span><span id="local-6989586621679246116"><span class="annot"><a href="#local-6989586621679246116"><span class="hs-identifier hs-var">metavar</span></a></span></span><span> </span><span id="local-6989586621679246117"><span class="annot"><a href="#local-6989586621679246117"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-comment">-- FV( (&#955; x. x) y )  =  { y }</span><span>
</span><span id="line-154"></span><span class="hs-comment">--</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- &#955;s. &#955;z. s (s z)    :: Term VoidS</span><span>
</span><span id="line-156"></span><span class="hs-comment">--     &#955;z. s (s z)    :: Term n1      --  n1 ~ { s }</span><span>
</span><span id="line-157"></span><span class="hs-comment">--         s (s z)    :: Term n2      --  n2 ~ { s, z }</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- &#955;s                 :: NameBinder VoidS n1</span><span>
</span><span id="line-159"></span><span class="hs-comment">--     &#955;z             :: NameBinder n1 n2</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span>
</span><span id="line-162"></span><span class="annot"><span class="hs-comment">-- * User-defined code</span></span><span>
</span><span id="line-163"></span><span>
</span><span id="line-164"></span><span class="hs-keyword">type</span><span> </span><span id="AST%27"><span class="annot"><a href="Language.Lambda.Impl.html#AST%27"><span class="hs-identifier hs-var">AST'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">AST</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span class="annot"><span class="hs-comment">-- | Scope-safe &#955;-term representation in scope @n@.</span></span><span>
</span><span id="line-167"></span><span class="hs-keyword">type</span><span> </span><span id="Term"><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-var">Term</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#AST%27"><span class="hs-identifier hs-type">AST'</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span class="hs-keyword">type</span><span> </span><span id="MetaTerm"><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-var">MetaTerm</span></a></span></span><span> </span><span id="local-6989586621679246119"><span class="annot"><a href="#local-6989586621679246119"><span class="hs-identifier hs-type">metavar</span></a></span></span><span> </span><span id="local-6989586621679246120"><span class="annot"><a href="#local-6989586621679246120"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.SOAS.html#SOAS"><span class="hs-identifier hs-type">SOAS</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246119"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246120"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="hs-comment">-- M[g, \z. z a]</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- M[x, y] -&gt; y x</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- y = \z. z a</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- x = g</span><span>
</span><span id="line-175"></span><span class="hs-comment">-- (\z. z a) g</span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span class="hs-comment">-- &gt;&gt;&gt; subst = &quot;X [x0: t, x1: t -&gt; u] &#8614; x1 x0&quot; :: MetaSubst'</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- &gt;&gt;&gt; term = &quot;&#955;g: t. &#955;a: u. &#955;w: v. X[g, &#955;z: u -&gt; t. z a]&quot;</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- &gt;&gt;&gt; nfMetaTermWithEmptyScope $ applyMetaSubsts id Foil.emptyScope (MetaSubsts [subst]) term</span><span>
</span><span id="line-180"></span><span class="hs-comment">-- &#955; x0 : t . &#955; x1 : u . &#955; x2 : v . x0 x1</span><span>
</span><span id="line-181"></span><span class="hs-comment">-- &gt;&gt;&gt; subst = &quot;X [x: t, y: t -&gt; u] &#8614; (&#955; z: t. y z) x&quot; :: MetaSubst'</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- &gt;&gt;&gt; term = &quot;&#955;g: t. &#955;a: u. &#955;w: v. X[g, &#955;z: u -&gt; t. z a]&quot;</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- &gt;&gt;&gt; nfMetaTermWithEmptyScope $ applyMetaSubsts id Foil.emptyScope (MetaSubsts [subst]) term</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- &#955; x0 : t . &#955; x1 : u . &#955; x2 : v . x0 x1</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- &gt;&gt;&gt; term = &quot;&#955;g: t. &#955;a: u. X[g, &#955;z: u -&gt; t. z a]&quot;</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- &gt;&gt;&gt; nfMetaTermWithEmptyScope $ applyMetaSubsts id Foil.emptyScope (MetaSubsts [subst]) term</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- &#955; x0 : t . &#955; x1 : u . x0 x1</span><span>
</span><span id="line-188"></span><span>
</span><span id="line-189"></span><span class="hs-pragma">{-# COMPLETE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">Var</span></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-pragma hs-type">Lam'</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#App%27"><span class="hs-pragma hs-type">App'</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Let%27"><span class="hs-pragma hs-type">Let'</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaVar%27"><span class="hs-pragma hs-type">MetaVar'</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Data.SOAS.html#MetaApp"><span class="hs-pragma hs-type">MetaApp</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span id="local-6989586621679245178"><span id="local-6989586621679245179"><span class="annot"><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-type">nfMetaTerm</span></a></span><span>
</span><span id="line-192"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245178"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245178"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-194"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245179"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245178"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245179"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245178"><span class="hs-identifier hs-type">n</span></a></span></span></span><span>
</span><span id="line-196"></span><span id="nfMetaTerm"><span class="annot"><span class="annottext">nfMetaTerm :: forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var hs-var">nfMetaTerm</span></a></span></span><span> </span><span id="local-6989586621679246128"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-197"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Var</span></span><span> </span><span id="local-6989586621679246129"><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246129"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name n -&gt; MetaTerm metavar n
forall (n :: S) (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *).
Name n -&gt; AST binder sig n
</span><span class="hs-identifier hs-var">Var</span></span><span> </span><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246129"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-198"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-identifier hs-type">Lam'</span></a></span><span> </span><span id="local-6989586621679246132"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246132"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span id="local-6989586621679246133"><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246133"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246134"><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
</span><a href="#local-6989586621679246134"><span class="hs-identifier hs-var">body</span></a></span></span><span>
</span><span id="line-199"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">DistinctEvidence l
</span><span class="hs-identifier hs-var">Foil.Distinct</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l -&gt; DistinctEvidence l
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; DistinctEvidence l
</span><span class="hs-identifier hs-var">Foil.assertDistinct</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246133"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-200"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246139"><span class="annot"><span class="annottext">extendedScope :: Scope l
</span><a href="#local-6989586621679246139"><span class="hs-identifier hs-var hs-var">extendedScope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l -&gt; Scope n -&gt; Scope l
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScopePattern</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246133"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-201"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; FoilPattern n l
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
-&gt; MetaTerm metavar n
forall (binder :: S -&gt; S -&gt; *) (n :: S) (q :: * -&gt; * -&gt; *)
       (l :: S).
Type
-&gt; binder n l
-&gt; AST binder (Sum TermSig q) l
-&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-identifier hs-var">Lam'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246132"><span class="hs-identifier hs-var">typ</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246133"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope l
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246139"><span class="hs-identifier hs-var">extendedScope</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
</span><a href="#local-6989586621679246134"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-202"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#App%27"><span class="hs-identifier hs-type">App'</span></a></span><span> </span><span id="local-6989586621679246140"><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246140"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679246141"><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246141"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246140"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-204"></span><span>      </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-identifier hs-type">Lam'</span></a></span><span> </span><span id="local-6989586621679246153"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246153"><span class="hs-identifier hs-var">_typ</span></a></span></span><span> </span><span id="local-6989586621679246154"><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246154"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246155"><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
</span><a href="#local-6989586621679246155"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-205"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246156"><span class="annot"><span class="annottext">subst :: Substitution
  (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
</span><a href="#local-6989586621679246156"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
-&gt; MetaTerm metavar n
-&gt; Substitution
     (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
forall (t :: S -&gt; *) (n :: S) (l :: S).
InjectName t =&gt;
FoilPattern n l -&gt; t n -&gt; Substitution t l n
</span><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246154"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246141"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-206"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n
-&gt; Substitution
     (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
-&gt; MetaTerm metavar n
forall (sig :: * -&gt; * -&gt; *) (o :: S) (binder :: S -&gt; S -&gt; *)
       (i :: S).
(Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) =&gt;
Scope o
-&gt; Substitution (AST binder sig) i o
-&gt; AST binder sig i
-&gt; AST binder sig o
</span><span class="hs-identifier hs-var">substitute</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution
  (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
</span><a href="#local-6989586621679246156"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
</span><a href="#local-6989586621679246155"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-207"></span><span>      </span><span id="local-6989586621679246158"><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246158"><span class="hs-identifier hs-var">f'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (binder :: S -&gt; S -&gt; *) (q :: * -&gt; * -&gt; *) (n :: S).
AST binder (Sum TermSig q) n
-&gt; AST binder (Sum TermSig q) n -&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#App%27"><span class="hs-identifier hs-var">App'</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246158"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246141"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-208"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#Let%27"><span class="hs-identifier hs-type">Let'</span></a></span><span> </span><span id="local-6989586621679246167"><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246167"><span class="hs-identifier hs-var">value</span></a></span></span><span> </span><span id="local-6989586621679246168"><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246168"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246169"><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
</span><a href="#local-6989586621679246169"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-209"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246170"><span class="annot"><span class="annottext">subst :: Substitution
  (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
</span><a href="#local-6989586621679246170"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
-&gt; MetaTerm metavar n
-&gt; Substitution
     (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
forall (t :: S -&gt; *) (n :: S) (l :: S).
InjectName t =&gt;
FoilPattern n l -&gt; t n -&gt; Substitution t l n
</span><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246168"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246167"><span class="hs-identifier hs-var">value</span></a></span><span>
</span><span id="line-210"></span><span>        </span><span id="local-6989586621679246171"><span class="annot"><span class="annottext">body' :: MetaTerm metavar n
</span><a href="#local-6989586621679246171"><span class="hs-identifier hs-var hs-var">body'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; Substitution
     (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
-&gt; MetaTerm metavar n
forall (sig :: * -&gt; * -&gt; *) (o :: S) (binder :: S -&gt; S -&gt; *)
       (i :: S).
(Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) =&gt;
Scope o
-&gt; Substitution (AST binder sig) i o
-&gt; AST binder sig i
-&gt; AST binder sig o
</span><span class="hs-identifier hs-var">substitute</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution
  (AST FoilPattern (Sum TermSig (MetaAppSig metavar))) l n
</span><a href="#local-6989586621679246170"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
</span><a href="#local-6989586621679246169"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-211"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm metavar n
</span><a href="#local-6989586621679246171"><span class="hs-identifier hs-var">body'</span></a></span><span>
</span><span id="line-212"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaVar%27"><span class="hs-identifier hs-type">MetaVar'</span></a></span><span> </span><span id="local-6989586621679246172"><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246172"><span class="hs-identifier hs-var">metavar</span></a></span></span><span> </span><span id="local-6989586621679246173"><span class="annot"><span class="annottext">[MetaTerm metavar n]
</span><a href="#local-6989586621679246173"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MetaVarIdent -&gt; [MetaTerm metavar n] -&gt; MetaTerm metavar n
forall (binder :: S -&gt; S -&gt; *) (q :: * -&gt; * -&gt; *) (n :: S).
MetaVarIdent
-&gt; [AST binder (Sum TermSig q) n] -&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#MetaVar%27"><span class="hs-identifier hs-var">MetaVar'</span></a></span><span> </span><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246172"><span class="hs-identifier hs-var">metavar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(MetaTerm metavar n -&gt; MetaTerm metavar n)
-&gt; [MetaTerm metavar n] -&gt; [MetaTerm metavar n]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[MetaTerm metavar n]
</span><a href="#local-6989586621679246173"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-comment">-- MetaSubst' metavar term -&gt; MetaSubst' metavar (nfMetaTerm scope term)</span><span>
</span><span id="line-214"></span><span>  </span><span class="annot"><a href="Data.SOAS.html#MetaApp"><span class="hs-identifier hs-type">MetaApp</span></a></span><span> </span><span id="local-6989586621679246174"><span class="annot"><span class="annottext">metavar
</span><a href="#local-6989586621679246174"><span class="hs-identifier hs-var">metavar</span></a></span></span><span> </span><span id="local-6989586621679246175"><span class="annot"><span class="annottext">[MetaTerm metavar n]
</span><a href="#local-6989586621679246175"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">metavar -&gt; [MetaTerm metavar n] -&gt; MetaTerm metavar n
forall metavar (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *)
       (n :: S).
metavar -&gt; [SOAS binder metavar sig n] -&gt; SOAS binder metavar sig n
</span><a href="Data.SOAS.html#MetaApp"><span class="hs-identifier hs-var">MetaApp</span></a></span><span> </span><span class="annot"><span class="annottext">metavar
</span><a href="#local-6989586621679246174"><span class="hs-identifier hs-var">metavar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(MetaTerm metavar n -&gt; MetaTerm metavar n)
-&gt; [MetaTerm metavar n] -&gt; [MetaTerm metavar n]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246128"><span class="hs-identifier hs-var">scope</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[MetaTerm metavar n]
</span><a href="#local-6989586621679246175"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-215"></span><span>
</span><span id="line-216"></span><span id="local-6989586621679245206"><span class="annot"><a href="Language.Lambda.Impl.html#nfMetaTermWithEmptyScope"><span class="hs-identifier hs-type">nfMetaTermWithEmptyScope</span></a></span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SOAS.html#SOAS"><span class="hs-identifier hs-type">SOAS</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245206"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">VoidS</span></span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.SOAS.html#SOAS"><span class="hs-identifier hs-type">SOAS</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245206"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">VoidS</span></span></span><span>
</span><span id="line-219"></span><span id="nfMetaTermWithEmptyScope"><span class="annot"><span class="annottext">nfMetaTermWithEmptyScope :: forall metavar.
SOAS FoilPattern metavar TermSig 'VoidS
-&gt; SOAS FoilPattern metavar TermSig 'VoidS
</span><a href="Language.Lambda.Impl.html#nfMetaTermWithEmptyScope"><span class="hs-identifier hs-var hs-var">nfMetaTermWithEmptyScope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS -&gt; MetaTerm metavar 'VoidS -&gt; MetaTerm metavar 'VoidS
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span id="local-6989586621679245208"><span id="local-6989586621679245209"><span id="local-6989586621679245210"><span class="annot"><a href="Language.Lambda.Impl.html#nameMapToSubsts"><span class="hs-identifier hs-type">nameMapToSubsts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679245208"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679245209"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245210"><span class="hs-identifier hs-type">o</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Substitution</span></span><span> </span><span class="annot"><a href="#local-6989586621679245209"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245208"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245210"><span class="hs-identifier hs-type">o</span></a></span></span></span></span><span>
</span><span id="line-222"></span><span id="nameMapToSubsts"><span class="annot"><span class="annottext">nameMapToSubsts :: forall (i :: S) (e :: S -&gt; *) (o :: S).
NameMap i (e o) -&gt; Substitution e i o
</span><a href="Language.Lambda.Impl.html#nameMapToSubsts"><span class="hs-identifier hs-var hs-var">nameMapToSubsts</span></a></span></span><span> </span><span id="local-6989586621679246180"><span class="annot"><span class="annottext">NameMap i (e o)
</span><a href="#local-6989586621679246180"><span class="hs-identifier hs-var">nameMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-223"></span><span>  </span><span class="annot"><span class="annottext">IntMap (e o) -&gt; Substitution e i o
forall (e :: S -&gt; *) (i :: S) (o :: S).
IntMap (e o) -&gt; Substitution e i o
</span><span class="hs-identifier hs-var">FoilInternal.UnsafeSubstitution</span></span><span> </span><span class="annot"><span class="annottext">(IntMap (e o) -&gt; Substitution e i o)
-&gt; IntMap (e o) -&gt; Substitution e i o
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NameMap i (e o) -&gt; IntMap (e o)
forall (n :: S) a. NameMap n a -&gt; IntMap a
</span><span class="hs-identifier hs-var">FoilInternal.getNameMap</span></span><span> </span><span class="annot"><span class="annottext">NameMap i (e o)
</span><a href="#local-6989586621679246180"><span class="hs-identifier hs-var">nameMap</span></a></span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span class="annot"><span class="hs-comment">-- ** Conversion helpers for 'MetaSubst'</span></span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span class="annot"><a href="Language.Lambda.Impl.html#toMetaSubst"><span class="hs-identifier hs-type">toMetaSubst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaSubst"><span class="hs-identifier hs-type">Raw.MetaSubst</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span>
</span><span id="line-228"></span><span id="toMetaSubst"><span class="annot"><span class="annottext">toMetaSubst :: MetaSubst -&gt; MetaSubst'
</span><a href="Language.Lambda.Impl.html#toMetaSubst"><span class="hs-identifier hs-var hs-var">toMetaSubst</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#AMetaSubst"><span class="hs-identifier hs-type">Raw.AMetaSubst</span></a></span><span> </span><span id="local-6989586621679246186"><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246186"><span class="hs-identifier hs-var">metavar</span></a></span></span><span> </span><span id="local-6989586621679246187"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246187"><span class="hs-identifier hs-var">vars</span></a></span></span><span> </span><span id="local-6989586621679246188"><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246188"><span class="hs-identifier hs-var">term</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-229"></span><span>  </span><span class="annot"><span class="annottext">[Binder]
-&gt; Scope 'VoidS
-&gt; Map VarIdent (Name 'VoidS)
-&gt; NameBinderList 'VoidS 'VoidS
-&gt; NameMap 'VoidS Type
-&gt; (forall {l :: S}.
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList 'VoidS l
    -&gt; NameMap l Type
    -&gt; MetaSubst')
-&gt; MetaSubst'
forall (n :: S) (i :: S) r.
Distinct n =&gt;
[Binder]
-&gt; Scope n
-&gt; Map VarIdent (Name n)
-&gt; NameBinderList i n
-&gt; NameMap n Type
-&gt; (forall (l :: S).
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList i l
    -&gt; NameMap l Type
    -&gt; r)
-&gt; r
</span><a href="Language.Lambda.Impl.html#withMetaSubstVars"><span class="hs-identifier hs-var">withMetaSubstVars</span></a></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246187"><span class="hs-identifier hs-var">vars</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name 'VoidS)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS 'VoidS
forall (n :: S). NameBinderList n n
</span><span class="hs-identifier hs-var">NameBinderListEmpty</span></span><span> </span><span class="annot"><span class="annottext">NameMap 'VoidS Type
forall a. NameMap 'VoidS a
</span><span class="hs-identifier hs-var">Foil.emptyNameMap</span></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}.
  Distinct l =&gt;
  Scope l
  -&gt; Map VarIdent (Name l)
  -&gt; NameBinderList 'VoidS l
  -&gt; NameMap l Type
  -&gt; MetaSubst')
 -&gt; MetaSubst')
-&gt; (forall {l :: S}.
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList 'VoidS l
    -&gt; NameMap l Type
    -&gt; MetaSubst')
-&gt; MetaSubst'
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246195"><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246195"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246196"><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246196"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span id="local-6989586621679246197"><span class="annot"><span class="annottext">NameBinderList 'VoidS l
</span><a href="#local-6989586621679246197"><span class="hs-identifier hs-var">binderList</span></a></span></span><span> </span><span id="local-6989586621679246198"><span class="annot"><span class="annottext">NameMap l Type
</span><a href="#local-6989586621679246198"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246199"><span class="annot"><span class="annottext">term' :: Term l
</span><a href="#local-6989586621679246199"><span class="hs-identifier hs-var hs-var">term'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope l -&gt; Map VarIdent (Name l) -&gt; Term -&gt; Term l
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; Term n
</span><a href="Language.Lambda.Impl.html#toTerm"><span class="hs-identifier hs-var">toTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246195"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246196"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScopedTerm -&gt; Term
</span><a href="Language.Lambda.Impl.html#getTermFromScopedTerm"><span class="hs-identifier hs-var">getTermFromScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246188"><span class="hs-identifier hs-var">term</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-231"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(MetaVarIdent,
 MetaAbs FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) Type)
-&gt; MetaSubst'
forall (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *) metavar
       (ext :: * -&gt; * -&gt; *) t.
(metavar, MetaAbs binder (Sum sig ext) t)
-&gt; MetaSubst binder sig metavar ext t
</span><a href="Data.SOAS.html#MetaSubst"><span class="hs-identifier hs-var">MetaSubst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246186"><span class="hs-identifier hs-var">metavar</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS l
-&gt; NameMap l Type
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
-&gt; MetaAbs FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) Type
forall (n :: S) t (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *).
NameBinderList 'VoidS n
-&gt; NameMap n t -&gt; AST binder sig n -&gt; MetaAbs binder sig t
</span><a href="Data.SOAS.html#MetaAbs"><span class="hs-identifier hs-var">MetaAbs</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS l
</span><a href="#local-6989586621679246197"><span class="hs-identifier hs-var">binderList</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap l Type
</span><a href="#local-6989586621679246198"><span class="hs-identifier hs-var">binderTypes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term l -&gt; AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var">toMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Term l
</span><a href="#local-6989586621679246199"><span class="hs-identifier hs-var">term'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span>
</span><span id="line-233"></span><span id="local-6989586621679245230"><span id="local-6989586621679245231"><span id="local-6989586621679245233"><span class="annot"><a href="Language.Lambda.Impl.html#withMetaSubstVars"><span class="hs-identifier hs-type">withMetaSubstVars</span></a></span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245230"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-235"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Binder"><span class="hs-identifier hs-type">Raw.Binder</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245230"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-237"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245230"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-238"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameBinderList</span></span><span> </span><span class="annot"><a href="#local-6989586621679245231"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245230"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679245230"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-240"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679245232"><span class="annot"><a href="#local-6989586621679245232"><span class="hs-identifier hs-type">l</span></a></span></span><span>
</span><span id="line-241"></span><span>        </span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245232"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>       </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245232"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-243"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245232"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameBinderList</span></span><span> </span><span class="annot"><a href="#local-6989586621679245231"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245232"><span class="hs-identifier hs-type">l</span></a></span><span>
</span><span id="line-245"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679245232"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-246"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679245233"><span class="hs-identifier hs-type">r</span></a></span><span>
</span><span id="line-247"></span><span>     </span><span class="hs-special">)</span><span>
</span><span id="line-248"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679245233"><span class="hs-identifier hs-type">r</span></a></span></span></span></span><span>
</span><span id="line-249"></span><span id="withMetaSubstVars"><span class="annot"><span class="annottext">withMetaSubstVars :: forall (n :: S) (i :: S) r.
Distinct n =&gt;
[Binder]
-&gt; Scope n
-&gt; Map VarIdent (Name n)
-&gt; NameBinderList i n
-&gt; NameMap n Type
-&gt; (forall (l :: S).
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList i l
    -&gt; NameMap l Type
    -&gt; r)
-&gt; r
</span><a href="Language.Lambda.Impl.html#withMetaSubstVars"><span class="hs-identifier hs-var hs-var">withMetaSubstVars</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span id="local-6989586621679246206"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246206"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246207"><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246207"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span id="local-6989586621679246208"><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246208"><span class="hs-identifier hs-var">binderList</span></a></span></span><span> </span><span id="local-6989586621679246209"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246209"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span id="local-6989586621679246210"><span class="annot"><span class="annottext">forall (l :: S).
Distinct l =&gt;
Scope l
-&gt; Map VarIdent (Name l)
-&gt; NameBinderList i l
-&gt; NameMap l Type
-&gt; r
</span><a href="#local-6989586621679246210"><span class="hs-identifier hs-var">cont</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; Map VarIdent (Name n)
-&gt; NameBinderList i n
-&gt; NameMap n Type
-&gt; r
forall (l :: S).
Distinct l =&gt;
Scope l
-&gt; Map VarIdent (Name l)
-&gt; NameBinderList i l
-&gt; NameMap l Type
-&gt; r
</span><a href="#local-6989586621679246210"><span class="hs-identifier hs-var">cont</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246206"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246207"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246208"><span class="hs-identifier hs-var">binderList</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246209"><span class="hs-identifier hs-var">binderTypes</span></a></span><span>
</span><span id="line-250"></span><span class="annot"><a href="Language.Lambda.Impl.html#withMetaSubstVars"><span class="hs-identifier hs-var">withMetaSubstVars</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#ABinder"><span class="hs-identifier hs-type">Raw.ABinder</span></a></span><span> </span><span id="local-6989586621679246212"><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246212"><span class="hs-identifier hs-var">ident</span></a></span></span><span> </span><span id="local-6989586621679246213"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246213"><span class="hs-identifier hs-var">type_</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679246214"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246214"><span class="hs-identifier hs-var">idents</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679246215"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246215"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246216"><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246216"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span id="local-6989586621679246217"><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246217"><span class="hs-identifier hs-var">binderList</span></a></span></span><span> </span><span id="local-6989586621679246218"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246218"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span id="local-6989586621679246219"><span class="annot"><span class="annottext">forall (l :: S).
Distinct l =&gt;
Scope l
-&gt; Map VarIdent (Name l)
-&gt; NameBinderList i l
-&gt; NameMap l Type
-&gt; r
</span><a href="#local-6989586621679246219"><span class="hs-identifier hs-var">cont</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-251"></span><span>  </span><span class="annot"><span class="annottext">Scope n -&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246215"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r)
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246227"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246227"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-252"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246228"><span class="annot"><span class="annottext">scope' :: Scope l
</span><a href="#local-6989586621679246228"><span class="hs-identifier hs-var hs-var">scope'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Scope n -&gt; Scope l
forall (n :: S) (l :: S). NameBinder n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScope</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246227"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246215"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-253"></span><span>        </span><span id="local-6989586621679246229"><span class="annot"><span class="annottext">name :: Name l
</span><a href="#local-6989586621679246229"><span class="hs-identifier hs-var hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246227"><span class="hs-identifier hs-var">binder</span></a></span><span>
</span><span id="line-254"></span><span>        </span><span id="local-6989586621679246230"><span class="annot"><span class="annottext">env' :: Map VarIdent (Name l)
</span><a href="#local-6989586621679246230"><span class="hs-identifier hs-var hs-var">env'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">VarIdent
-&gt; Name l -&gt; Map VarIdent (Name l) -&gt; Map VarIdent (Name l)
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246212"><span class="hs-identifier hs-var">ident</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679246229"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name n -&gt; Name l
forall (e :: S -&gt; *) (n :: S) (l :: S).
(Sinkable e, DExt n l) =&gt;
e n -&gt; e l
</span><span class="hs-identifier hs-var">Foil.sink</span></span><span> </span><span class="annot"><span class="annottext">(Name n -&gt; Name l)
-&gt; Map VarIdent (Name n) -&gt; Map VarIdent (Name l)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name n)
</span><a href="#local-6989586621679246216"><span class="hs-identifier hs-var">env</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-255"></span><span>        </span><span id="local-6989586621679246231"><span class="annot"><span class="annottext">binderList' :: NameBinderList i l
</span><a href="#local-6989586621679246231"><span class="hs-identifier hs-var hs-var">binderList'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; NameBinderList i n -&gt; NameBinderList i l
forall (i :: S) (l :: S) (n :: S).
NameBinder i l -&gt; NameBinderList n i -&gt; NameBinderList n l
</span><a href="Data.SOAS.html#push"><span class="hs-identifier hs-var">push</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246227"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246217"><span class="hs-identifier hs-var">binderList</span></a></span><span>
</span><span id="line-256"></span><span>        </span><span id="local-6989586621679246233"><span class="annot"><span class="annottext">binderTypes' :: NameMap l Type
</span><a href="#local-6989586621679246233"><span class="hs-identifier hs-var hs-var">binderTypes'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Type -&gt; NameMap n Type -&gt; NameMap l Type
forall (n :: S) (l :: S) a.
NameBinder n l -&gt; a -&gt; NameMap n a -&gt; NameMap l a
</span><span class="hs-identifier hs-var">Foil.addNameBinder</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246227"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246213"><span class="hs-identifier hs-var">type_</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246218"><span class="hs-identifier hs-var">binderTypes</span></a></span><span>
</span><span id="line-257"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[Binder]
-&gt; Scope l
-&gt; Map VarIdent (Name l)
-&gt; NameBinderList i l
-&gt; NameMap l Type
-&gt; (forall (l :: S).
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList i l
    -&gt; NameMap l Type
    -&gt; r)
-&gt; r
forall (n :: S) (i :: S) r.
Distinct n =&gt;
[Binder]
-&gt; Scope n
-&gt; Map VarIdent (Name n)
-&gt; NameBinderList i n
-&gt; NameMap n Type
-&gt; (forall (l :: S).
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList i l
    -&gt; NameMap l Type
    -&gt; r)
-&gt; r
</span><a href="Language.Lambda.Impl.html#withMetaSubstVars"><span class="hs-identifier hs-var">withMetaSubstVars</span></a></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246214"><span class="hs-identifier hs-var">idents</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246228"><span class="hs-identifier hs-var">scope'</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246230"><span class="hs-identifier hs-var">env'</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList i l
</span><a href="#local-6989586621679246231"><span class="hs-identifier hs-var">binderList'</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap l Type
</span><a href="#local-6989586621679246233"><span class="hs-identifier hs-var">binderTypes'</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
-&gt; Map VarIdent (Name l)
-&gt; NameBinderList i l
-&gt; NameMap l Type
-&gt; r
forall (l :: S).
Distinct l =&gt;
Scope l
-&gt; Map VarIdent (Name l)
-&gt; NameBinderList i l
-&gt; NameMap l Type
-&gt; r
</span><a href="#local-6989586621679246219"><span class="hs-identifier hs-var">cont</span></a></span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span class="hs-keyword">type</span><span> </span><span id="MetaSubst%27"><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-var">MetaSubst'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-260"></span><span>  </span><span class="annot"><a href="Data.SOAS.html#MetaSubst"><span class="hs-identifier hs-type">MetaSubst</span></a></span><span>
</span><span id="line-261"></span><span>    </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span>
</span><span id="line-262"></span><span>    </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span>
</span><span id="line-263"></span><span>    </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span>
</span><span id="line-264"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Data.SOAS.html#MetaAppSig"><span class="hs-identifier hs-type">MetaAppSig</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-265"></span><span>    </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span class="hs-keyword">type</span><span> </span><span id="MetaSubsts%27"><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubsts%27"><span class="hs-identifier hs-var">MetaSubsts'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-268"></span><span>  </span><span class="annot"><a href="Data.SOAS.html#MetaSubsts"><span class="hs-identifier hs-type">MetaSubsts</span></a></span><span>
</span><span id="line-269"></span><span>    </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span>
</span><span id="line-270"></span><span>    </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span>
</span><span id="line-271"></span><span>    </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span>
</span><span id="line-272"></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Data.SOAS.html#MetaAppSig"><span class="hs-identifier hs-type">MetaAppSig</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>    </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span class="annot"><a href="Language.Lambda.Impl.html#fromMetaSubst"><span class="hs-identifier hs-type">fromMetaSubst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaSubst"><span class="hs-identifier hs-type">Raw.MetaSubst</span></a></span><span>
</span><span id="line-276"></span><span id="fromMetaSubst"><span class="annot"><span class="annottext">fromMetaSubst :: MetaSubst' -&gt; MetaSubst
</span><a href="Language.Lambda.Impl.html#fromMetaSubst"><span class="hs-identifier hs-var hs-var">fromMetaSubst</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SOAS.html#MetaSubst"><span class="hs-identifier hs-type">MetaSubst</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246238"><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246238"><span class="hs-identifier hs-var">metavar</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.SOAS.html#MetaAbs"><span class="hs-identifier hs-type">MetaAbs</span></a></span><span> </span><span id="local-6989586621679246240"><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246240"><span class="hs-identifier hs-var">binderList</span></a></span></span><span> </span><span id="local-6989586621679246241"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246241"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span id="local-6989586621679246242"><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
</span><a href="#local-6989586621679246242"><span class="hs-identifier hs-var">term</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-277"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246243"><span class="annot"><span class="annottext">term' :: ScopedTerm
</span><a href="#local-6989586621679246243"><span class="hs-identifier hs-var hs-var">term'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; ScopedTerm
</span><a href="Language.Lambda.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; ScopedTerm) -&gt; Term -&gt; ScopedTerm
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term n -&gt; Term
forall (n :: S). Term n -&gt; Term
</span><a href="Language.Lambda.Impl.html#fromTerm"><span class="hs-identifier hs-var">fromTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term n -&gt; Term) -&gt; Term n -&gt; Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n -&gt; Term n
forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var">fromMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
</span><a href="#local-6989586621679246242"><span class="hs-identifier hs-var">term</span></a></span><span>
</span><span id="line-278"></span><span>      </span><span id="local-6989586621679246246"><span class="annot"><span class="annottext">idents :: [Binder]
</span><a href="#local-6989586621679246246"><span class="hs-identifier hs-var hs-var">idents</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS n -&gt; NameMap n Type -&gt; [Binder]
forall (i :: S) (n :: S).
Distinct i =&gt;
NameBinderList i n -&gt; NameMap n Type -&gt; [Binder]
</span><a href="Language.Lambda.Impl.html#toBinders"><span class="hs-identifier hs-var">toBinders</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246240"><span class="hs-identifier hs-var">binderList</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246241"><span class="hs-identifier hs-var">binderTypes</span></a></span><span>
</span><span id="line-279"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">MetaVarIdent -&gt; [Binder] -&gt; ScopedTerm -&gt; MetaSubst
</span><a href="Language.Lambda.Syntax.Abs.html#AMetaSubst"><span class="hs-identifier hs-var">Raw.AMetaSubst</span></a></span><span> </span><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246238"><span class="hs-identifier hs-var">metavar</span></a></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246246"><span class="hs-identifier hs-var">idents</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246243"><span class="hs-identifier hs-var">term'</span></a></span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span id="local-6989586621679245267"><span id="local-6989586621679245268"><span class="annot"><a href="Language.Lambda.Impl.html#toBinders"><span class="hs-identifier hs-type">toBinders</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245267"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameBinderList</span></span><span> </span><span class="annot"><a href="#local-6989586621679245267"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245268"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679245268"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Binder"><span class="hs-identifier hs-type">Raw.Binder</span></a></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-282"></span><span id="toBinders"><span class="annot"><span class="annottext">toBinders :: forall (i :: S) (n :: S).
Distinct i =&gt;
NameBinderList i n -&gt; NameMap n Type -&gt; [Binder]
</span><a href="Language.Lambda.Impl.html#toBinders"><span class="hs-identifier hs-var hs-var">toBinders</span></a></span></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n
</span><span class="hs-identifier hs-var">NameBinderListEmpty</span></span><span> </span><span id="local-6989586621679246250"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246250"><span class="hs-identifier hs-var">_binderTypes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-283"></span><span class="annot"><a href="Language.Lambda.Impl.html#toBinders"><span class="hs-identifier hs-var">toBinders</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NameBinderListCons</span></span><span> </span><span id="local-6989586621679246254"><span class="annot"><span class="annottext">NameBinder i i
</span><a href="#local-6989586621679246254"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679246255"><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246255"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679246256"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246256"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">DistinctEvidence i
</span><span class="hs-identifier hs-var">Foil.Distinct</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameBinder i i -&gt; DistinctEvidence i
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; DistinctEvidence l
</span><span class="hs-identifier hs-var">Foil.assertDistinct</span></span><span> </span><span class="annot"><span class="annottext">NameBinder i i
</span><a href="#local-6989586621679246254"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DistinctEvidence n
</span><span class="hs-identifier hs-var">Foil.Distinct</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameBinderList i n -&gt; DistinctEvidence n
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; DistinctEvidence l
</span><span class="hs-identifier hs-var">Foil.assertDistinct</span></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246255"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ExtEvidence i n
</span><span class="hs-identifier hs-var">Foil.Ext</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">NameBinderList i n -&gt; ExtEvidence i n
forall (pattern :: S -&gt; S -&gt; *) (n :: S) (l :: S).
CoSinkable pattern =&gt;
pattern n l -&gt; ExtEvidence n l
</span><span class="hs-identifier hs-var">Foil.assertExt</span></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246255"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-287"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246274"><span class="annot"><span class="annottext">ident :: VarIdent
</span><a href="#local-6989586621679246274"><span class="hs-identifier hs-var hs-var">ident</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; VarIdent
</span><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-var">Raw.VarIdent</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; VarIdent) -&gt; String -&gt; VarIdent
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;x&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name i -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder i i -&gt; Name i
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder i i
</span><a href="#local-6989586621679246254"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span>          </span><span id="local-6989586621679246277"><span class="annot"><span class="annottext">typ :: Type
</span><a href="#local-6989586621679246277"><span class="hs-identifier hs-var hs-var">typ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name n -&gt; NameMap n Type -&gt; Type
forall (n :: S) a. Name n -&gt; NameMap n a -&gt; a
</span><span class="hs-identifier hs-var">Foil.lookupName</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name i -&gt; Name n
forall (e :: S -&gt; *) (n :: S) (l :: S).
(Sinkable e, DExt n l) =&gt;
e n -&gt; e l
</span><span class="hs-identifier hs-var">Foil.sink</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder i i -&gt; Name i
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder i i
</span><a href="#local-6989586621679246254"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246256"><span class="hs-identifier hs-var">binderTypes</span></a></span><span>
</span><span id="line-289"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">VarIdent -&gt; Type -&gt; Binder
</span><a href="Language.Lambda.Syntax.Abs.html#ABinder"><span class="hs-identifier hs-var">Raw.ABinder</span></a></span><span> </span><span class="annot"><span class="annottext">VarIdent
</span><a href="#local-6989586621679246274"><span class="hs-identifier hs-var">ident</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246277"><span class="hs-identifier hs-var">typ</span></a></span><span> </span><span class="annot"><span class="annottext">Binder -&gt; [Binder] -&gt; [Binder]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n -&gt; NameMap n Type -&gt; [Binder]
forall (i :: S) (n :: S).
Distinct i =&gt;
NameBinderList i n -&gt; NameMap n Type -&gt; [Binder]
</span><a href="Language.Lambda.Impl.html#toBinders"><span class="hs-identifier hs-var">toBinders</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList i n
</span><a href="#local-6989586621679246255"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246256"><span class="hs-identifier hs-var">binderTypes</span></a></span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span class="hs-keyword">data</span><span> </span><span id="UnificationConstraint"><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-var">UnificationConstraint</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-292"></span><span>  </span><span id="local-6989586621679246279"><span id="UnificationConstraint"><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-var">UnificationConstraint</span></a></span></span><span>
</span><span id="line-293"></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679246279"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-294"></span><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679246279"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-295"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameBinderList</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span> </span><span class="annot"><a href="#local-6989586621679246279"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-296"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.NameMap</span></span><span> </span><span class="annot"><a href="#local-6989586621679246279"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-297"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246279"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-298"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246279"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-299"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span></span><span>
</span><span id="line-300"></span><span>
</span><span id="line-301"></span><span class="annot"><a href="Language.Lambda.Impl.html#toUnificationConstraint"><span class="hs-identifier hs-type">toUnificationConstraint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#UnificationConstraint"><span class="hs-identifier hs-type">Raw.UnificationConstraint</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span>
</span><span id="line-302"></span><span id="toUnificationConstraint"><span class="annot"><span class="annottext">toUnificationConstraint :: UnificationConstraint -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#toUnificationConstraint"><span class="hs-identifier hs-var hs-var">toUnificationConstraint</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#AUnificationConstraint"><span class="hs-identifier hs-type">Raw.AUnificationConstraint</span></a></span><span> </span><span id="local-6989586621679246283"><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246283"><span class="hs-identifier hs-var">vars</span></a></span></span><span> </span><span id="local-6989586621679246284"><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246284"><span class="hs-identifier hs-var">lhs</span></a></span></span><span> </span><span id="local-6989586621679246285"><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246285"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-303"></span><span>  </span><span class="annot"><span class="annottext">[Binder]
-&gt; Scope 'VoidS
-&gt; Map VarIdent (Name 'VoidS)
-&gt; NameBinderList 'VoidS 'VoidS
-&gt; NameMap 'VoidS Type
-&gt; (forall {l :: S}.
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList 'VoidS l
    -&gt; NameMap l Type
    -&gt; UnificationConstraint)
-&gt; UnificationConstraint
forall (n :: S) (i :: S) r.
Distinct n =&gt;
[Binder]
-&gt; Scope n
-&gt; Map VarIdent (Name n)
-&gt; NameBinderList i n
-&gt; NameMap n Type
-&gt; (forall (l :: S).
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList i l
    -&gt; NameMap l Type
    -&gt; r)
-&gt; r
</span><a href="Language.Lambda.Impl.html#withMetaSubstVars"><span class="hs-identifier hs-var">withMetaSubstVars</span></a></span><span> </span><span class="annot"><span class="annottext">[Binder]
</span><a href="#local-6989586621679246283"><span class="hs-identifier hs-var">vars</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name 'VoidS)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS 'VoidS
forall (n :: S). NameBinderList n n
</span><span class="hs-identifier hs-var">NameBinderListEmpty</span></span><span> </span><span class="annot"><span class="annottext">NameMap 'VoidS Type
forall a. NameMap 'VoidS a
</span><span class="hs-identifier hs-var">Foil.emptyNameMap</span></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}.
  Distinct l =&gt;
  Scope l
  -&gt; Map VarIdent (Name l)
  -&gt; NameBinderList 'VoidS l
  -&gt; NameMap l Type
  -&gt; UnificationConstraint)
 -&gt; UnificationConstraint)
-&gt; (forall {l :: S}.
    Distinct l =&gt;
    Scope l
    -&gt; Map VarIdent (Name l)
    -&gt; NameBinderList 'VoidS l
    -&gt; NameMap l Type
    -&gt; UnificationConstraint)
-&gt; UnificationConstraint
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246289"><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246289"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246290"><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246290"><span class="hs-identifier hs-var">env</span></a></span></span><span> </span><span id="local-6989586621679246291"><span class="annot"><span class="annottext">NameBinderList 'VoidS l
</span><a href="#local-6989586621679246291"><span class="hs-identifier hs-var">binders</span></a></span></span><span> </span><span id="local-6989586621679246292"><span class="annot"><span class="annottext">NameMap l Type
</span><a href="#local-6989586621679246292"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-304"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246293"><span class="annot"><span class="annottext">toMetaTerm' :: ScopedTerm -&gt; MetaTerm MetaVarIdent l
</span><a href="#local-6989586621679246293"><span class="hs-identifier hs-var hs-var">toMetaTerm'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term l -&gt; MetaTerm MetaVarIdent l
forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var">toMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term l -&gt; MetaTerm MetaVarIdent l)
-&gt; (ScopedTerm -&gt; Term l) -&gt; ScopedTerm -&gt; MetaTerm MetaVarIdent l
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Scope l -&gt; Map VarIdent (Name l) -&gt; Term -&gt; Term l
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; Term n
</span><a href="Language.Lambda.Impl.html#toTerm"><span class="hs-identifier hs-var">toTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246289"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name l)
</span><a href="#local-6989586621679246290"><span class="hs-identifier hs-var">env</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Term l) -&gt; (ScopedTerm -&gt; Term) -&gt; ScopedTerm -&gt; Term l
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ScopedTerm -&gt; Term
</span><a href="Language.Lambda.Impl.html#getTermFromScopedTerm"><span class="hs-identifier hs-var">getTermFromScopedTerm</span></a></span><span>
</span><span id="line-305"></span><span>     </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope l
-&gt; NameBinderList 'VoidS l
-&gt; NameMap l Type
-&gt; MetaTerm MetaVarIdent l
-&gt; MetaTerm MetaVarIdent l
-&gt; UnificationConstraint
forall (n :: S).
Distinct n =&gt;
Scope n
-&gt; NameBinderList 'VoidS n
-&gt; NameMap n Type
-&gt; MetaTerm MetaVarIdent n
-&gt; MetaTerm MetaVarIdent n
-&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-var">UnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l
</span><a href="#local-6989586621679246289"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS l
</span><a href="#local-6989586621679246291"><span class="hs-identifier hs-var">binders</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap l Type
</span><a href="#local-6989586621679246292"><span class="hs-identifier hs-var">binderTypes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScopedTerm -&gt; MetaTerm MetaVarIdent l
</span><a href="#local-6989586621679246293"><span class="hs-identifier hs-var">toMetaTerm'</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246284"><span class="hs-identifier hs-var">lhs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScopedTerm -&gt; MetaTerm MetaVarIdent l
</span><a href="#local-6989586621679246293"><span class="hs-identifier hs-var">toMetaTerm'</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm
</span><a href="#local-6989586621679246285"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-306"></span><span>
</span><span id="line-307"></span><span class="annot"><a href="Language.Lambda.Impl.html#fromUnificationConstraint"><span class="hs-identifier hs-type">fromUnificationConstraint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#UnificationConstraint"><span class="hs-identifier hs-type">Raw.UnificationConstraint</span></a></span><span>
</span><span id="line-308"></span><span id="fromUnificationConstraint"><span class="annot"><span class="annottext">fromUnificationConstraint :: UnificationConstraint -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#fromUnificationConstraint"><span class="hs-identifier hs-var hs-var">fromUnificationConstraint</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679246298"><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246298"><span class="hs-identifier hs-var">binders</span></a></span></span><span> </span><span id="local-6989586621679246299"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246299"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span id="local-6989586621679246300"><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246300"><span class="hs-identifier hs-var">lhs</span></a></span></span><span> </span><span id="local-6989586621679246301"><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246301"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-309"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246302"><span class="annot"><span class="annottext">fromMetaTerm' :: MetaTerm MetaVarIdent n -&gt; ScopedTerm
</span><a href="#local-6989586621679246302"><span class="hs-identifier hs-var hs-var">fromMetaTerm'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; ScopedTerm
</span><a href="Language.Lambda.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; ScopedTerm)
-&gt; (MetaTerm MetaVarIdent n -&gt; Term)
-&gt; MetaTerm MetaVarIdent n
-&gt; ScopedTerm
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Term n -&gt; Term
forall (n :: S). Term n -&gt; Term
</span><a href="Language.Lambda.Impl.html#fromTerm"><span class="hs-identifier hs-var">fromTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term n -&gt; Term)
-&gt; (MetaTerm MetaVarIdent n -&gt; Term n)
-&gt; MetaTerm MetaVarIdent n
-&gt; Term
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; Term n
forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var">fromMetaTerm</span></a></span><span>
</span><span id="line-310"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[Binder] -&gt; ScopedTerm -&gt; ScopedTerm -&gt; UnificationConstraint
</span><a href="Language.Lambda.Syntax.Abs.html#AUnificationConstraint"><span class="hs-identifier hs-var">Raw.AUnificationConstraint</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinderList 'VoidS n -&gt; NameMap n Type -&gt; [Binder]
forall (i :: S) (n :: S).
Distinct i =&gt;
NameBinderList i n -&gt; NameMap n Type -&gt; [Binder]
</span><a href="Language.Lambda.Impl.html#toBinders"><span class="hs-identifier hs-var">toBinders</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246298"><span class="hs-identifier hs-var">binders</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246299"><span class="hs-identifier hs-var">binderTypes</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; ScopedTerm
forall {n :: S}. MetaTerm MetaVarIdent n -&gt; ScopedTerm
</span><a href="#local-6989586621679246302"><span class="hs-identifier hs-var">fromMetaTerm'</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246300"><span class="hs-identifier hs-var">lhs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; ScopedTerm
forall {n :: S}. MetaTerm MetaVarIdent n -&gt; ScopedTerm
</span><a href="#local-6989586621679246302"><span class="hs-identifier hs-var">fromMetaTerm'</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246301"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span class="annot"><span class="hs-comment">-- ** Conversion helpers for 'MetaTerm'</span></span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span id="local-6989586621679245251"><span class="annot"><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-type">toMetaTerm</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245251"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245251"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-315"></span><span id="toMetaTerm"><span class="annot"><span class="annottext">toMetaTerm :: forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var hs-var">toMetaTerm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-316"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaVar"><span class="hs-identifier hs-type">MetaVar</span></a></span><span> </span><span id="local-6989586621679246304"><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246304"><span class="hs-identifier hs-var">metavar</span></a></span></span><span> </span><span id="local-6989586621679246305"><span class="annot"><span class="annottext">[Term n]
</span><a href="#local-6989586621679246305"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MetaVarIdent
-&gt; [MetaTerm MetaVarIdent n] -&gt; MetaTerm MetaVarIdent n
forall metavar (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *)
       (n :: S).
metavar -&gt; [SOAS binder metavar sig n] -&gt; SOAS binder metavar sig n
</span><a href="Data.SOAS.html#MetaApp"><span class="hs-identifier hs-var">MetaApp</span></a></span><span> </span><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246304"><span class="hs-identifier hs-var">metavar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Term n -&gt; MetaTerm MetaVarIdent n)
-&gt; [Term n] -&gt; [MetaTerm MetaVarIdent n]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Term n -&gt; MetaTerm MetaVarIdent n
forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var">toMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">[Term n]
</span><a href="#local-6989586621679246305"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-317"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Var</span></span><span> </span><span id="local-6989586621679246306"><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246306"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name n -&gt; MetaTerm MetaVarIdent n
forall (n :: S) (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *).
Name n -&gt; AST binder sig n
</span><span class="hs-identifier hs-var">Var</span></span><span> </span><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246306"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-318"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span id="local-6989586621679246307"><span class="annot"><span class="annottext">TermSig (ScopedAST FoilPattern TermSig n) (Term n)
</span><a href="#local-6989586621679246307"><span class="hs-identifier hs-var">node</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Sum
  TermSig
  (MetaAppSig MetaVarIdent)
  (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
  (MetaTerm MetaVarIdent n)
-&gt; MetaTerm MetaVarIdent n
forall (sig :: * -&gt; * -&gt; *) (binder :: S -&gt; S -&gt; *) (n :: S).
sig (ScopedAST binder sig n) (AST binder sig n) -&gt; AST binder sig n
</span><span class="hs-identifier hs-var">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TermSig
  (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
  (MetaTerm MetaVarIdent n)
-&gt; Sum
     TermSig
     (MetaAppSig MetaVarIdent)
     (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
     (MetaTerm MetaVarIdent n)
forall {k} {k1} (p :: k -&gt; k1 -&gt; *) (q :: k -&gt; k1 -&gt; *) (a :: k)
       (b :: k1).
p a b -&gt; Sum p q a b
</span><span class="hs-identifier hs-var">L2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ScopedAST FoilPattern TermSig n
 -&gt; ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
-&gt; (Term n -&gt; MetaTerm MetaVarIdent n)
-&gt; TermSig (ScopedAST FoilPattern TermSig n) (Term n)
-&gt; TermSig
     (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
     (MetaTerm MetaVarIdent n)
forall a b c d. (a -&gt; b) -&gt; (c -&gt; d) -&gt; TermSig a c -&gt; TermSig b d
forall (p :: * -&gt; * -&gt; *) a b c d.
Bifunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d
</span><span class="hs-identifier hs-var">bimap</span></span><span> </span><span class="annot"><span class="annottext">ScopedAST FoilPattern TermSig n
-&gt; ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
forall {n :: S}.
ScopedAST FoilPattern TermSig n
-&gt; ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
</span><a href="#local-6989586621679246308"><span class="hs-identifier hs-var">toMetaScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Term n -&gt; MetaTerm MetaVarIdent n
forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var">toMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">TermSig (ScopedAST FoilPattern TermSig n) (Term n)
</span><a href="#local-6989586621679246307"><span class="hs-identifier hs-var">node</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-320"></span><span>  </span><span id="local-6989586621679246308"><span class="annot"><span class="annottext">toMetaScopedTerm :: ScopedAST FoilPattern TermSig n
-&gt; ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
</span><a href="#local-6989586621679246308"><span class="hs-identifier hs-var hs-var">toMetaScopedTerm</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ScopedAST</span></span><span> </span><span id="local-6989586621679246309"><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246309"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246310"><span class="annot"><span class="annottext">AST FoilPattern TermSig l
</span><a href="#local-6989586621679246310"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
-&gt; ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
forall (binder :: S -&gt; S -&gt; *) (n :: S) (l :: S)
       (sig :: * -&gt; * -&gt; *).
binder n l -&gt; AST binder sig l -&gt; ScopedAST binder sig n
</span><span class="hs-identifier hs-var">ScopedAST</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246309"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AST FoilPattern TermSig l
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var">toMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern TermSig l
</span><a href="#local-6989586621679246310"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span id="local-6989586621679245266"><span class="annot"><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-type">fromMetaTerm</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245266"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245266"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-323"></span><span id="fromMetaTerm"><span class="annot"><span class="annottext">fromMetaTerm :: forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var hs-var">fromMetaTerm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-324"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Var</span></span><span> </span><span id="local-6989586621679246312"><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246312"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name n -&gt; Term n
forall (n :: S) (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *).
Name n -&gt; AST binder sig n
</span><span class="hs-identifier hs-var">Var</span></span><span> </span><span class="annot"><span class="annottext">Name n
</span><a href="#local-6989586621679246312"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-325"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">R2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SOAS.html#MetaAppSig"><span class="hs-identifier hs-type">MetaAppSig</span></a></span><span> </span><span id="local-6989586621679246315"><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246315"><span class="hs-identifier hs-var">metavar</span></a></span></span><span> </span><span id="local-6989586621679246316"><span class="annot"><span class="annottext">[MetaTerm MetaVarIdent n]
</span><a href="#local-6989586621679246316"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">MetaVarIdent -&gt; [Term n] -&gt; Term n
forall (binder :: S -&gt; S -&gt; *) (n :: S).
MetaVarIdent -&gt; [AST binder TermSig n] -&gt; AST binder TermSig n
</span><a href="Language.Lambda.Impl.html#MetaVar"><span class="hs-identifier hs-var">MetaVar</span></a></span><span> </span><span class="annot"><span class="annottext">MetaVarIdent
</span><a href="#local-6989586621679246315"><span class="hs-identifier hs-var">metavar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(MetaTerm MetaVarIdent n -&gt; Term n)
-&gt; [MetaTerm MetaVarIdent n] -&gt; [Term n]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; Term n
forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var">fromMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">[MetaTerm MetaVarIdent n]
</span><a href="#local-6989586621679246316"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-326"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L2</span></span><span> </span><span id="local-6989586621679246317"><span class="annot"><span class="annottext">TermSig
  (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
  (MetaTerm MetaVarIdent n)
</span><a href="#local-6989586621679246317"><span class="hs-identifier hs-var">node</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">TermSig (ScopedAST FoilPattern TermSig n) (Term n) -&gt; Term n
forall (sig :: * -&gt; * -&gt; *) (binder :: S -&gt; S -&gt; *) (n :: S).
sig (ScopedAST binder sig n) (AST binder sig n) -&gt; AST binder sig n
</span><span class="hs-identifier hs-var">Node</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
 -&gt; ScopedAST FoilPattern TermSig n)
-&gt; (MetaTerm MetaVarIdent n -&gt; Term n)
-&gt; TermSig
     (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
     (MetaTerm MetaVarIdent n)
-&gt; TermSig (ScopedAST FoilPattern TermSig n) (Term n)
forall a b c d. (a -&gt; b) -&gt; (c -&gt; d) -&gt; TermSig a c -&gt; TermSig b d
forall (p :: * -&gt; * -&gt; *) a b c d.
Bifunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d
</span><span class="hs-identifier hs-var">bimap</span></span><span> </span><span class="annot"><span class="annottext">ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
-&gt; ScopedAST FoilPattern TermSig n
forall {n :: S}.
ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
-&gt; ScopedAST FoilPattern TermSig n
</span><a href="#local-6989586621679246318"><span class="hs-identifier hs-var">fromMetaScopedTerm</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; Term n
forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var">fromMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">TermSig
  (ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n)
  (MetaTerm MetaVarIdent n)
</span><a href="#local-6989586621679246317"><span class="hs-identifier hs-var">node</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-328"></span><span>  </span><span id="local-6989586621679246318"><span class="annot"><span class="annottext">fromMetaScopedTerm :: ScopedAST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) n
-&gt; ScopedAST FoilPattern TermSig n
</span><a href="#local-6989586621679246318"><span class="hs-identifier hs-var hs-var">fromMetaScopedTerm</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ScopedAST</span></span><span> </span><span id="local-6989586621679246319"><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246319"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246320"><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
</span><a href="#local-6989586621679246320"><span class="hs-identifier hs-var">body</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
-&gt; AST FoilPattern TermSig l -&gt; ScopedAST FoilPattern TermSig n
forall (binder :: S -&gt; S -&gt; *) (n :: S) (l :: S)
       (sig :: * -&gt; * -&gt; *).
binder n l -&gt; AST binder sig l -&gt; ScopedAST binder sig n
</span><span class="hs-identifier hs-var">ScopedAST</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l
</span><a href="#local-6989586621679246319"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
-&gt; AST FoilPattern TermSig l
forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var">fromMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern (Sum TermSig (MetaAppSig MetaVarIdent)) l
</span><a href="#local-6989586621679246320"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-329"></span><span>
</span><span id="line-330"></span><span class="annot"><span class="hs-comment">-- ** Conversion helpers</span></span><span>
</span><span id="line-331"></span><span>
</span><span id="line-332"></span><span class="hs-comment">-- | Convert 'Raw.Term'' into a scope-safe term.</span><span>
</span><span id="line-333"></span><span class="hs-comment">-- This is a special case of 'convertToAST'.</span><span>
</span><span id="line-334"></span><span id="local-6989586621679245239"><span class="annot"><a href="Language.Lambda.Impl.html#toTerm"><span class="hs-identifier hs-type">toTerm</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245239"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245239"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-type">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245239"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245239"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-335"></span><span id="toTerm"><span class="annot"><span class="annottext">toTerm :: forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; Term n
</span><a href="Language.Lambda.Impl.html#toTerm"><span class="hs-identifier hs-var hs-var">toTerm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Either VarIdent (TermSig (Pattern, ScopedTerm) Term))
-&gt; (forall (n :: S) r.
    Distinct n =&gt;
    Scope n
    -&gt; Map VarIdent (Name n)
    -&gt; Pattern
    -&gt; (forall (l :: S).
        DExt n l =&gt;
        FoilPattern n l -&gt; Map VarIdent (Name l) -&gt; r)
    -&gt; r)
-&gt; (ScopedTerm -&gt; Term)
-&gt; Scope n
-&gt; Map VarIdent (Name n)
-&gt; Term
-&gt; AST FoilPattern TermSig n
forall (n :: S) (sig :: * -&gt; * -&gt; *) rawIdent
       (binder :: S -&gt; S -&gt; *) rawTerm rawPattern rawScopedTerm.
(Distinct n, Bifunctor sig, Ord rawIdent, CoSinkable binder) =&gt;
(rawTerm
 -&gt; Either rawIdent (sig (rawPattern, rawScopedTerm) rawTerm))
-&gt; (forall (x :: S) z.
    Distinct x =&gt;
    Scope x
    -&gt; Map rawIdent (Name x)
    -&gt; rawPattern
    -&gt; (forall (y :: S).
        DExt x y =&gt;
        binder x y -&gt; Map rawIdent (Name y) -&gt; z)
    -&gt; z)
-&gt; (rawScopedTerm -&gt; rawTerm)
-&gt; Scope n
-&gt; Map rawIdent (Name n)
-&gt; rawTerm
-&gt; AST binder sig n
</span><span class="hs-identifier hs-var">convertToAST</span></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Either VarIdent (TermSig (Pattern, ScopedTerm) Term)
</span><a href="Language.Lambda.Impl.html#convertToTermSig"><span class="hs-identifier hs-var">convertToTermSig</span></a></span><span> </span><span class="annot"><span class="annottext">Scope x
-&gt; Map VarIdent (Name x)
-&gt; Pattern
-&gt; (forall (l :: S).
    DExt x l =&gt;
    FoilPattern x l -&gt; Map VarIdent (Name l) -&gt; z)
-&gt; z
forall (n :: S) r.
Distinct n =&gt;
Scope n
-&gt; Map VarIdent (Name n)
-&gt; Pattern
-&gt; (forall (l :: S).
    DExt n l =&gt;
    FoilPattern n l -&gt; Map VarIdent (Name l) -&gt; r)
-&gt; r
</span><a href="Language.Lambda.Impl.html#toFoilPattern"><span class="hs-identifier hs-var">toFoilPattern</span></a></span><span> </span><span class="annot"><span class="annottext">ScopedTerm -&gt; Term
</span><a href="Language.Lambda.Impl.html#getTermFromScopedTerm"><span class="hs-identifier hs-var">getTermFromScopedTerm</span></a></span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span class="hs-comment">-- | Convert 'Raw.Term'' into a closed scope-safe term.</span><span>
</span><span id="line-338"></span><span class="hs-comment">-- This is a special case of 'toTerm''.</span><span>
</span><span id="line-339"></span><span class="annot"><a href="Language.Lambda.Impl.html#toTermClosed"><span class="hs-identifier hs-type">toTermClosed</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span>
</span><span id="line-340"></span><span id="toTermClosed"><span class="annot"><span class="annottext">toTermClosed :: Term -&gt; Term 'VoidS
</span><a href="Language.Lambda.Impl.html#toTermClosed"><span class="hs-identifier hs-var hs-var">toTermClosed</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS -&gt; Map VarIdent (Name 'VoidS) -&gt; Term -&gt; Term 'VoidS
forall (n :: S).
Distinct n =&gt;
Scope n -&gt; Map VarIdent (Name n) -&gt; Term -&gt; Term n
</span><a href="Language.Lambda.Impl.html#toTerm"><span class="hs-identifier hs-var">toTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="annot"><span class="annottext">Map VarIdent (Name 'VoidS)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span id="local-6989586621679245265"><span class="annot"><a href="Language.Lambda.Impl.html#fromTerm"><span class="hs-identifier hs-type">fromTerm</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245265"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Term"><span class="hs-identifier hs-type">Raw.Term</span></a></span></span><span>
</span><span id="line-343"></span><span id="fromTerm"><span class="annot"><span class="annottext">fromTerm :: forall (n :: S). Term n -&gt; Term
</span><a href="Language.Lambda.Impl.html#fromTerm"><span class="hs-identifier hs-var hs-var">fromTerm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-344"></span><span>  </span><span class="annot"><span class="annottext">(TermSig (Pattern, ScopedTerm) Term -&gt; Term)
-&gt; (VarIdent -&gt; Term)
-&gt; (forall (x :: S) (y :: S). FoilPattern x y -&gt; Pattern)
-&gt; (Term -&gt; ScopedTerm)
-&gt; (Int -&gt; VarIdent)
-&gt; AST FoilPattern TermSig n
-&gt; Term
forall (sig :: * -&gt; * -&gt; *) rawPattern rawScopedTerm rawTerm
       rawIdent (binder :: S -&gt; S -&gt; *) (n :: S).
Bifunctor sig =&gt;
(sig (rawPattern, rawScopedTerm) rawTerm -&gt; rawTerm)
-&gt; (rawIdent -&gt; rawTerm)
-&gt; (forall (x :: S) (y :: S). binder x y -&gt; rawPattern)
-&gt; (rawTerm -&gt; rawScopedTerm)
-&gt; (Int -&gt; rawIdent)
-&gt; AST binder sig n
-&gt; rawTerm
</span><span class="hs-identifier hs-var">convertFromAST</span></span><span>
</span><span id="line-345"></span><span>    </span><span class="annot"><span class="annottext">TermSig (Pattern, ScopedTerm) Term -&gt; Term
</span><a href="Language.Lambda.Impl.html#convertFromTermSig"><span class="hs-identifier hs-var">convertFromTermSig</span></a></span><span>
</span><span id="line-346"></span><span>    </span><span class="annot"><span class="annottext">VarIdent -&gt; Term
</span><a href="Language.Lambda.Syntax.Abs.html#Var"><span class="hs-identifier hs-var">Raw.Var</span></a></span><span>
</span><span id="line-347"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; VarIdent) -&gt; FoilPattern x y -&gt; Pattern
forall (n :: S) (l :: S).
(Int -&gt; VarIdent) -&gt; FoilPattern n l -&gt; Pattern
</span><a href="Language.Lambda.Impl.html#fromFoilPattern"><span class="hs-identifier hs-var">fromFoilPattern</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679246338"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679246338"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; VarIdent
</span><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-var">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;x&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679246338"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-348"></span><span>    </span><span class="annot"><span class="annottext">Term -&gt; ScopedTerm
</span><a href="Language.Lambda.Syntax.Abs.html#AScopedTerm"><span class="hs-identifier hs-var">Raw.AScopedTerm</span></a></span><span>
</span><span id="line-349"></span><span>    </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679246339"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679246339"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; VarIdent
</span><a href="Language.Lambda.Syntax.Abs.html#VarIdent"><span class="hs-identifier hs-var">Raw.VarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;x&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679246339"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span class="hs-comment">-- &gt;&gt;&gt; lam (Raw.Base (Raw.VarIdent &quot;t&quot;)) Foil.emptyScope (\x -&gt; App (MetaVar (Raw.MetaVarIdent &quot;X&quot;) []) (Var x))</span><span>
</span><span id="line-352"></span><span class="hs-comment">-- &#955; x0 : t . X [] x0</span><span>
</span><span id="line-353"></span><span id="local-6989586621679245324"><span class="annot"><a href="Language.Lambda.Impl.html#lam"><span class="hs-identifier hs-type">lam</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245324"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245324"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679245325"><span class="annot"><a href="#local-6989586621679245325"><span class="hs-identifier hs-type">l</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.DExt</span></span><span> </span><span class="annot"><a href="#local-6989586621679245324"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245325"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245325"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245325"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245324"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-354"></span><span id="lam"><span class="annot"><span class="annottext">lam :: forall (n :: S).
Distinct n =&gt;
Type
-&gt; Scope n
-&gt; (forall (l :: S). DExt n l =&gt; Name l -&gt; Term l)
-&gt; Term n
</span><a href="Language.Lambda.Impl.html#lam"><span class="hs-identifier hs-var hs-var">lam</span></a></span></span><span> </span><span id="local-6989586621679246343"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246343"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span id="local-6989586621679246344"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246344"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246345"><span class="annot"><span class="annottext">forall (l :: S). DExt n l =&gt; Name l -&gt; Term l
</span><a href="#local-6989586621679246345"><span class="hs-identifier hs-var">makeBody</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; Term n)
-&gt; Term n
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">Foil.withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246344"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; Term n) -&gt; Term n)
-&gt; (forall {l :: S}. DExt n l =&gt; NameBinder n l -&gt; Term n)
-&gt; Term n
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246348"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246348"><span class="hs-identifier hs-var">x'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-355"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246349"><span class="annot"><span class="annottext">x :: Name l
</span><a href="#local-6989586621679246349"><span class="hs-identifier hs-var hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246348"><span class="hs-identifier hs-var">x'</span></a></span><span>
</span><span id="line-356"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Type -&gt; FoilPattern n l -&gt; AST FoilPattern TermSig l -&gt; Term n
forall (binder :: S -&gt; S -&gt; *) (n :: S) (l1 :: S).
Type
-&gt; binder n l1 -&gt; AST binder TermSig l1 -&gt; AST binder TermSig n
</span><a href="Language.Lambda.Impl.html#Lam"><span class="hs-identifier hs-var">Lam</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246343"><span class="hs-identifier hs-var">typ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder n l -&gt; FoilPattern n l
forall (n :: S) (n1 :: S). NameBinder n n1 -&gt; FoilPattern n n1
</span><a href="Language.Lambda.Impl.html#FoilAPattern"><span class="hs-identifier hs-var">FoilAPattern</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246348"><span class="hs-identifier hs-var">x'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name l -&gt; AST FoilPattern TermSig l
forall (l :: S). DExt n l =&gt; Name l -&gt; Term l
</span><a href="#local-6989586621679246345"><span class="hs-identifier hs-var">makeBody</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679246349"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-357"></span><span>
</span><span id="line-358"></span><span id="local-6989586621679245329"><span id="local-6989586621679245331"><span class="annot"><a href="Language.Lambda.Impl.html#lam%27"><span class="hs-identifier hs-type">lam'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245329"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245329"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679245330"><span class="annot"><a href="#local-6989586621679245330"><span class="hs-identifier hs-type">l</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.DExt</span></span><span> </span><span class="annot"><a href="#local-6989586621679245329"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245330"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Name</span></span><span> </span><span class="annot"><a href="#local-6989586621679245330"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245331"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245330"><span class="hs-identifier hs-type">l</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245331"><span class="hs-identifier hs-type">metavar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245329"><span class="hs-identifier hs-type">n</span></a></span></span></span><span>
</span><span id="line-359"></span><span id="lam%27"><span class="annot"><span class="annottext">lam' :: forall (n :: S) metavar.
Distinct n =&gt;
Type
-&gt; Scope n
-&gt; (forall (l :: S). DExt n l =&gt; Name l -&gt; MetaTerm metavar l)
-&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#lam%27"><span class="hs-identifier hs-var hs-var">lam'</span></a></span></span><span> </span><span id="local-6989586621679246353"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246353"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span id="local-6989586621679246354"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246354"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246355"><span class="annot"><span class="annottext">forall (l :: S). DExt n l =&gt; Name l -&gt; MetaTerm metavar l
</span><a href="#local-6989586621679246355"><span class="hs-identifier hs-var">makeBody</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; (forall {l :: S}.
    DExt n l =&gt;
    NameBinder n l -&gt; MetaTerm metavar n)
-&gt; MetaTerm metavar n
forall (n :: S) r.
Distinct n =&gt;
Scope n -&gt; (forall (l :: S). DExt n l =&gt; NameBinder n l -&gt; r) -&gt; r
</span><span class="hs-identifier hs-var">Foil.withFresh</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246354"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">((forall {l :: S}.
  DExt n l =&gt;
  NameBinder n l -&gt; MetaTerm metavar n)
 -&gt; MetaTerm metavar n)
-&gt; (forall {l :: S}.
    DExt n l =&gt;
    NameBinder n l -&gt; MetaTerm metavar n)
-&gt; MetaTerm metavar n
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679246358"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246358"><span class="hs-identifier hs-var">x'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-360"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246359"><span class="annot"><span class="annottext">x :: Name l
</span><a href="#local-6989586621679246359"><span class="hs-identifier hs-var hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameBinder n l -&gt; Name l
forall (n :: S) (l :: S). NameBinder n l -&gt; Name l
</span><span class="hs-identifier hs-var">Foil.nameOf</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246358"><span class="hs-identifier hs-var">x'</span></a></span><span>
</span><span id="line-361"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Type
-&gt; FoilPattern n l
-&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
-&gt; MetaTerm metavar n
forall (binder :: S -&gt; S -&gt; *) (n :: S) (q :: * -&gt; * -&gt; *)
       (l :: S).
Type
-&gt; binder n l
-&gt; AST binder (Sum TermSig q) l
-&gt; AST binder (Sum TermSig q) n
</span><a href="Language.Lambda.Impl.html#Lam%27"><span class="hs-identifier hs-var">Lam'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246353"><span class="hs-identifier hs-var">typ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameBinder n l -&gt; FoilPattern n l
forall (n :: S) (n1 :: S). NameBinder n n1 -&gt; FoilPattern n n1
</span><a href="Language.Lambda.Impl.html#FoilAPattern"><span class="hs-identifier hs-var">FoilAPattern</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246358"><span class="hs-identifier hs-var">x'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name l -&gt; AST FoilPattern (Sum TermSig (MetaAppSig metavar)) l
forall (l :: S). DExt n l =&gt; Name l -&gt; MetaTerm metavar l
</span><a href="#local-6989586621679246355"><span class="hs-identifier hs-var">makeBody</span></a></span><span> </span><span class="annot"><span class="annottext">Name l
</span><a href="#local-6989586621679246359"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span class="hs-comment">-- &gt;&gt;&gt; lam (Raw.Base (Raw.VarIdent &quot;t&quot;)) Foil.emptyScope (\x -&gt; App (Var x) (Var x))</span><span>
</span><span id="line-364"></span><span class="hs-comment">-- &#955; x0 : t . x0 x0</span><span>
</span><span id="line-365"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679244708"><span id="local-6989586621679246361"><span id="local-6989586621679246365"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679244708"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-366"></span><span>  </span><span id="local-6989586621679246370"><span class="annot"><span class="annottext">show :: Term n -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">show</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; String
forall a. Print a =&gt; a -&gt; String
</span><a href="Language.Lambda.Syntax.Print.html#printTree"><span class="hs-identifier hs-var">Raw.printTree</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; String) -&gt; (Term n -&gt; Term) -&gt; Term n -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Term n -&gt; Term
forall (n :: S). Term n -&gt; Term
</span><a href="Language.Lambda.Impl.html#fromTerm"><span class="hs-identifier hs-var">fromTerm</span></a></span><span>
</span><span id="line-367"></span><span>
</span><span id="line-368"></span><span class="hs-comment">-- &gt;&gt;&gt; &quot;&#955;y:t.(&#955;x:u.&#955;y:v.x)y&quot; :: Term Foil.VoidS</span><span>
</span><span id="line-369"></span><span class="hs-comment">-- &#955; x0 : t . (&#955; x1 : u . &#955; x2 : v . x1) x0</span><span>
</span><span id="line-370"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IsString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-371"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">fromString</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">VoidS</span></span><span>
</span><span id="line-372"></span><span>  </span><span id="local-6989586621679246375"><span class="annot"><span class="annottext">fromString :: String -&gt; Term 'VoidS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fromString</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Term 'VoidS
</span><a href="Language.Lambda.Impl.html#unsafeParseTerm"><span class="hs-identifier hs-var">unsafeParseTerm</span></a></span><span>
</span><span id="line-373"></span><span>
</span><span id="line-374"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679245341"><span id="local-6989586621679246378"><span id="local-6989586621679246383"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245341"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-375"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245341"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-376"></span><span>  </span><span id="local-6989586621679246386"><span class="annot"><span class="annottext">show :: MetaTerm MetaVarIdent n -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">show</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; String
forall a. Print a =&gt; a -&gt; String
</span><a href="Language.Lambda.Syntax.Print.html#printTree"><span class="hs-identifier hs-var">Raw.printTree</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; String)
-&gt; (MetaTerm MetaVarIdent n -&gt; Term)
-&gt; MetaTerm MetaVarIdent n
-&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Term n -&gt; Term
forall (n :: S). Term n -&gt; Term
</span><a href="Language.Lambda.Impl.html#fromTerm"><span class="hs-identifier hs-var">fromTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term n -&gt; Term)
-&gt; (MetaTerm MetaVarIdent n -&gt; Term n)
-&gt; MetaTerm MetaVarIdent n
-&gt; Term
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; Term n
forall (n :: S). MetaTerm MetaVarIdent n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#fromMetaTerm"><span class="hs-identifier hs-var">fromMetaTerm</span></a></span><span>
</span><span id="line-377"></span><span>
</span><span id="line-378"></span><span class="hs-comment">-- &gt;&gt;&gt; &quot;&#955;y:t.(&#955;x:u.&#955;y:v.X[x, y X[y, x]])y&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-379"></span><span class="hs-comment">-- &#955; x0 : t . (&#955; x1 : u . &#955; x2 : v . X [x1, x2 X [x2, x1]]) x0</span><span>
</span><span id="line-380"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IsString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-381"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">fromString</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaTerm"><span class="hs-identifier hs-type">MetaTerm</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">VoidS</span></span><span>
</span><span id="line-382"></span><span>  </span><span id="local-6989586621679246389"><span class="annot"><span class="annottext">fromString :: String -&gt; MetaTerm MetaVarIdent 'VoidS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fromString</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term 'VoidS -&gt; MetaTerm MetaVarIdent 'VoidS
forall (n :: S). Term n -&gt; MetaTerm MetaVarIdent n
</span><a href="Language.Lambda.Impl.html#toMetaTerm"><span class="hs-identifier hs-var">toMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">(Term 'VoidS -&gt; MetaTerm MetaVarIdent 'VoidS)
-&gt; (String -&gt; Term 'VoidS)
-&gt; String
-&gt; MetaTerm MetaVarIdent 'VoidS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Term 'VoidS
</span><a href="Language.Lambda.Impl.html#unsafeParseTerm"><span class="hs-identifier hs-var">unsafeParseTerm</span></a></span><span>
</span><span id="line-383"></span><span>
</span><span id="line-384"></span><span class="hs-comment">-- &gt;&gt;&gt; &quot;X [ x: t, y: u, z: v ] &#8614; &#955;y:t.(&#955;x:t.&#955;y:u.X[x, y X[y, x]])y&quot; :: MetaSubst'</span><span>
</span><span id="line-385"></span><span class="hs-comment">-- X [x0 : t, x1 : u, x2 : v] &#8614; &#955; x3 : t . (&#955; x4 : t . &#955; x5 : u . X [x4, x5 X [x5, x4]]) x3</span><span>
</span><span id="line-386"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679246391"><span id="local-6989586621679246396"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-387"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-388"></span><span>  </span><span id="local-6989586621679246400"><span class="annot"><span class="annottext">show :: MetaSubst' -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">show</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MetaSubst -&gt; String
forall a. Print a =&gt; a -&gt; String
</span><a href="Language.Lambda.Syntax.Print.html#printTree"><span class="hs-identifier hs-var">Raw.printTree</span></a></span><span> </span><span class="annot"><span class="annottext">(MetaSubst -&gt; String)
-&gt; (MetaSubst' -&gt; MetaSubst) -&gt; MetaSubst' -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">MetaSubst' -&gt; MetaSubst
</span><a href="Language.Lambda.Impl.html#fromMetaSubst"><span class="hs-identifier hs-var">fromMetaSubst</span></a></span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679246402"><span id="local-6989586621679246407"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubsts%27"><span class="hs-identifier hs-type">MetaSubsts'</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-391"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubsts%27"><span class="hs-identifier hs-type">MetaSubsts'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-392"></span><span>  </span><span id="local-6989586621679246411"><span class="annot"><span class="annottext">show :: MetaSubsts' -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">show</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[MetaSubst'] -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">([MetaSubst'] -&gt; String)
-&gt; (MetaSubsts' -&gt; [MetaSubst']) -&gt; MetaSubsts' -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">MetaSubsts' -&gt; [MetaSubst']
forall (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *) metavar
       (ext :: * -&gt; * -&gt; *) t.
MetaSubsts binder sig metavar ext t
-&gt; [MetaSubst binder sig metavar ext t]
</span><a href="Data.SOAS.html#getMetaSubsts"><span class="hs-identifier hs-var">getMetaSubsts</span></a></span><span>
</span><span id="line-393"></span><span>
</span><span id="line-394"></span><span class="hs-comment">-- &gt;&gt;&gt; &quot;X [ x: a, y: u ] &#8614; &#955; x : t. y&quot; :: MetaSubst'</span><span>
</span><span id="line-395"></span><span class="hs-comment">-- X [x0 : a, x1 : u] &#8614; &#955; x2 : t . x1</span><span>
</span><span id="line-396"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IsString</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-397"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">fromString</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span>
</span><span id="line-398"></span><span>  </span><span id="local-6989586621679246415"><span class="annot"><span class="annottext">fromString :: String -&gt; MetaSubst'
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fromString</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; MetaSubst'
</span><a href="Language.Lambda.Impl.html#unsafeParseMetaSubst"><span class="hs-identifier hs-var">unsafeParseMetaSubst</span></a></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span class="annot"><a href="Language.Lambda.Impl.html#unsafeParseTerm"><span class="hs-identifier hs-type">unsafeParseTerm</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.VoidS</span></span><span>
</span><span id="line-401"></span><span id="unsafeParseTerm"><span class="annot"><span class="annottext">unsafeParseTerm :: String -&gt; Term 'VoidS
</span><a href="Language.Lambda.Impl.html#unsafeParseTerm"><span class="hs-identifier hs-var hs-var">unsafeParseTerm</span></a></span></span><span> </span><span id="local-6989586621679246417"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246417"><span class="hs-identifier hs-var">input</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-402"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Token] -&gt; Err Term
</span><a href="Language.Lambda.Syntax.Par.html#pTerm"><span class="hs-identifier hs-var">Raw.pTerm</span></a></span><span> </span><span class="annot"><span class="annottext">[Token]
</span><a href="#local-6989586621679246419"><span class="hs-identifier hs-var">tokens</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-403"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679246420"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246420"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Term 'VoidS
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246420"><span class="hs-identifier hs-var">err</span></a></span><span>
</span><span id="line-404"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679246422"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246422"><span class="hs-identifier hs-var">term</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Term 'VoidS
</span><a href="Language.Lambda.Impl.html#toTermClosed"><span class="hs-identifier hs-var">toTermClosed</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246422"><span class="hs-identifier hs-var">term</span></a></span><span>
</span><span id="line-405"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-406"></span><span>  </span><span id="local-6989586621679246419"><span class="annot"><span class="annottext">tokens :: [Token]
</span><a href="#local-6989586621679246419"><span class="hs-identifier hs-var hs-var">tokens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; [Token] -&gt; [Token]
</span><a href="Language.Lambda.Syntax.Layout.html#resolveLayout"><span class="hs-identifier hs-var">Raw.resolveLayout</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; [Token]
</span><a href="Language.Lambda.Syntax.Par.html#myLexer"><span class="hs-identifier hs-var">Raw.myLexer</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246417"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-407"></span><span>
</span><span id="line-408"></span><span class="annot"><a href="Language.Lambda.Impl.html#parseMetaSubst"><span class="hs-identifier hs-type">parseMetaSubst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span>
</span><span id="line-409"></span><span id="parseMetaSubst"><span class="annot"><span class="annottext">parseMetaSubst :: String -&gt; Either String MetaSubst'
</span><a href="Language.Lambda.Impl.html#parseMetaSubst"><span class="hs-identifier hs-var hs-var">parseMetaSubst</span></a></span></span><span> </span><span id="local-6989586621679246426"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246426"><span class="hs-identifier hs-var">input</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-410"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246427"><span class="annot"><span class="annottext">tokens :: [Token]
</span><a href="#local-6989586621679246427"><span class="hs-identifier hs-var hs-var">tokens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; [Token] -&gt; [Token]
</span><a href="Language.Lambda.Syntax.Layout.html#resolveLayout"><span class="hs-identifier hs-var">Raw.resolveLayout</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; [Token]
</span><a href="Language.Lambda.Syntax.Par.html#myLexer"><span class="hs-identifier hs-var">Raw.myLexer</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246426"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-411"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">MetaSubst -&gt; MetaSubst'
</span><a href="Language.Lambda.Impl.html#toMetaSubst"><span class="hs-identifier hs-var">toMetaSubst</span></a></span><span> </span><span class="annot"><span class="annottext">(MetaSubst -&gt; MetaSubst')
-&gt; Either String MetaSubst -&gt; Either String MetaSubst'
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Token] -&gt; Either String MetaSubst
</span><a href="Language.Lambda.Syntax.Par.html#pMetaSubst"><span class="hs-identifier hs-var">Raw.pMetaSubst</span></a></span><span> </span><span class="annot"><span class="annottext">[Token]
</span><a href="#local-6989586621679246427"><span class="hs-identifier hs-var">tokens</span></a></span><span>
</span><span id="line-412"></span><span>
</span><span id="line-413"></span><span class="annot"><a href="Language.Lambda.Impl.html#unsafeParseMetaSubst"><span class="hs-identifier hs-type">unsafeParseMetaSubst</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span>
</span><span id="line-414"></span><span id="unsafeParseMetaSubst"><span class="annot"><span class="annottext">unsafeParseMetaSubst :: String -&gt; MetaSubst'
</span><a href="Language.Lambda.Impl.html#unsafeParseMetaSubst"><span class="hs-identifier hs-var hs-var">unsafeParseMetaSubst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; MetaSubst')
-&gt; (MetaSubst' -&gt; MetaSubst')
-&gt; Either String MetaSubst'
-&gt; MetaSubst'
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; MetaSubst'
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">MetaSubst' -&gt; MetaSubst'
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span> </span><span class="annot"><span class="annottext">(Either String MetaSubst' -&gt; MetaSubst')
-&gt; (String -&gt; Either String MetaSubst') -&gt; String -&gt; MetaSubst'
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Either String MetaSubst'
</span><a href="Language.Lambda.Impl.html#parseMetaSubst"><span class="hs-identifier hs-var">parseMetaSubst</span></a></span><span>
</span><span id="line-415"></span><span>
</span><span id="line-416"></span><span class="hs-comment">-- &gt;&gt;&gt; &quot;&#8704; m: t, n: u. Y[m, X[n, m]] = (&#955; x: t. m (x n)) m&quot; :: UnificationConstraint</span><span>
</span><span id="line-417"></span><span class="hs-comment">-- &#8704; x0 : t, x1 : u . Y [x0, X [x1, x0]] = (&#955; x2 : t . x0 (x2 x1)) x0</span><span>
</span><span id="line-418"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IsString</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-419"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">fromString</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span>
</span><span id="line-420"></span><span>  </span><span id="local-6989586621679246433"><span class="annot"><span class="annottext">fromString :: String -&gt; UnificationConstraint
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fromString</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#unsafeParseUnificationConstraint"><span class="hs-identifier hs-var">unsafeParseUnificationConstraint</span></a></span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679246436"><span id="local-6989586621679246440"><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-423"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">show</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-424"></span><span>  </span><span id="local-6989586621679246444"><span class="annot"><span class="annottext">show :: UnificationConstraint -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">show</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">UnificationConstraint -&gt; String
forall a. Print a =&gt; a -&gt; String
</span><a href="Language.Lambda.Syntax.Print.html#printTree"><span class="hs-identifier hs-var">Raw.printTree</span></a></span><span> </span><span class="annot"><span class="annottext">(UnificationConstraint -&gt; String)
-&gt; (UnificationConstraint -&gt; UnificationConstraint)
-&gt; UnificationConstraint
-&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">UnificationConstraint -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#fromUnificationConstraint"><span class="hs-identifier hs-var">fromUnificationConstraint</span></a></span><span>
</span><span id="line-425"></span><span>
</span><span id="line-426"></span><span class="annot"><a href="Language.Lambda.Impl.html#unsafeParseUnificationConstraint"><span class="hs-identifier hs-type">unsafeParseUnificationConstraint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span>
</span><span id="line-427"></span><span id="unsafeParseUnificationConstraint"><span class="annot"><span class="annottext">unsafeParseUnificationConstraint :: String -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#unsafeParseUnificationConstraint"><span class="hs-identifier hs-var hs-var">unsafeParseUnificationConstraint</span></a></span></span><span> </span><span id="local-6989586621679246445"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">input</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-428"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[Token] -&gt; Err UnificationConstraint
</span><a href="Language.Lambda.Syntax.Par.html#pUnificationConstraint"><span class="hs-identifier hs-var">Raw.pUnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">[Token]
</span><a href="#local-6989586621679246447"><span class="hs-identifier hs-var">tokens</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-429"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679246448"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246448"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; UnificationConstraint
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246448"><span class="hs-identifier hs-var">err</span></a></span><span>
</span><span id="line-430"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679246449"><span class="annot"><span class="annottext">UnificationConstraint
</span><a href="#local-6989586621679246449"><span class="hs-identifier hs-var">problem</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">UnificationConstraint -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#toUnificationConstraint"><span class="hs-identifier hs-var">toUnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">UnificationConstraint
</span><a href="#local-6989586621679246449"><span class="hs-identifier hs-var">problem</span></a></span><span>
</span><span id="line-431"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-432"></span><span>  </span><span id="local-6989586621679246447"><span class="annot"><span class="annottext">tokens :: [Token]
</span><a href="#local-6989586621679246447"><span class="hs-identifier hs-var hs-var">tokens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; [Token] -&gt; [Token]
</span><a href="Language.Lambda.Syntax.Layout.html#resolveLayout"><span class="hs-identifier hs-var">Raw.resolveLayout</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; [Token]
</span><a href="Language.Lambda.Syntax.Par.html#myLexer"><span class="hs-identifier hs-var">Raw.myLexer</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679246445"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-433"></span><span>
</span><span id="line-434"></span><span class="annot"><span class="hs-comment">-- | Match a pattern against an term.</span></span><span>
</span><span id="line-435"></span><span id="local-6989586621679245193"><span id="local-6989586621679245194"><span id="local-6989586621679245195"><span class="annot"><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-type">matchPattern</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InjectName</span></span><span> </span><span class="annot"><a href="#local-6989586621679245193"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245194"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245195"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679245193"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245194"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Substitution</span></span><span> </span><span class="annot"><a href="#local-6989586621679245193"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245195"><span class="hs-identifier hs-type">l</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245194"><span class="hs-identifier hs-type">n</span></a></span></span></span></span><span>
</span><span id="line-436"></span><span id="matchPattern"><span class="annot"><span class="annottext">matchPattern :: forall (t :: S -&gt; *) (n :: S) (l :: S).
InjectName t =&gt;
FoilPattern n l -&gt; t n -&gt; Substitution t l n
</span><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-var hs-var">matchPattern</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#FoilAPattern"><span class="hs-identifier hs-type">FoilAPattern</span></a></span><span> </span><span id="local-6989586621679246452"><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246452"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Substitution t n n -&gt; NameBinder n l -&gt; t n -&gt; Substitution t l n
forall (e :: S -&gt; *) (i :: S) (o :: S) (i' :: S).
Substitution e i o -&gt; NameBinder i i' -&gt; e o -&gt; Substitution e i' o
</span><span class="hs-identifier hs-var">Foil.addSubst</span></span><span> </span><span class="annot"><span class="annottext">Substitution t n n
forall (e :: S -&gt; *) (i :: S). InjectName e =&gt; Substitution e i i
</span><span class="hs-identifier hs-var">Foil.identitySubst</span></span><span> </span><span class="annot"><span class="annottext">NameBinder n l
</span><a href="#local-6989586621679246452"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-437"></span><span>
</span><span id="line-438"></span><span class="hs-comment">-- &gt;&gt;&gt; whnf Foil.emptyScope (lam (Raw.Base (Raw.VarIdent &quot;magic&quot;)) Foil.emptyScope (\x -&gt; App (Var x) (Var x)))</span><span>
</span><span id="line-439"></span><span class="hs-comment">-- &#955; x0 : magic . x0 x0</span><span>
</span><span id="line-440"></span><span class="hs-comment">-- &gt;&gt;&gt; whnf Foil.emptyScope &quot;(&#955;s:fix.&#955;z:fix.s (s z)) (&#955;s:fix.&#955;z:fix.s (s z))&quot;</span><span>
</span><span id="line-441"></span><span class="hs-comment">-- &#955; x1 : fix . (&#955; x0 : fix . &#955; x1 : fix . x0 (x0 x1)) ((&#955; x0 : fix . &#955; x1 : fix . x0 (x0 x1)) x1)</span><span>
</span><span id="line-442"></span><span class="hs-comment">-- &gt;&gt;&gt; whnf Foil.emptyScope &quot;(&#955;s:fix.&#955;z:fix.s (S[] z)) (&#955;s:fix.&#955;z:fix.s (s z))&quot;</span><span>
</span><span id="line-443"></span><span class="hs-comment">-- &#955; x1 : fix . (&#955; x0 : fix . &#955; x1 : fix . x0 (x0 x1)) (S [] x1)</span><span>
</span><span id="line-444"></span><span id="local-6989586621679245366"><span class="annot"><a href="Language.Lambda.Impl.html#whnf"><span class="hs-identifier hs-type">whnf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679245366"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679245366"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245366"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245366"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-445"></span><span id="whnf"><span class="annot"><span class="annottext">whnf :: forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#whnf"><span class="hs-identifier hs-var hs-var">whnf</span></a></span></span><span> </span><span id="local-6989586621679246457"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246457"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-446"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679246458"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246458"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679246459"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246459"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-447"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; Term n -&gt; Term n
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246457"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246458"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-448"></span><span>      </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span id="local-6989586621679246466"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246466"><span class="hs-identifier hs-var">_type</span></a></span></span><span> </span><span id="local-6989586621679246467"><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246467"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246468"><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246468"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-449"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246469"><span class="annot"><span class="annottext">subst :: Substitution (AST FoilPattern TermSig) l1 n
</span><a href="#local-6989586621679246469"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
-&gt; Term n -&gt; Substitution (AST FoilPattern TermSig) l1 n
forall (t :: S -&gt; *) (n :: S) (l :: S).
InjectName t =&gt;
FoilPattern n l -&gt; t n -&gt; Substitution t l n
</span><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246467"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246459"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-450"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; Term n -&gt; Term n
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#whnf"><span class="hs-identifier hs-var">whnf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246457"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n
-&gt; Substitution (AST FoilPattern TermSig) l1 n
-&gt; AST FoilPattern TermSig l1
-&gt; Term n
forall (sig :: * -&gt; * -&gt; *) (o :: S) (binder :: S -&gt; S -&gt; *)
       (i :: S).
(Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) =&gt;
Scope o
-&gt; Substitution (AST binder sig) i o
-&gt; AST binder sig i
-&gt; AST binder sig o
</span><span class="hs-identifier hs-var">substitute</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246457"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution (AST FoilPattern TermSig) l1 n
</span><a href="#local-6989586621679246469"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246468"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-451"></span><span>      </span><span id="local-6989586621679246470"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246470"><span class="hs-identifier hs-var">f'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term n -&gt; Term n -&gt; Term n
forall (binder :: S -&gt; S -&gt; *) (n :: S).
AST binder TermSig n
-&gt; AST binder TermSig n -&gt; AST binder TermSig n
</span><a href="Language.Lambda.Impl.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246470"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246459"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-452"></span><span>  </span><span id="local-6989586621679246471"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246471"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246471"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;&#955;y:t.&#955;z:f. (&#955;x:t.&#955;y:f.y) y z&quot;</span><span>
</span><span id="line-455"></span><span class="hs-comment">-- &#955; x0 : t . &#955; x1 : f . x1</span><span>
</span><span id="line-456"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;&#955;z:t.&#955;w:u.(&#955;x:t.&#955;y:u-&gt;u.y) z (&#955;z:u.z) w&quot;</span><span>
</span><span id="line-457"></span><span class="hs-comment">-- &#955; x0 : t . &#955; x1 : u . x1</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;(&#955;b:t-&gt;f-&gt;t.&#955;x:f.&#955;y:t.b y x) (&#955;x:t.&#955;y:f.x)&quot;</span><span>
</span><span id="line-459"></span><span class="hs-comment">-- &#955; x1 : f . &#955; x2 : t . x2</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;(&#955;s:(t-&gt;t)-&gt;t-&gt;t.&#955;z:t-&gt;t.s(s z))(&#955;b:t-&gt;t-&gt;t.&#955;x:t.&#955;y:t.b y x)(&#955;x:t.&#955;y:t.y)&quot;</span><span>
</span><span id="line-461"></span><span class="hs-comment">-- &#955; x2 : t . &#955; x3 : t . x3</span><span>
</span><span id="line-462"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;(&#955;s:(t-&gt;t)-&gt;t-&gt;t.&#955;z:t-&gt;t.s (s z)) (&#955;s:(t-&gt;t)-&gt;t-&gt;t.&#955;z:t-&gt;t.s (s z)) (&#955;b:t-&gt;t-&gt;t.&#955;y:t.&#955;x:t.b x y) (&#955;y:t.&#955;x:t.x)&quot;</span><span>
</span><span id="line-463"></span><span class="hs-comment">-- &#955; x1 : t . &#955; x3 : t . x3</span><span>
</span><span id="line-464"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;(&#955; a : (t -&gt; t) . &#955; x: u . x) (&#955; a : t . a)&quot;</span><span>
</span><span id="line-465"></span><span class="hs-comment">-- &#955; x1 : u . x1</span><span>
</span><span id="line-466"></span><span class="hs-comment">-- &gt;&gt;&gt; nf Foil.emptyScope &quot;let f = &#955; a : (t -&gt; t) . &#955; x : (u -&gt; u) . x in f (&#955; a : t . a) (&#955; a : u . a)&quot;</span><span>
</span><span id="line-467"></span><span class="hs-comment">-- &#955; x1 : u . x1</span><span>
</span><span id="line-468"></span><span id="local-6989586621679246472"><span class="annot"><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-type">nf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foil.Distinct</span></span><span> </span><span class="annot"><a href="#local-6989586621679246472"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foil.Scope</span></span><span> </span><span class="annot"><a href="#local-6989586621679246472"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246472"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679246472"><span class="hs-identifier hs-type">n</span></a></span></span><span>
</span><span id="line-469"></span><span id="nf"><span class="annot"><span class="annottext">nf :: forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-var hs-var">nf</span></a></span></span><span> </span><span id="local-6989586621679246476"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-470"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#App"><span class="hs-identifier hs-type">App</span></a></span><span> </span><span id="local-6989586621679246477"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246477"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679246478"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246478"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-471"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; Term n -&gt; Term n
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-var">nf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246477"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-472"></span><span>      </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span id="local-6989586621679246485"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246485"><span class="hs-identifier hs-var">_type</span></a></span></span><span> </span><span id="local-6989586621679246486"><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246486"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246487"><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246487"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-473"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246488"><span class="annot"><span class="annottext">subst :: Substitution (AST FoilPattern TermSig) l1 n
</span><a href="#local-6989586621679246488"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
-&gt; Term n -&gt; Substitution (AST FoilPattern TermSig) l1 n
forall (t :: S -&gt; *) (n :: S) (l :: S).
InjectName t =&gt;
FoilPattern n l -&gt; t n -&gt; Substitution t l n
</span><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246486"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246478"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-474"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; Term n -&gt; Term n
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-var">nf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n
-&gt; Substitution (AST FoilPattern TermSig) l1 n
-&gt; AST FoilPattern TermSig l1
-&gt; Term n
forall (sig :: * -&gt; * -&gt; *) (o :: S) (binder :: S -&gt; S -&gt; *)
       (i :: S).
(Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) =&gt;
Scope o
-&gt; Substitution (AST binder sig) i o
-&gt; AST binder sig i
-&gt; AST binder sig o
</span><span class="hs-identifier hs-var">substitute</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution (AST FoilPattern TermSig) l1 n
</span><a href="#local-6989586621679246488"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246487"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-475"></span><span>      </span><span id="local-6989586621679246489"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246489"><span class="hs-identifier hs-var">f'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term n -&gt; Term n -&gt; Term n
forall (binder :: S -&gt; S -&gt; *) (n :: S).
AST binder TermSig n
-&gt; AST binder TermSig n -&gt; AST binder TermSig n
</span><a href="Language.Lambda.Impl.html#App"><span class="hs-identifier hs-var">App</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246489"><span class="hs-identifier hs-var">f'</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246478"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-476"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#Lam"><span class="hs-identifier hs-type">Lam</span></a></span><span> </span><span id="local-6989586621679246492"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246492"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span id="local-6989586621679246493"><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246493"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246494"><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246494"><span class="hs-identifier hs-var">body</span></a></span></span><span>
</span><span id="line-477"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">DistinctEvidence l1
</span><span class="hs-identifier hs-var">Foil.Distinct</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1 -&gt; DistinctEvidence l1
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; DistinctEvidence l
</span><span class="hs-identifier hs-var">Foil.assertDistinct</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246493"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-478"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246499"><span class="annot"><span class="annottext">extendedScope :: Scope l1
</span><a href="#local-6989586621679246499"><span class="hs-identifier hs-var hs-var">extendedScope</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1 -&gt; Scope n -&gt; Scope l1
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; Scope n -&gt; Scope l
</span><span class="hs-identifier hs-var">Foil.extendScopePattern</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246493"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span><span>
</span><span id="line-479"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Type -&gt; FoilPattern n l1 -&gt; AST FoilPattern TermSig l1 -&gt; Term n
forall (binder :: S -&gt; S -&gt; *) (n :: S) (l1 :: S).
Type
-&gt; binder n l1 -&gt; AST binder TermSig l1 -&gt; AST binder TermSig n
</span><a href="Language.Lambda.Impl.html#Lam"><span class="hs-identifier hs-var">Lam</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679246492"><span class="hs-identifier hs-var">typ</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246493"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope l1
-&gt; AST FoilPattern TermSig l1 -&gt; AST FoilPattern TermSig l1
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-var">nf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope l1
</span><a href="#local-6989586621679246499"><span class="hs-identifier hs-var">extendedScope</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246494"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-480"></span><span>  </span><span class="annot"><a href="Language.Lambda.Impl.html#Let"><span class="hs-identifier hs-type">Let</span></a></span><span> </span><span id="local-6989586621679246502"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246502"><span class="hs-identifier hs-var">value</span></a></span></span><span> </span><span id="local-6989586621679246503"><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246503"><span class="hs-identifier hs-var">binder</span></a></span></span><span> </span><span id="local-6989586621679246504"><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246504"><span class="hs-identifier hs-var">body</span></a></span></span><span>
</span><span id="line-481"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">DistinctEvidence l1
</span><span class="hs-identifier hs-var">Foil.Distinct</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1 -&gt; DistinctEvidence l1
forall (n :: S) (pattern :: S -&gt; S -&gt; *) (l :: S).
(Distinct n, CoSinkable pattern) =&gt;
pattern n l -&gt; DistinctEvidence l
</span><span class="hs-identifier hs-var">Foil.assertDistinct</span></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246503"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-482"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246512"><span class="annot"><span class="annottext">subst :: Substitution (AST FoilPattern TermSig) l1 n
</span><a href="#local-6989586621679246512"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
-&gt; Term n -&gt; Substitution (AST FoilPattern TermSig) l1 n
forall (t :: S -&gt; *) (n :: S) (l :: S).
InjectName t =&gt;
FoilPattern n l -&gt; t n -&gt; Substitution t l n
</span><a href="Language.Lambda.Impl.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">FoilPattern n l1
</span><a href="#local-6989586621679246503"><span class="hs-identifier hs-var">binder</span></a></span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246502"><span class="hs-identifier hs-var">value</span></a></span><span>
</span><span id="line-483"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; Term n -&gt; Term n
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-var">nf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Scope n
-&gt; Substitution (AST FoilPattern TermSig) l1 n
-&gt; AST FoilPattern TermSig l1
-&gt; Term n
forall (sig :: * -&gt; * -&gt; *) (o :: S) (binder :: S -&gt; S -&gt; *)
       (i :: S).
(Bifunctor sig, Distinct o, CoSinkable binder, SinkableK binder) =&gt;
Scope o
-&gt; Substitution (AST binder sig) i o
-&gt; AST binder sig i
-&gt; AST binder sig o
</span><span class="hs-identifier hs-var">substitute</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246476"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution (AST FoilPattern TermSig) l1 n
</span><a href="#local-6989586621679246512"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">AST FoilPattern TermSig l1
</span><a href="#local-6989586621679246504"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-484"></span><span>  </span><span id="local-6989586621679246513"><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246513"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term n
</span><a href="#local-6989586621679246513"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-485"></span><span>
</span><span id="line-486"></span><span class="annot"><a href="Language.Lambda.Impl.html#interpretCommand"><span class="hs-identifier hs-type">interpretCommand</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Command"><span class="hs-identifier hs-type">Raw.Command</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-487"></span><span id="interpretCommand"><span class="annot"><span class="annottext">interpretCommand :: Command -&gt; IO ()
</span><a href="Language.Lambda.Impl.html#interpretCommand"><span class="hs-identifier hs-var hs-var">interpretCommand</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#CommandCompute"><span class="hs-identifier hs-type">Raw.CommandCompute</span></a></span><span> </span><span id="local-6989586621679246516"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246516"><span class="hs-identifier hs-var">term</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-488"></span><span>  </span><span class="annot"><span class="annottext">Term 'VoidS -&gt; IO ()
forall a. Show a =&gt; a -&gt; IO ()
</span><span class="hs-identifier hs-var">print</span></span><span> </span><span class="annot"><span class="annottext">(Term 'VoidS -&gt; IO ()) -&gt; Term 'VoidS -&gt; IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS -&gt; Term 'VoidS -&gt; Term 'VoidS
forall (n :: S). Distinct n =&gt; Scope n -&gt; Term n -&gt; Term n
</span><a href="Language.Lambda.Impl.html#nf"><span class="hs-identifier hs-var">nf</span></a></span><span> </span><span class="annot"><span class="annottext">Scope 'VoidS
</span><span class="hs-identifier hs-var">Foil.emptyScope</span></span><span> </span><span class="annot"><span class="annottext">(Term 'VoidS -&gt; Term 'VoidS) -&gt; Term 'VoidS -&gt; Term 'VoidS
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Term 'VoidS
</span><a href="Language.Lambda.Impl.html#toTermClosed"><span class="hs-identifier hs-var">toTermClosed</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621679246516"><span class="hs-identifier hs-var">term</span></a></span><span>
</span><span id="line-489"></span><span>
</span><span id="line-490"></span><span class="annot"><a href="Language.Lambda.Impl.html#interpretProgram"><span class="hs-identifier hs-type">interpretProgram</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Program"><span class="hs-identifier hs-type">Raw.Program</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-491"></span><span id="interpretProgram"><span class="annot"><span class="annottext">interpretProgram :: Program -&gt; IO ()
</span><a href="Language.Lambda.Impl.html#interpretProgram"><span class="hs-identifier hs-var hs-var">interpretProgram</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#AProgram"><span class="hs-identifier hs-type">Raw.AProgram</span></a></span><span> </span><span id="local-6989586621679246519"><span class="annot"><span class="annottext">[Command]
</span><a href="#local-6989586621679246519"><span class="hs-identifier hs-var">commands</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Command -&gt; IO ()) -&gt; [Command] -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="annot"><span class="annottext">Command -&gt; IO ()
</span><a href="Language.Lambda.Impl.html#interpretCommand"><span class="hs-identifier hs-var">interpretCommand</span></a></span><span> </span><span class="annot"><span class="annottext">[Command]
</span><a href="#local-6989586621679246519"><span class="hs-identifier hs-var">commands</span></a></span><span>
</span><span id="line-492"></span><span>
</span><span id="line-493"></span><span class="annot"><span class="hs-comment">-- ** Test framework implementation</span></span><span>
</span><span id="line-494"></span><span>
</span><span id="line-495"></span><span class="hs-comment">-- &gt;&gt;&gt; constraint = &quot;&#8704; g:t1, a:t2, w:t3. X[g, &#955;z:t4. z a] = g a&quot; :: UnificationConstraint</span><span>
</span><span id="line-496"></span><span class="hs-comment">-- &gt;&gt;&gt; subst = &quot;X[x : t2, y : t3] &#8614; (&#955; z : t1 . y z) x&quot; :: MetaSubst'</span><span>
</span><span id="line-497"></span><span class="hs-comment">-- &gt;&gt;&gt; isSolved (solveUnificationConstraint (MetaSubsts [subst]) constraint)</span><span>
</span><span id="line-498"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-499"></span><span class="hs-comment">-- &gt;&gt;&gt; constraint1 = &quot;&#8704; f:t, x:t . X[f, x] = f Y[x]&quot; :: UnificationConstraint</span><span>
</span><span id="line-500"></span><span class="hs-comment">-- &gt;&gt;&gt; constraint2 = &quot;&#8704; x:t . Y[x] = x x&quot; :: UnificationConstraint</span><span>
</span><span id="line-501"></span><span class="hs-comment">-- &gt;&gt;&gt; subst1 = &quot;Y[x:t] &#8614; x x&quot; :: MetaSubst'</span><span>
</span><span id="line-502"></span><span class="hs-comment">-- &gt;&gt;&gt; subst2 = &quot;X[f:t, x:t] &#8614; f (x x)&quot; :: MetaSubst'</span><span>
</span><span id="line-503"></span><span class="hs-comment">-- &gt;&gt;&gt; subst3 = &quot;M[x:t, y:t] &#8614; y x&quot; :: MetaSubst'</span><span>
</span><span id="line-504"></span><span class="hs-comment">-- &gt;&gt;&gt; all (isSolved . solveUnificationConstraint (MetaSubsts [subst1, subst2, subst3])) [constraint1, constraint2]</span><span>
</span><span id="line-505"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-506"></span><span>
</span><span id="line-507"></span><span class="annot"><a href="Language.Lambda.Impl.html#solveUnificationConstraint"><span class="hs-identifier hs-type">solveUnificationConstraint</span></a></span><span>
</span><span id="line-508"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.SOAS.html#MetaSubsts"><span class="hs-identifier hs-type">MetaSubsts</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#FoilPattern"><span class="hs-identifier hs-type">FoilPattern</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#TermSig"><span class="hs-identifier hs-type">TermSig</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.SOAS.html#MetaAppSig"><span class="hs-identifier hs-type">MetaAppSig</span></a></span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#MetaVarIdent"><span class="hs-identifier hs-type">Raw.MetaVarIdent</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Lambda.Syntax.Abs.html#Type"><span class="hs-identifier hs-type">Raw.Type</span></a></span><span>
</span><span id="line-509"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span>
</span><span id="line-510"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span>
</span><span id="line-511"></span><span id="solveUnificationConstraint"><span class="annot"><span class="annottext">solveUnificationConstraint :: MetaSubsts' -&gt; UnificationConstraint -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#solveUnificationConstraint"><span class="hs-identifier hs-var hs-var">solveUnificationConstraint</span></a></span></span><span> </span><span id="local-6989586621679246522"><span class="annot"><span class="annottext">MetaSubsts'
</span><a href="#local-6989586621679246522"><span class="hs-identifier hs-var">substs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span id="local-6989586621679246531"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246531"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246532"><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246532"><span class="hs-identifier hs-var">binders</span></a></span></span><span> </span><span id="local-6989586621679246533"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246533"><span class="hs-identifier hs-var">binderTypes</span></a></span></span><span> </span><span id="local-6989586621679246534"><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246534"><span class="hs-identifier hs-var">lhs</span></a></span></span><span> </span><span id="local-6989586621679246535"><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246535"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-512"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246536"><span class="annot"><span class="annottext">solve :: MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246536"><span class="hs-identifier hs-var hs-var">solve</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope n -&gt; MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n
forall (n :: S) metavar.
Distinct n =&gt;
Scope n -&gt; MetaTerm metavar n -&gt; MetaTerm metavar n
</span><a href="Language.Lambda.Impl.html#nfMetaTerm"><span class="hs-identifier hs-var">nfMetaTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246531"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">(MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n)
-&gt; (MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n)
-&gt; MetaTerm MetaVarIdent n
-&gt; MetaTerm MetaVarIdent n
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(MetaVarIdent -&gt; MetaVarIdent)
-&gt; Scope n
-&gt; MetaSubsts'
-&gt; MetaTerm MetaVarIdent n
-&gt; MetaTerm MetaVarIdent n
forall (sig :: * -&gt; * -&gt; *) metavar (n :: S)
       (binder :: S -&gt; S -&gt; *) metavar' t.
(Bifunctor sig, Eq metavar, Distinct n, CoSinkable binder,
 SinkableK binder) =&gt;
(metavar -&gt; metavar')
-&gt; Scope n
-&gt; MetaSubsts binder sig metavar (MetaAppSig metavar') t
-&gt; SOAS binder metavar sig n
-&gt; SOAS binder metavar' sig n
</span><a href="Data.SOAS.html#applyMetaSubsts"><span class="hs-identifier hs-var">applyMetaSubsts</span></a></span><span> </span><span class="annot"><span class="annottext">MetaVarIdent -&gt; MetaVarIdent
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246531"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">MetaSubsts'
</span><a href="#local-6989586621679246522"><span class="hs-identifier hs-var">substs</span></a></span><span>
</span><span id="line-513"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; NameBinderList 'VoidS n
-&gt; NameMap n Type
-&gt; MetaTerm MetaVarIdent n
-&gt; MetaTerm MetaVarIdent n
-&gt; UnificationConstraint
forall (n :: S).
Distinct n =&gt;
Scope n
-&gt; NameBinderList 'VoidS n
-&gt; NameMap n Type
-&gt; MetaTerm MetaVarIdent n
-&gt; MetaTerm MetaVarIdent n
-&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-var">UnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246531"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246532"><span class="hs-identifier hs-var">binders</span></a></span><span> </span><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246533"><span class="hs-identifier hs-var">binderTypes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246536"><span class="hs-identifier hs-var">solve</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246534"><span class="hs-identifier hs-var">lhs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246536"><span class="hs-identifier hs-var">solve</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246535"><span class="hs-identifier hs-var">rhs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span>
</span><span id="line-515"></span><span class="annot"><a href="Language.Lambda.Impl.html#isSolved"><span class="hs-identifier hs-type">isSolved</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-516"></span><span id="isSolved"><span class="annot"><span class="annottext">isSolved :: UnificationConstraint -&gt; Bool
</span><a href="Language.Lambda.Impl.html#isSolved"><span class="hs-identifier hs-var hs-var">isSolved</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span> </span><span id="local-6989586621679246554"><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246554"><span class="hs-identifier hs-var">scope</span></a></span></span><span> </span><span id="local-6989586621679246555"><span class="annot"><span class="annottext">NameBinderList 'VoidS n
</span><a href="#local-6989586621679246555"><span class="hs-identifier hs-var">_binders</span></a></span></span><span> </span><span id="local-6989586621679246556"><span class="annot"><span class="annottext">NameMap n Type
</span><a href="#local-6989586621679246556"><span class="hs-identifier hs-var">_binderTypes</span></a></span></span><span> </span><span id="local-6989586621679246557"><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246557"><span class="hs-identifier hs-var">lhs</span></a></span></span><span> </span><span id="local-6989586621679246558"><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246558"><span class="hs-identifier hs-var">rhs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Scope n
-&gt; MetaTerm MetaVarIdent n -&gt; MetaTerm MetaVarIdent n -&gt; Bool
forall (sig :: * -&gt; * -&gt; *) (n :: S) (binder :: S -&gt; S -&gt; *).
(Bitraversable sig, ZipMatchK sig, Distinct n,
 UnifiablePattern binder, SinkableK binder) =&gt;
Scope n -&gt; AST binder sig n -&gt; AST binder sig n -&gt; Bool
</span><span class="hs-identifier hs-var">alphaEquiv</span></span><span> </span><span class="annot"><span class="annottext">Scope n
</span><a href="#local-6989586621679246554"><span class="hs-identifier hs-var">scope</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246557"><span class="hs-identifier hs-var">lhs</span></a></span><span> </span><span class="annot"><span class="annottext">MetaTerm MetaVarIdent n
</span><a href="#local-6989586621679246558"><span class="hs-identifier hs-var">rhs</span></a></span><span>
</span><span id="line-517"></span><span>
</span><span id="line-518"></span><span class="hs-comment">-- Data types</span><span>
</span><span id="line-519"></span><span class="hs-keyword">data</span><span> </span><span id="Config"><span class="annot"><a href="Language.Lambda.Impl.html#Config"><span class="hs-identifier hs-var">Config</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Config"><span class="annot"><a href="Language.Lambda.Impl.html#Config"><span class="hs-identifier hs-var">Config</span></a></span></span><span>
</span><span id="line-520"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="configLanguage"><span class="annot"><span class="annottext">Config -&gt; Text
</span><a href="Language.Lambda.Impl.html#configLanguage"><span class="hs-identifier hs-var hs-var">configLanguage</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-521"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="configFragment"><span class="annot"><span class="annottext">Config -&gt; Text
</span><a href="Language.Lambda.Impl.html#configFragment"><span class="hs-identifier hs-var hs-var">configFragment</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-522"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="configProblems"><span class="annot"><span class="annottext">Config -&gt; [Problem]
</span><a href="Language.Lambda.Impl.html#configProblems"><span class="hs-identifier hs-var hs-var">configProblems</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-type">Problem</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-523"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-524"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246564"><span id="local-6989586621679246572"><span id="local-6989586621679246576"><span class="annot"><span class="annottext">Int -&gt; Config -&gt; String -&gt; String
[Config] -&gt; String -&gt; String
Config -&gt; String
(Int -&gt; Config -&gt; String -&gt; String)
-&gt; (Config -&gt; String)
-&gt; ([Config] -&gt; String -&gt; String)
-&gt; Show Config
forall a.
(Int -&gt; a -&gt; String -&gt; String)
-&gt; (a -&gt; String) -&gt; ([a] -&gt; String -&gt; String) -&gt; Show a
$cshowsPrec :: Int -&gt; Config -&gt; String -&gt; String
showsPrec :: Int -&gt; Config -&gt; String -&gt; String
$cshow :: Config -&gt; String
show :: Config -&gt; String
$cshowList :: [Config] -&gt; String -&gt; String
showList :: [Config] -&gt; String -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246580"><span id="local-6989586621679246582"><span class="annot"><span class="annottext">(forall x. Config -&gt; Rep Config x)
-&gt; (forall x. Rep Config x -&gt; Config) -&gt; Generic Config
forall x. Rep Config x -&gt; Config
forall x. Config -&gt; Rep Config x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Config -&gt; Rep Config x
from :: forall x. Config -&gt; Rep Config x
$cto :: forall x. Rep Config x -&gt; Config
to :: forall x. Rep Config x -&gt; Config
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-525"></span><span>
</span><span id="line-526"></span><span class="hs-keyword">data</span><span> </span><span id="Problem"><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-var">Problem</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Problem"><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-var">Problem</span></a></span></span><span>
</span><span id="line-527"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="problemConstraints"><span class="annot"><span class="annottext">Problem -&gt; [UnificationConstraint]
</span><a href="Language.Lambda.Impl.html#problemConstraints"><span class="hs-identifier hs-var hs-var">problemConstraints</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-528"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="problemSolutions"><span class="annot"><span class="annottext">Problem -&gt; [Solution]
</span><a href="Language.Lambda.Impl.html#problemSolutions"><span class="hs-identifier hs-var hs-var">problemSolutions</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-529"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-530"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246588"><span id="local-6989586621679246594"><span id="local-6989586621679246597"><span class="annot"><span class="annottext">Int -&gt; Problem -&gt; String -&gt; String
[Problem] -&gt; String -&gt; String
Problem -&gt; String
(Int -&gt; Problem -&gt; String -&gt; String)
-&gt; (Problem -&gt; String)
-&gt; ([Problem] -&gt; String -&gt; String)
-&gt; Show Problem
forall a.
(Int -&gt; a -&gt; String -&gt; String)
-&gt; (a -&gt; String) -&gt; ([a] -&gt; String -&gt; String) -&gt; Show a
$cshowsPrec :: Int -&gt; Problem -&gt; String -&gt; String
showsPrec :: Int -&gt; Problem -&gt; String -&gt; String
$cshow :: Problem -&gt; String
show :: Problem -&gt; String
$cshowList :: [Problem] -&gt; String -&gt; String
showList :: [Problem] -&gt; String -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246601"><span id="local-6989586621679246603"><span class="annot"><span class="annottext">(forall x. Problem -&gt; Rep Problem x)
-&gt; (forall x. Rep Problem x -&gt; Problem) -&gt; Generic Problem
forall x. Rep Problem x -&gt; Problem
forall x. Problem -&gt; Rep Problem x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Problem -&gt; Rep Problem x
from :: forall x. Problem -&gt; Rep Problem x
$cto :: forall x. Rep Problem x -&gt; Problem
to :: forall x. Rep Problem x -&gt; Problem
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-531"></span><span>
</span><span id="line-532"></span><span class="hs-keyword">data</span><span> </span><span id="Solution"><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-var">Solution</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Solution"><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-var">Solution</span></a></span></span><span>
</span><span id="line-533"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="solutionName"><span class="annot"><span class="annottext">Solution -&gt; Text
</span><a href="Language.Lambda.Impl.html#solutionName"><span class="hs-identifier hs-var hs-var">solutionName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span>
</span><span id="line-534"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="solutionSubstitutions"><span class="annot"><span class="annottext">Solution -&gt; [MetaSubst']
</span><a href="Language.Lambda.Impl.html#solutionSubstitutions"><span class="hs-identifier hs-var hs-var">solutionSubstitutions</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#MetaSubst%27"><span class="hs-identifier hs-type">MetaSubst'</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-535"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-536"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246609"><span id="local-6989586621679246615"><span id="local-6989586621679246618"><span class="annot"><span class="annottext">Int -&gt; Solution -&gt; String -&gt; String
[Solution] -&gt; String -&gt; String
Solution -&gt; String
(Int -&gt; Solution -&gt; String -&gt; String)
-&gt; (Solution -&gt; String)
-&gt; ([Solution] -&gt; String -&gt; String)
-&gt; Show Solution
forall a.
(Int -&gt; a -&gt; String -&gt; String)
-&gt; (a -&gt; String) -&gt; ([a] -&gt; String -&gt; String) -&gt; Show a
$cshowsPrec :: Int -&gt; Solution -&gt; String -&gt; String
showsPrec :: Int -&gt; Solution -&gt; String -&gt; String
$cshow :: Solution -&gt; String
show :: Solution -&gt; String
$cshowList :: [Solution] -&gt; String -&gt; String
showList :: [Solution] -&gt; String -&gt; String
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246621"><span id="local-6989586621679246623"><span class="annot"><span class="annottext">(forall x. Solution -&gt; Rep Solution x)
-&gt; (forall x. Rep Solution x -&gt; Solution) -&gt; Generic Solution
forall x. Rep Solution x -&gt; Solution
forall x. Solution -&gt; Rep Solution x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. Solution -&gt; Rep Solution x
from :: forall x. Solution -&gt; Rep Solution x
$cto :: forall x. Rep Solution x -&gt; Solution
to :: forall x. Rep Solution x -&gt; Solution
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-537"></span><span>
</span><span id="line-538"></span><span class="hs-comment">-- TomlCodecs</span><span>
</span><span id="line-539"></span><span class="annot"><a href="Language.Lambda.Impl.html#configCodec"><span class="hs-identifier hs-type">configCodec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TomlCodec</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Config"><span class="hs-identifier hs-type">Config</span></a></span><span>
</span><span id="line-540"></span><span id="configCodec"><span class="annot"><span class="annottext">configCodec :: TomlCodec Config
</span><a href="Language.Lambda.Impl.html#configCodec"><span class="hs-identifier hs-var hs-var">configCodec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-541"></span><span>  </span><span class="annot"><span class="annottext">Text -&gt; Text -&gt; [Problem] -&gt; Config
</span><a href="Language.Lambda.Impl.html#Config"><span class="hs-identifier hs-var">Config</span></a></span><span>
</span><span id="line-542"></span><span>    </span><span class="annot"><span class="annottext">(Text -&gt; Text -&gt; [Problem] -&gt; Config)
-&gt; Codec Config Text -&gt; Codec Config (Text -&gt; [Problem] -&gt; Config)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Key -&gt; TomlCodec Text
</span><span class="hs-identifier hs-var">Toml.text</span></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;language&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Text -&gt; (Config -&gt; Text) -&gt; Codec Config Text
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">Config -&gt; Text
</span><a href="Language.Lambda.Impl.html#configLanguage"><span class="hs-identifier hs-var">configLanguage</span></a></span><span>
</span><span id="line-543"></span><span>    </span><span class="annot"><span class="annottext">Codec Config (Text -&gt; [Problem] -&gt; Config)
-&gt; Codec Config Text -&gt; Codec Config ([Problem] -&gt; Config)
forall a b.
Codec Config (a -&gt; b) -&gt; Codec Config a -&gt; Codec Config b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Key -&gt; TomlCodec Text
</span><span class="hs-identifier hs-var">Toml.text</span></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;fragment&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Text -&gt; (Config -&gt; Text) -&gt; Codec Config Text
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">Config -&gt; Text
</span><a href="Language.Lambda.Impl.html#configFragment"><span class="hs-identifier hs-var">configFragment</span></a></span><span>
</span><span id="line-544"></span><span>    </span><span class="annot"><span class="annottext">Codec Config ([Problem] -&gt; Config)
-&gt; Codec Config [Problem] -&gt; TomlCodec Config
forall a b.
Codec Config (a -&gt; b) -&gt; Codec Config a -&gt; Codec Config b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Problem -&gt; Key -&gt; TomlCodec [Problem]
forall a. TomlCodec a -&gt; Key -&gt; TomlCodec [a]
</span><span class="hs-identifier hs-var">Toml.list</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Problem
</span><a href="Language.Lambda.Impl.html#problemCodec"><span class="hs-identifier hs-var">problemCodec</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;problems&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec [Problem]
-&gt; (Config -&gt; [Problem]) -&gt; Codec Config [Problem]
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">Config -&gt; [Problem]
</span><a href="Language.Lambda.Impl.html#configProblems"><span class="hs-identifier hs-var">configProblems</span></a></span><span>
</span><span id="line-545"></span><span>
</span><span id="line-546"></span><span class="annot"><a href="Language.Lambda.Impl.html#problemCodec"><span class="hs-identifier hs-type">problemCodec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TomlCodec</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-type">Problem</span></a></span><span>
</span><span id="line-547"></span><span id="problemCodec"><span class="annot"><span class="annottext">problemCodec :: TomlCodec Problem
</span><a href="Language.Lambda.Impl.html#problemCodec"><span class="hs-identifier hs-var hs-var">problemCodec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-548"></span><span>  </span><span class="annot"><span class="annottext">[UnificationConstraint] -&gt; [Solution] -&gt; Problem
</span><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-var">Problem</span></a></span><span>
</span><span id="line-549"></span><span>    </span><span class="annot"><span class="annottext">([UnificationConstraint] -&gt; [Solution] -&gt; Problem)
-&gt; Codec Problem [UnificationConstraint]
-&gt; Codec Problem ([Solution] -&gt; Problem)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Codec Problem [UnificationConstraint]
forall {object}. Codec object [UnificationConstraint]
</span><a href="#local-6989586621679246629"><span class="hs-identifier hs-var">constraintsCodec</span></a></span><span>
</span><span id="line-550"></span><span>    </span><span class="annot"><span class="annottext">Codec Problem ([Solution] -&gt; Problem)
-&gt; Codec Problem [Solution] -&gt; TomlCodec Problem
forall a b.
Codec Problem (a -&gt; b) -&gt; Codec Problem a -&gt; Codec Problem b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Solution -&gt; Key -&gt; TomlCodec [Solution]
forall a. TomlCodec a -&gt; Key -&gt; TomlCodec [a]
</span><span class="hs-identifier hs-var">Toml.list</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Solution
</span><a href="Language.Lambda.Impl.html#solutionCodec"><span class="hs-identifier hs-var">solutionCodec</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;solutions&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec [Solution]
-&gt; (Problem -&gt; [Solution]) -&gt; Codec Problem [Solution]
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">Problem -&gt; [Solution]
</span><a href="Language.Lambda.Impl.html#problemSolutions"><span class="hs-identifier hs-var">problemSolutions</span></a></span><span>
</span><span id="line-551"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-552"></span><span>  </span><span id="local-6989586621679246629"><span class="annot"><span class="annottext">constraintsCodec :: Codec object [UnificationConstraint]
</span><a href="#local-6989586621679246629"><span class="hs-identifier hs-var hs-var">constraintsCodec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-553"></span><span>    </span><span class="annot"><span class="annottext">(Text -&gt; UnificationConstraint)
-&gt; [Text] -&gt; [UnificationConstraint]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#unsafeParseUnificationConstraint"><span class="hs-identifier hs-var">unsafeParseUnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; UnificationConstraint)
-&gt; (Text -&gt; String) -&gt; Text -&gt; UnificationConstraint
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; String
</span><span class="hs-identifier hs-var">TIO.unpack</span></span><span class="hs-special">)</span><span>
</span><span id="line-554"></span><span>      </span><span class="annot"><span class="annottext">([Text] -&gt; [UnificationConstraint])
-&gt; Codec object [Text] -&gt; Codec object [UnificationConstraint]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">TomlBiMap Text AnyValue -&gt; Key -&gt; TomlCodec [Text]
forall a. TomlBiMap a AnyValue -&gt; Key -&gt; TomlCodec [a]
</span><span class="hs-identifier hs-var">Toml.arrayOf</span></span><span> </span><span class="annot"><span class="annottext">TomlBiMap Text AnyValue
</span><span class="hs-identifier hs-var">Toml._Text</span></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;constraints&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec [Text] -&gt; (object -&gt; [Text]) -&gt; Codec object [Text]
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; object -&gt; [Text]
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;no encode needed&quot;</span></span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span id="local-6989586621679245408"><span class="annot"><a href="Language.Lambda.Impl.html#parseTextToEither"><span class="hs-identifier hs-type">parseTextToEither</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="#local-6989586621679245408"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span> </span><span class="annot"><a href="#local-6989586621679245408"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-557"></span><span id="parseTextToEither"><span class="annot"><span class="annottext">parseTextToEither :: forall a. (String -&gt; Either String a) -&gt; Text -&gt; Either Text a
</span><a href="Language.Lambda.Impl.html#parseTextToEither"><span class="hs-identifier hs-var hs-var">parseTextToEither</span></a></span></span><span> </span><span id="local-6989586621679246643"><span class="annot"><span class="annottext">String -&gt; Either String a
</span><a href="#local-6989586621679246643"><span class="hs-identifier hs-var">parse</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; Text) -&gt; Either String a -&gt; Either Text a
forall a b c. (a -&gt; b) -&gt; Either a c -&gt; Either b c
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Text
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(Either String a -&gt; Either Text a)
-&gt; (Text -&gt; Either String a) -&gt; Text -&gt; Either Text a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Either String a
</span><a href="#local-6989586621679246643"><span class="hs-identifier hs-var">parse</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Either String a)
-&gt; (Text -&gt; String) -&gt; Text -&gt; Either String a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; String
</span><span class="hs-identifier hs-var">TIO.unpack</span></span><span>
</span><span id="line-558"></span><span>
</span><span id="line-559"></span><span class="annot"><a href="Language.Lambda.Impl.html#solutionCodec"><span class="hs-identifier hs-type">solutionCodec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TomlCodec</span></span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span>
</span><span id="line-560"></span><span id="solutionCodec"><span class="annot"><span class="annottext">solutionCodec :: TomlCodec Solution
</span><a href="Language.Lambda.Impl.html#solutionCodec"><span class="hs-identifier hs-var hs-var">solutionCodec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-561"></span><span>  </span><span class="annot"><span class="annottext">Text -&gt; [MetaSubst'] -&gt; Solution
</span><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-var">Solution</span></a></span><span>
</span><span id="line-562"></span><span>    </span><span class="annot"><span class="annottext">(Text -&gt; [MetaSubst'] -&gt; Solution)
-&gt; Codec Solution Text -&gt; Codec Solution ([MetaSubst'] -&gt; Solution)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Key -&gt; TomlCodec Text
</span><span class="hs-identifier hs-var">Toml.text</span></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;name&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Text -&gt; (Solution -&gt; Text) -&gt; Codec Solution Text
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">Solution -&gt; Text
</span><a href="Language.Lambda.Impl.html#solutionName"><span class="hs-identifier hs-var">solutionName</span></a></span><span>
</span><span id="line-563"></span><span>    </span><span class="annot"><span class="annottext">Codec Solution ([MetaSubst'] -&gt; Solution)
-&gt; Codec Solution [MetaSubst'] -&gt; TomlCodec Solution
forall a b.
Codec Solution (a -&gt; b) -&gt; Codec Solution a -&gt; Codec Solution b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Codec Solution [MetaSubst']
forall {object}. Codec object [MetaSubst']
</span><a href="#local-6989586621679246644"><span class="hs-identifier hs-var">substitutionsCodec</span></a></span><span>
</span><span id="line-564"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-565"></span><span>  </span><span id="local-6989586621679246644"><span class="annot"><span class="annottext">substitutionsCodec :: Codec object [MetaSubst']
</span><a href="#local-6989586621679246644"><span class="hs-identifier hs-var hs-var">substitutionsCodec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-566"></span><span>    </span><span class="annot"><span class="annottext">(Text -&gt; MetaSubst') -&gt; [Text] -&gt; [MetaSubst']
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; MetaSubst'
</span><a href="Language.Lambda.Impl.html#unsafeParseMetaSubst"><span class="hs-identifier hs-var">unsafeParseMetaSubst</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; MetaSubst') -&gt; (Text -&gt; String) -&gt; Text -&gt; MetaSubst'
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; String
</span><span class="hs-identifier hs-var">TIO.unpack</span></span><span class="hs-special">)</span><span>
</span><span id="line-567"></span><span>      </span><span class="annot"><span class="annottext">([Text] -&gt; [MetaSubst'])
-&gt; Codec object [Text] -&gt; Codec object [MetaSubst']
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">TomlBiMap Text AnyValue -&gt; Key -&gt; TomlCodec [Text]
forall a. TomlBiMap a AnyValue -&gt; Key -&gt; TomlCodec [a]
</span><span class="hs-identifier hs-var">Toml.arrayOf</span></span><span> </span><span class="annot"><span class="annottext">TomlBiMap Text AnyValue
</span><span class="hs-identifier hs-var">Toml._Text</span></span><span> </span><span class="annot"><span class="annottext">Key
</span><span class="hs-string">&quot;substitutions&quot;</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec [Text] -&gt; (object -&gt; [Text]) -&gt; Codec object [Text]
forall field a object.
Codec field a -&gt; (object -&gt; field) -&gt; Codec object a
</span><span class="hs-operator hs-var">.=</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; object -&gt; [Text]
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;no encode needed&quot;</span></span><span>
</span><span id="line-568"></span><span>
</span><span id="line-569"></span><span id="local-6989586621679245411"><span class="annot"><a href="Language.Lambda.Impl.html#toCodec"><span class="hs-identifier hs-type">toCodec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="#local-6989586621679245411"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="#local-6989586621679245411"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Toml.Key</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TomlCodec</span></span><span> </span><span class="annot"><a href="#local-6989586621679245411"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-570"></span><span id="toCodec"><span class="annot"><span class="annottext">toCodec :: forall a.
Show a =&gt;
(String -&gt; Either String a) -&gt; Key -&gt; TomlCodec a
</span><a href="Language.Lambda.Impl.html#toCodec"><span class="hs-identifier hs-var hs-var">toCodec</span></a></span></span><span> </span><span id="local-6989586621679246653"><span class="annot"><span class="annottext">String -&gt; Either String a
</span><a href="#local-6989586621679246653"><span class="hs-identifier hs-var">parseString</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-571"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246654"><span class="annot"><span class="annottext">parseText :: Text -&gt; Either Text a
</span><a href="#local-6989586621679246654"><span class="hs-identifier hs-var hs-var">parseText</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String -&gt; Text) -&gt; Either String a -&gt; Either Text a
forall a b c. (a -&gt; b) -&gt; Either a c -&gt; Either b c
forall (p :: * -&gt; * -&gt; *) a b c.
Bifunctor p =&gt;
(a -&gt; b) -&gt; p a c -&gt; p b c
</span><span class="hs-identifier hs-var">first</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Text
forall a. IsString a =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">fromString</span></span><span> </span><span class="annot"><span class="annottext">(Either String a -&gt; Either Text a)
-&gt; (Text -&gt; Either String a) -&gt; Text -&gt; Either Text a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Either String a
</span><a href="#local-6989586621679246653"><span class="hs-identifier hs-var">parseString</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Either String a)
-&gt; (Text -&gt; String) -&gt; Text -&gt; Either String a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; String
</span><span class="hs-identifier hs-var">TIO.unpack</span></span><span>
</span><span id="line-572"></span><span>      </span><span id="local-6989586621679246656"><span class="annot"><span class="annottext">showText :: a -&gt; Text
</span><a href="#local-6989586621679246656"><span class="hs-identifier hs-var hs-var">showText</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Text
</span><span class="hs-identifier hs-var">TIO.pack</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Text) -&gt; (a -&gt; String) -&gt; a -&gt; Text
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span>
</span><span id="line-573"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Text) -&gt; (Text -&gt; Either Text a) -&gt; Key -&gt; TomlCodec a
forall a.
(a -&gt; Text) -&gt; (Text -&gt; Either Text a) -&gt; Key -&gt; TomlCodec a
</span><span class="hs-identifier hs-var">Toml.textBy</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Text
</span><a href="#local-6989586621679246656"><span class="hs-identifier hs-var">showText</span></a></span><span> </span><span class="annot"><span class="annottext">Text -&gt; Either Text a
</span><a href="#local-6989586621679246654"><span class="hs-identifier hs-var">parseText</span></a></span><span>
</span><span id="line-574"></span><span>
</span><span id="line-575"></span><span class="annot"><a href="Language.Lambda.Impl.html#validateProblem"><span class="hs-identifier hs-type">validateProblem</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-type">Problem</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-576"></span><span id="validateProblem"><span class="annot"><span class="annottext">validateProblem :: Problem -&gt; ([(Solution, [UnificationConstraint])], [Solution])
</span><a href="Language.Lambda.Impl.html#validateProblem"><span class="hs-identifier hs-var hs-var">validateProblem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-type">Problem</span></a></span><span> </span><span id="local-6989586621679246660"><span class="annot"><span class="annottext">[UnificationConstraint]
</span><a href="#local-6989586621679246660"><span class="hs-identifier hs-var">constraints</span></a></span></span><span> </span><span id="local-6989586621679246661"><span class="annot"><span class="annottext">[Solution]
</span><a href="#local-6989586621679246661"><span class="hs-identifier hs-var">solutions</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-577"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246662"><span class="annot"><span class="annottext">results :: [Either (Solution, [UnificationConstraint]) Solution]
</span><a href="#local-6989586621679246662"><span class="hs-identifier hs-var hs-var">results</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Solution -&gt; Either (Solution, [UnificationConstraint]) Solution)
-&gt; [Solution]
-&gt; [Either (Solution, [UnificationConstraint]) Solution]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[UnificationConstraint]
-&gt; Solution -&gt; Either (Solution, [UnificationConstraint]) Solution
</span><a href="Language.Lambda.Impl.html#validateSolution"><span class="hs-identifier hs-var">validateSolution</span></a></span><span> </span><span class="annot"><span class="annottext">[UnificationConstraint]
</span><a href="#local-6989586621679246660"><span class="hs-identifier hs-var">constraints</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Solution]
</span><a href="#local-6989586621679246661"><span class="hs-identifier hs-var">solutions</span></a></span><span>
</span><span id="line-578"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[Either (Solution, [UnificationConstraint]) Solution]
-&gt; ([(Solution, [UnificationConstraint])], [Solution])
forall a b. [Either a b] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">partitionEithers</span></span><span> </span><span class="annot"><span class="annottext">[Either (Solution, [UnificationConstraint]) Solution]
</span><a href="#local-6989586621679246662"><span class="hs-identifier hs-var">results</span></a></span><span>
</span><span id="line-579"></span><span>
</span><span id="line-580"></span><span class="hs-comment">-- Helper function to check if a constraint is solved by a specific solution</span><span>
</span><span id="line-581"></span><span class="annot"><a href="Language.Lambda.Impl.html#validateSolution"><span class="hs-identifier hs-type">validateSolution</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Lambda.Impl.html#UnificationConstraint"><span class="hs-identifier hs-type">UnificationConstraint</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span>
</span><span id="line-582"></span><span id="validateSolution"><span class="annot"><span class="annottext">validateSolution :: [UnificationConstraint]
-&gt; Solution -&gt; Either (Solution, [UnificationConstraint]) Solution
</span><a href="Language.Lambda.Impl.html#validateSolution"><span class="hs-identifier hs-var hs-var">validateSolution</span></a></span></span><span> </span><span id="local-6989586621679246664"><span class="annot"><span class="annottext">[UnificationConstraint]
</span><a href="#local-6989586621679246664"><span class="hs-identifier hs-var">constraints</span></a></span></span><span> </span><span id="local-6989586621679246665"><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246665"><span class="hs-identifier hs-var">solution</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-583"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679246666"><span class="annot"><span class="annottext">substs :: MetaSubsts'
</span><a href="#local-6989586621679246666"><span class="hs-identifier hs-var hs-var">substs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[MetaSubst'] -&gt; MetaSubsts'
forall (binder :: S -&gt; S -&gt; *) (sig :: * -&gt; * -&gt; *) metavar
       (ext :: * -&gt; * -&gt; *) t.
[MetaSubst binder sig metavar ext t]
-&gt; MetaSubsts binder sig metavar ext t
</span><a href="Data.SOAS.html#MetaSubsts"><span class="hs-identifier hs-var">MetaSubsts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Solution -&gt; [MetaSubst']
</span><a href="Language.Lambda.Impl.html#solutionSubstitutions"><span class="hs-identifier hs-var">solutionSubstitutions</span></a></span><span> </span><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246665"><span class="hs-identifier hs-var">solution</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-584"></span><span>      </span><span id="local-6989586621679246668"><span class="annot"><span class="annottext">constraints' :: [UnificationConstraint]
</span><a href="#local-6989586621679246668"><span class="hs-identifier hs-var hs-var">constraints'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(UnificationConstraint -&gt; UnificationConstraint)
-&gt; [UnificationConstraint] -&gt; [UnificationConstraint]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MetaSubsts' -&gt; UnificationConstraint -&gt; UnificationConstraint
</span><a href="Language.Lambda.Impl.html#solveUnificationConstraint"><span class="hs-identifier hs-var">solveUnificationConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">MetaSubsts'
</span><a href="#local-6989586621679246666"><span class="hs-identifier hs-var">substs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[UnificationConstraint]
</span><a href="#local-6989586621679246664"><span class="hs-identifier hs-var">constraints</span></a></span><span>
</span><span id="line-585"></span><span>   </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">(UnificationConstraint -&gt; Bool) -&gt; [UnificationConstraint] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">UnificationConstraint -&gt; Bool
</span><a href="Language.Lambda.Impl.html#isSolved"><span class="hs-identifier hs-var">isSolved</span></a></span><span> </span><span class="annot"><span class="annottext">[UnificationConstraint]
</span><a href="#local-6989586621679246668"><span class="hs-identifier hs-var">constraints'</span></a></span><span>
</span><span id="line-586"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Solution -&gt; Either (Solution, [UnificationConstraint]) Solution
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246665"><span class="hs-identifier hs-var">solution</span></a></span><span>
</span><span id="line-587"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">(Solution, [UnificationConstraint])
-&gt; Either (Solution, [UnificationConstraint]) Solution
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246665"><span class="hs-identifier hs-var">solution</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[UnificationConstraint]
</span><a href="#local-6989586621679246668"><span class="hs-identifier hs-var">constraints'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-588"></span><span>
</span><span id="line-589"></span><span id="local-6989586621679245423"><span id="local-6989586621679245424"><span class="annot"><a href="Language.Lambda.Impl.html#printInvalidSolutionsWithConstraint"><span class="hs-identifier hs-type">printInvalidSolutionsWithConstraint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679245423"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="annot"><a href="#local-6989586621679245424"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Lambda.Impl.html#Solution"><span class="hs-identifier hs-type">Solution</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679245423"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679245424"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-590"></span><span id="printInvalidSolutionsWithConstraint"><span class="annot"><span class="annottext">printInvalidSolutionsWithConstraint :: forall (t :: * -&gt; *) a.
(Foldable t, Show a) =&gt;
(Solution, t a) -&gt; IO ()
</span><a href="Language.Lambda.Impl.html#printInvalidSolutionsWithConstraint"><span class="hs-identifier hs-var hs-var">printInvalidSolutionsWithConstraint</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246696"><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246696"><span class="hs-identifier hs-var">solution</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246697"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679246697"><span class="hs-identifier hs-var">constraints</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-591"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; IO ()) -&gt; String -&gt; IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Char -&gt; String
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">25</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'-'</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n&quot;</span></span><span>
</span><span id="line-592"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; IO ()) -&gt; String -&gt; IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Solution: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; String
</span><span class="hs-identifier hs-var">TIO.unpack</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Solution -&gt; Text
</span><a href="Language.Lambda.Impl.html#solutionName"><span class="hs-identifier hs-var">solutionName</span></a></span><span> </span><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246696"><span class="hs-identifier hs-var">solution</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-593"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-594"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Substitutions:&quot;</span></span><span>
</span><span id="line-595"></span><span>  </span><span class="annot"><span class="annottext">(MetaSubst' -&gt; IO ()) -&gt; [MetaSubst'] -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; IO ()) -&gt; (MetaSubst' -&gt; String) -&gt; MetaSubst' -&gt; IO ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;- &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(String -&gt; String)
-&gt; (MetaSubst' -&gt; String) -&gt; MetaSubst' -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">MetaSubst' -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Solution -&gt; [MetaSubst']
</span><a href="Language.Lambda.Impl.html#solutionSubstitutions"><span class="hs-identifier hs-var">solutionSubstitutions</span></a></span><span> </span><span class="annot"><span class="annottext">Solution
</span><a href="#local-6989586621679246696"><span class="hs-identifier hs-var">solution</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-596"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-597"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Constraints with applied substitutions:&quot;</span></span><span>
</span><span id="line-598"></span><span>  </span><span class="annot"><span class="annottext">(a -&gt; IO ()) -&gt; t a -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; IO ()) -&gt; (a -&gt; String) -&gt; a -&gt; IO ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;- &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(String -&gt; String) -&gt; (a -&gt; String) -&gt; a -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679246697"><span class="hs-identifier hs-var">constraints</span></a></span><span>
</span><span id="line-599"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-600"></span><span>  </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; IO ()) -&gt; String -&gt; IO ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Char -&gt; String
forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">25</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'-'</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n&quot;</span></span><span>
</span><span id="line-601"></span><span>
</span><span id="line-602"></span><span class="hs-comment">-- Main function to parse and print the configuration</span><span>
</span><span id="line-603"></span><span class="annot"><a href="Language.Lambda.Impl.html#parseConfigAndValidate"><span class="hs-identifier hs-type">parseConfigAndValidate</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-604"></span><span id="parseConfigAndValidate"><span class="annot"><span class="annottext">parseConfigAndValidate :: IO ()
</span><a href="Language.Lambda.Impl.html#parseConfigAndValidate"><span class="hs-identifier hs-var hs-var">parseConfigAndValidate</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-605"></span><span>  </span><span id="local-6989586621679246701"><span class="annot"><span class="annottext">Either [TomlDecodeError] Config
</span><a href="#local-6989586621679246701"><span class="hs-identifier hs-var">configResult</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TomlCodec Config -&gt; String -&gt; IO (Either [TomlDecodeError] Config)
forall a (m :: * -&gt; *).
MonadIO m =&gt;
TomlCodec a -&gt; String -&gt; m (Either [TomlDecodeError] a)
</span><span class="hs-identifier hs-var">Toml.decodeFileEither</span></span><span> </span><span class="annot"><span class="annottext">TomlCodec Config
</span><a href="Language.Lambda.Impl.html#configCodec"><span class="hs-identifier hs-var">configCodec</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;config.toml&quot;</span></span><span>
</span><span id="line-606"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either [TomlDecodeError] Config
</span><a href="#local-6989586621679246701"><span class="hs-identifier hs-var">configResult</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-607"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679246703"><span class="annot"><span class="annottext">[TomlDecodeError]
</span><a href="#local-6989586621679246703"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[TomlDecodeError] -&gt; IO ()
forall a. Show a =&gt; a -&gt; IO ()
</span><span class="hs-identifier hs-var">print</span></span><span> </span><span class="annot"><span class="annottext">[TomlDecodeError]
</span><a href="#local-6989586621679246703"><span class="hs-identifier hs-var">err</span></a></span><span>
</span><span id="line-608"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679246704"><span class="annot"><span class="annottext">Config
</span><a href="#local-6989586621679246704"><span class="hs-identifier hs-var">cfg</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Problem -&gt; IO ()) -&gt; [Problem] -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="annot"><span class="annottext">Problem -&gt; IO ()
</span><a href="#local-6989586621679246705"><span class="hs-identifier hs-var">validateAndPrintProblem</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Config -&gt; [Problem]
</span><a href="Language.Lambda.Impl.html#configProblems"><span class="hs-identifier hs-var">configProblems</span></a></span><span> </span><span class="annot"><span class="annottext">Config
</span><a href="#local-6989586621679246704"><span class="hs-identifier hs-var">cfg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-609"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-610"></span><span>  </span><span class="annot"><a href="#local-6989586621679246705"><span class="hs-identifier hs-type">validateAndPrintProblem</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Lambda.Impl.html#Problem"><span class="hs-identifier hs-type">Problem</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-611"></span><span>  </span><span id="local-6989586621679246705"><span class="annot"><span class="annottext">validateAndPrintProblem :: Problem -&gt; IO ()
</span><a href="#local-6989586621679246705"><span class="hs-identifier hs-var hs-var">validateAndPrintProblem</span></a></span></span><span> </span><span id="local-6989586621679246706"><span class="annot"><span class="annottext">Problem
</span><a href="#local-6989586621679246706"><span class="hs-identifier hs-var">problem</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-612"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679246707"><span class="annot"><span class="annottext">[(Solution, [UnificationConstraint])]
</span><a href="#local-6989586621679246707"><span class="hs-identifier hs-var">invalidSolutionsWithConstraints</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679246708"><span class="annot"><span class="annottext">[Solution]
</span><a href="#local-6989586621679246708"><span class="hs-identifier hs-var">validatedSolutions</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Problem -&gt; ([(Solution, [UnificationConstraint])], [Solution])
</span><a href="Language.Lambda.Impl.html#validateProblem"><span class="hs-identifier hs-var">validateProblem</span></a></span><span> </span><span class="annot"><span class="annottext">Problem
</span><a href="#local-6989586621679246706"><span class="hs-identifier hs-var">problem</span></a></span><span>
</span><span id="line-613"></span><span>    </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;=== Validated solutions ===&quot;</span></span><span>
</span><span id="line-614"></span><span>    </span><span class="annot"><span class="annottext">(Solution -&gt; IO ()) -&gt; [Solution] -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; IO ()) -&gt; (Solution -&gt; String) -&gt; Solution -&gt; IO ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;- &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(String -&gt; String) -&gt; (Solution -&gt; String) -&gt; Solution -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Text -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">(Text -&gt; String) -&gt; (Solution -&gt; Text) -&gt; Solution -&gt; String
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Solution -&gt; Text
</span><a href="Language.Lambda.Impl.html#solutionName"><span class="hs-identifier hs-var">solutionName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Solution]
</span><a href="#local-6989586621679246708"><span class="hs-identifier hs-var">validatedSolutions</span></a></span><span>
</span><span id="line-615"></span><span>    </span><span class="annot"><span class="annottext">String -&gt; IO ()
</span><span class="hs-identifier hs-var">putStrLn</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n=== Invalid solutions ===\n&quot;</span></span><span>
</span><span id="line-616"></span><span>    </span><span class="annot"><span class="annottext">((Solution, [UnificationConstraint]) -&gt; IO ())
-&gt; [(Solution, [UnificationConstraint])] -&gt; IO ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="annot"><span class="annottext">(Solution, [UnificationConstraint]) -&gt; IO ()
forall (t :: * -&gt; *) a.
(Foldable t, Show a) =&gt;
(Solution, t a) -&gt; IO ()
</span><a href="Language.Lambda.Impl.html#printInvalidSolutionsWithConstraint"><span class="hs-identifier hs-var">printInvalidSolutionsWithConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">[(Solution, [UnificationConstraint])]
</span><a href="#local-6989586621679246707"><span class="hs-identifier hs-var">invalidSolutionsWithConstraints</span></a></span><span>
</span><span id="line-617"></span><span>
</span><span id="line-618"></span><span class="annot"><a href="Language.Lambda.Impl.html#main"><span class="hs-identifier hs-type">main</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-619"></span><span id="main"><span class="annot"><span class="annottext">main :: IO ()
</span><a href="Language.Lambda.Impl.html#main"><span class="hs-identifier hs-var hs-var">main</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IO ()
</span><a href="Language.Lambda.Impl.html#parseConfigAndValidate"><span class="hs-identifier hs-var">parseConfigAndValidate</span></a></span><span>
</span><span id="line-620"></span><span class="hs-comment">-- main = do</span><span>
</span><span id="line-621"></span><span class="hs-comment">--   let lhs = &quot;M[&#955;y:t. &#955;x:t. x, &#955;a:t. &#955;a:t. a]&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-622"></span><span class="hs-comment">--   let rhs = &quot;&#955;y:t. &#955;x:t. x&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-623"></span><span class="hs-comment">--   let res = match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-624"></span><span class="hs-comment">--   print res</span><span>
</span><span id="line-625"></span><span>
</span><span id="line-626"></span><span class="hs-comment">-- &#8704; x, y. M[&#955;z.N[x, y], x y] = &#955;a.&#955;b.x</span><span>
</span><span id="line-627"></span><span class="hs-comment">-- M [z1, z2] &#8614; &#955;a.z1</span><span>
</span><span id="line-628"></span><span class="hs-comment">-- N [z1, z2] &#8614; z1</span><span>
</span><span id="line-629"></span><span>
</span><span id="line-630"></span><span class="hs-comment">-- &gt;&gt;&gt; lhs = &quot;M[&#955;x:t.x, &#955;x:t.x]&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-631"></span><span class="hs-comment">-- &gt;&gt;&gt; rhs = &quot;&#955;x:t.x&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-632"></span><span class="hs-comment">-- &gt;&gt;&gt; match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-633"></span><span class="hs-comment">-- [[M [x0 : T, x1 : T] &#8614; x0],[M [x0 : T, x1 : T] &#8614; x1],[M [x0 : T, x1 : T] &#8614; &#955; x2 : t . x2]]</span><span>
</span><span id="line-634"></span><span>
</span><span id="line-635"></span><span class="hs-comment">-- &gt;&gt;&gt; lhs = &quot;M[&#955;y:t. y, &#955;a:t. &#955;a:t. a]&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-636"></span><span class="hs-comment">-- &gt;&gt;&gt; rhs = &quot;&#955;y:t. y&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-637"></span><span class="hs-comment">-- &gt;&gt;&gt; match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-638"></span><span class="hs-comment">-- [[M [x0 : T, x1 : T] &#8614; x0],[M [x0 : T, x1 : T] &#8614; &#955; x2 : t . x2]]</span><span>
</span><span id="line-639"></span><span>
</span><span id="line-640"></span><span class="hs-comment">-- &gt;&gt;&gt; lhs = &quot;M[]&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-641"></span><span class="hs-comment">-- &gt;&gt;&gt; rhs = &quot;&#955;x:t.x&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-642"></span><span class="hs-comment">-- &gt;&gt;&gt; match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-643"></span><span class="hs-comment">-- [[M [] &#8614; &#955; x0 : t . x0]]</span><span>
</span><span id="line-644"></span><span>
</span><span id="line-645"></span><span class="hs-comment">-- &gt;&gt;&gt; lhs = &quot;&#955;x : t. x&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-646"></span><span class="hs-comment">-- &gt;&gt;&gt; rhs = &quot;&#955;y : t. y&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-647"></span><span class="hs-comment">-- &gt;&gt;&gt; match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-648"></span><span class="hs-comment">-- [[]]</span><span>
</span><span id="line-649"></span><span>
</span><span id="line-650"></span><span class="hs-comment">-- &gt;&gt;&gt; lhs = &quot;&#955;x : t. &#955;x : t. x&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-651"></span><span class="hs-comment">-- &gt;&gt;&gt; rhs = &quot;&#955;y : t. y&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-652"></span><span class="hs-comment">-- &gt;&gt;&gt; match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-653"></span><span class="hs-comment">-- []</span><span>
</span><span id="line-654"></span><span>
</span><span id="line-655"></span><span class="hs-comment">-- &gt;&gt;&gt; lhs = &quot;&#955;y:t. M[&#955;x:t. x]&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-656"></span><span class="hs-comment">-- &gt;&gt;&gt; rhs = &quot;&#955;y:t. &#955;x:t. x&quot; :: MetaTerm Raw.MetaVarIdent Foil.VoidS</span><span>
</span><span id="line-657"></span><span class="hs-comment">-- &gt;&gt;&gt; match Foil.emptyScope lhs rhs :: [MetaSubsts']</span><span>
</span><span id="line-658"></span><span class="hs-comment">-- [[M [x0 : T] &#8614; x0],[M [x0 : T] &#8614; &#955; x1 : t . x1]]</span><span>
</span><span id="line-659"></span></pre></body></html>