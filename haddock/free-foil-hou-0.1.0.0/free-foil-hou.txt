-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/fedor-ivn/free-foil-hou#readme</a>
@package free-foil-hou
@version 0.1.0.0


-- | The abstract syntax of language Syntax.
module Language.Lambda.Syntax.Abs
data Program
AProgram :: [Command] -> Program
data Command
CommandCompute :: Term -> Command
data Term
Lam :: Pattern -> Type -> ScopedTerm -> Term
Let :: Pattern -> Term -> ScopedTerm -> Term
App :: Term -> Term -> Term
Var :: VarIdent -> Term
MetaVar :: MetaVarIdent -> [Term] -> Term
data ScopedTerm
AScopedTerm :: Term -> ScopedTerm
data Pattern
APattern :: VarIdent -> Pattern
data Binder
ABinder :: VarIdent -> Type -> Binder
data MetaSubst
AMetaSubst :: MetaVarIdent -> [Binder] -> ScopedTerm -> MetaSubst
data UnificationConstraint
AUnificationConstraint :: [Binder] -> ScopedTerm -> ScopedTerm -> UnificationConstraint
data Type
Fun :: Type -> Type -> Type
Base :: VarIdent -> Type
newtype VarIdent
VarIdent :: String -> VarIdent
newtype MetaVarIdent
MetaVarIdent :: String -> MetaVarIdent
instance Data.Data.Data Language.Lambda.Syntax.Abs.Binder
instance Data.Data.Data Language.Lambda.Syntax.Abs.Command
instance Data.Data.Data Language.Lambda.Syntax.Abs.MetaSubst
instance Data.Data.Data Language.Lambda.Syntax.Abs.MetaVarIdent
instance Data.Data.Data Language.Lambda.Syntax.Abs.Pattern
instance Data.Data.Data Language.Lambda.Syntax.Abs.Program
instance Data.Data.Data Language.Lambda.Syntax.Abs.ScopedTerm
instance Data.Data.Data Language.Lambda.Syntax.Abs.Term
instance Data.Data.Data Language.Lambda.Syntax.Abs.Type
instance Data.Data.Data Language.Lambda.Syntax.Abs.UnificationConstraint
instance Data.Data.Data Language.Lambda.Syntax.Abs.VarIdent
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.Binder
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.Command
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.MetaSubst
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.MetaVarIdent
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.Pattern
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.Program
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.ScopedTerm
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.Term
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.Type
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.UnificationConstraint
instance GHC.Classes.Eq Language.Lambda.Syntax.Abs.VarIdent
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.Binder
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.Command
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.MetaSubst
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.MetaVarIdent
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.Pattern
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.Program
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.ScopedTerm
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.Term
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.Type
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.UnificationConstraint
instance GHC.Generics.Generic Language.Lambda.Syntax.Abs.VarIdent
instance Data.String.IsString Language.Lambda.Syntax.Abs.MetaVarIdent
instance Data.String.IsString Language.Lambda.Syntax.Abs.VarIdent
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.Binder
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.Command
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.MetaSubst
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.MetaVarIdent
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.Pattern
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.Program
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.ScopedTerm
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.Term
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.Type
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.UnificationConstraint
instance GHC.Classes.Ord Language.Lambda.Syntax.Abs.VarIdent
instance GHC.Read.Read Language.Lambda.Syntax.Abs.Binder
instance GHC.Read.Read Language.Lambda.Syntax.Abs.Command
instance GHC.Read.Read Language.Lambda.Syntax.Abs.MetaSubst
instance GHC.Read.Read Language.Lambda.Syntax.Abs.MetaVarIdent
instance GHC.Read.Read Language.Lambda.Syntax.Abs.Pattern
instance GHC.Read.Read Language.Lambda.Syntax.Abs.Program
instance GHC.Read.Read Language.Lambda.Syntax.Abs.ScopedTerm
instance GHC.Read.Read Language.Lambda.Syntax.Abs.Term
instance GHC.Read.Read Language.Lambda.Syntax.Abs.Type
instance GHC.Read.Read Language.Lambda.Syntax.Abs.UnificationConstraint
instance GHC.Read.Read Language.Lambda.Syntax.Abs.VarIdent
instance GHC.Show.Show Language.Lambda.Syntax.Abs.Binder
instance GHC.Show.Show Language.Lambda.Syntax.Abs.Command
instance GHC.Show.Show Language.Lambda.Syntax.Abs.MetaSubst
instance GHC.Show.Show Language.Lambda.Syntax.Abs.MetaVarIdent
instance GHC.Show.Show Language.Lambda.Syntax.Abs.Pattern
instance GHC.Show.Show Language.Lambda.Syntax.Abs.Program
instance GHC.Show.Show Language.Lambda.Syntax.Abs.ScopedTerm
instance GHC.Show.Show Language.Lambda.Syntax.Abs.Term
instance GHC.Show.Show Language.Lambda.Syntax.Abs.Type
instance GHC.Show.Show Language.Lambda.Syntax.Abs.UnificationConstraint
instance GHC.Show.Show Language.Lambda.Syntax.Abs.VarIdent

module Data.SOAS

-- | Second-order signature for metavariable applications. This way,
--   metavariables can be added to any other signature using <a>Sum</a>.
data MetaAppSig metavar scope term

-- | A metavariable is always fully applied to a list of arguments.
MetaAppSig :: metavar -> [term] -> MetaAppSig metavar scope term

-- | A second-order abstract syntax (SOAS) is generated from a signature by
--   adding parametrised metavariables.
--   
--   Note that here we also parametrise SOAS by the type of binders
--   (patterns) <tt>binder</tt>.
type SOAS (binder :: S -> S -> Type) metavar (sig :: Type -> Type -> Type) (n :: S) = AST binder Sum sig MetaAppSig metavar n

-- | A scoped version of <a>SOAS</a>. <a>ScopedSOAS</a> is to <a>SOAS</a>
--   what <a>ScopedAST</a> is to <a>AST</a>.
type ScopedSOAS (binder :: S -> S -> Type) metavar (sig :: Type -> Type -> Type) (n :: S) = ScopedAST binder Sum sig MetaAppSig metavar n

-- | A convenient pattern synonym for parametrised metavariables.
pattern MetaApp :: forall metavar binder (sig :: Type -> Type -> Type) n. metavar -> [SOAS binder metavar sig n] -> SOAS binder metavar sig n

-- | A body of a metavariable substitution for one metavariable.
data MetaAbs (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) t
[MetaAbs] :: forall (n :: S) t (binder :: S -> S -> Type) (sig :: Type -> Type -> Type). NameBinderList 'VoidS n -> NameMap n t -> AST binder sig n -> MetaAbs binder sig t

-- | A metavariable substitution is a pair of a metavariable name and its
--   body.
newtype MetaSubst (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) metavar (ext :: Type -> Type -> Type) t
MetaSubst :: (metavar, MetaAbs binder (Sum sig ext) t) -> MetaSubst (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) metavar (ext :: Type -> Type -> Type) t
[getMetaSubst] :: MetaSubst (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) metavar (ext :: Type -> Type -> Type) t -> (metavar, MetaAbs binder (Sum sig ext) t)

-- | A collection of metavariable substitutions (for simultaneous
--   substitution of multiple metavariables).
newtype MetaSubsts (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) metavar (ext :: Type -> Type -> Type) t
MetaSubsts :: [MetaSubst binder sig metavar ext t] -> MetaSubsts (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) metavar (ext :: Type -> Type -> Type) t
[getMetaSubsts] :: MetaSubsts (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) metavar (ext :: Type -> Type -> Type) t -> [MetaSubst binder sig metavar ext t]

-- | Apply metavariable substitutions to a SOAS term.
applyMetaSubsts :: forall (sig :: Type -> Type -> Type) metavar (n :: S) (binder :: S -> S -> Type) metavar' t. (Bifunctor sig, Eq metavar, Distinct n, CoSinkable binder, SinkableK binder) => (metavar -> metavar') -> Scope n -> MetaSubsts binder sig metavar (MetaAppSig metavar') t -> SOAS binder metavar sig n -> SOAS binder metavar' sig n

-- | Combine (compose) metavariable substitutions.
--   
--   TODO: refactor
combineMetaSubsts :: forall metavar (sig :: Type -> Type -> Type) (ext :: Type -> Type -> Type) (binder :: S -> S -> Type) t. (Eq metavar, Bitraversable sig, Bitraversable ext, ZipMatchK (Sum sig ext), UnifiablePattern binder, SinkableK binder) => [MetaSubsts binder sig metavar ext t] -> [MetaSubsts binder sig metavar ext t]

-- | Match left-hand side (with metavariables) against the rigid right-hand
--   side.
--   
--   If matching is successful, it produces metavariable substitutions that
--   when applied to LHS make it syntactically equal to RHS. For example,
--   matching M[f x, g] = g (f x) produces substitution M[z₁, z₂] ↦ z₂ z₁
--   
--   There may be more than one solution for matching, e.g. M[f x, f x] = f
--   x can be solved with two different substitutions: 1. M[z₁, z₂] ↦ z₁ 2.
--   M[z₁, z₂] ↦ z₂
--   
--   Hence, this function produces a list of possible substitutions.
match :: forall (sig :: Type -> Type -> Type) metavar (n :: S) (binder :: S -> S -> Type) (ext :: Type -> Type -> Type) t. (Bitraversable sig, ZipMatchK sig, Eq metavar, Distinct n, UnifiablePattern binder, SinkableK binder, Bitraversable ext, ZipMatchK (Sum sig ext)) => Scope n -> SOAS binder metavar sig n -> AST binder (Sum sig ext) n -> [MetaSubsts binder sig metavar ext t]

-- | Same as <a>match</a> but for scoped terms.
matchScoped :: forall (sig :: Type -> Type -> Type) (n :: S) metavar (binder :: S -> S -> Type) (ext :: Type -> Type -> Type) t. (Bitraversable sig, ZipMatchK sig, Distinct n, Eq metavar, UnifiablePattern binder, SinkableK binder, Bitraversable ext, ZipMatchK (Sum sig ext)) => Scope n -> ScopedSOAS binder metavar sig n -> ScopedAST binder (Sum sig ext) n -> [MetaSubsts binder sig metavar ext t]

-- | A special case of <a>match</a>, when LHS is a parametrised
--   metavariable.
--   
--   Note that here we do not have an explicit name for that metavariable,
--   and only consider its arguments. This is helpful when recursively
--   matching with fresh metavariables, since we do not need to generate
--   any actual fresh names for such metavariables, saving in complexity
--   and performance.
--   
--   For each possible solution, this function produces a pair of
--   
--   <ol>
--   <li>Body of the metavariable substitution.</li>
--   <li>Metavariable substitutions for the metavariables that occur in the
--   parameters of the root metavariable on the LHS.</li>
--   </ol>
matchMetavar :: forall metavar (n :: S) (m :: S) (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) (ext :: Type -> Type -> Type) t. (Eq metavar, Distinct n, Distinct m, UnifiablePattern binder, SinkableK binder, Bitraversable sig, Bitraversable ext, ZipMatchK sig, ZipMatchK (Sum sig ext)) => Scope m -> NameBinderList 'VoidS m -> Scope n -> [SOAS binder metavar sig n] -> AST binder (Sum sig ext) n -> [(AST binder (Sum sig ext) m, MetaSubsts binder sig metavar ext t)]

-- | Same as <a>matchMetavar</a> but for scoped term.
matchMetavarScoped :: forall (n :: S) (m :: S) metavar (binder :: S -> S -> Type) (sig :: Type -> Type -> Type) (ext :: Type -> Type -> Type) t. (Distinct n, Distinct m, Eq metavar, UnifiablePattern binder, Bitraversable sig, Bitraversable ext, ZipMatchK sig, ZipMatchK (Sum sig ext), SinkableK binder) => Scope m -> NameBinderList 'VoidS m -> Scope n -> [SOAS binder metavar sig n] -> ScopedAST binder (Sum sig ext) n -> [(ScopedAST binder (Sum sig ext) m, MetaSubsts binder sig metavar ext t)]

-- | Generate fresh name binders for a list of things. This is useful to
--   generate proper name binders of metavariable parameters.
withFreshNameBinderList :: forall (n :: S) a (i :: S) r. Distinct n => [a] -> Scope n -> NameBinderList i n -> (forall (l :: S). Distinct l => Scope l -> NameBinderList i l -> r) -> r

-- | <i>O(n)</i>. Push a name binder into the end of a name binder list.
--   
--   <i>Should be in <a>Control.Monad.Foil</a>.</i>
push :: forall (i :: S) (l :: S) (n :: S). NameBinder i l -> NameBinderList n i -> NameBinderList n l

-- | <i>O(n)</i>. Concatenate name binder lists.
--   
--   Should be in <a>Control.Monad.Foil</a>.
concatNameBinderLists :: forall (i :: S) (l :: S) (n :: S). NameBinderList i l -> NameBinderList n i -> NameBinderList n l
instance Data.Bifoldable.Bifoldable (Data.SOAS.MetaAppSig metavar)
instance Data.Bifunctor.Bifunctor (Data.SOAS.MetaAppSig metavar)
instance Data.Bitraversable.Bitraversable (Data.SOAS.MetaAppSig metavar)
instance Data.Foldable.Foldable (Data.SOAS.MetaAppSig metavar scope)
instance GHC.Base.Functor (Data.SOAS.MetaAppSig metavar scope)
instance Generics.Kind.GenericK (Data.SOAS.MetaAppSig metavar scope)
instance Generics.Kind.GenericK (Data.SOAS.MetaAppSig metavar)
instance Generics.Kind.GenericK Data.SOAS.MetaAppSig
instance Generics.Kind.GenericK (Data.SOAS.MetaAppSig metavar scope term)
instance GHC.Generics.Generic (Data.SOAS.MetaAppSig metavar scope term)
instance Data.Traversable.Traversable (Data.SOAS.MetaAppSig metavar scope)
instance Data.ZipMatchK.Generic.ZipMatchK a => Data.ZipMatchK.Generic.ZipMatchK (Data.SOAS.MetaAppSig a)

module Language.Lambda.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
alex_action_2 :: Posn -> String -> Token
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t1 -> t2 -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, AlexInput)
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_VarIdent :: !String -> Tok
T_MetaVarIdent :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
instance GHC.Classes.Eq Language.Lambda.Syntax.Lex.Posn
instance GHC.Classes.Eq Language.Lambda.Syntax.Lex.Tok
instance GHC.Classes.Eq Language.Lambda.Syntax.Lex.TokSymbol
instance GHC.Classes.Eq Language.Lambda.Syntax.Lex.Token
instance GHC.Classes.Ord Language.Lambda.Syntax.Lex.Posn
instance GHC.Classes.Ord Language.Lambda.Syntax.Lex.Tok
instance GHC.Classes.Ord Language.Lambda.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.Lambda.Syntax.Lex.Token
instance GHC.Show.Show Language.Lambda.Syntax.Lex.BTree
instance GHC.Show.Show Language.Lambda.Syntax.Lex.Posn
instance GHC.Show.Show Language.Lambda.Syntax.Lex.Tok
instance GHC.Show.Show Language.Lambda.Syntax.Lex.TokSymbol
instance GHC.Show.Show Language.Lambda.Syntax.Lex.Token

module Language.Lambda.Syntax.Layout
data LayoutDelimiters
LayoutDelimiters :: TokSymbol -> Maybe TokSymbol -> Maybe TokSymbol -> LayoutDelimiters
[delimSep] :: LayoutDelimiters -> TokSymbol

-- | Nothing for toplevel layout.
[delimOpen] :: LayoutDelimiters -> Maybe TokSymbol

-- | Nothing for toplevel layout.
[delimClose] :: LayoutDelimiters -> Maybe TokSymbol
layoutWords :: [(TokSymbol, LayoutDelimiters)]
layoutStopWords :: [TokSymbol]
layoutOpen :: [TokSymbol]
layoutClose :: [TokSymbol]
layoutSep :: [TokSymbol]
parenOpen :: [TokSymbol]
parenClose :: [TokSymbol]

-- | Report an error during layout resolution.
layoutError :: [Token] -> String -> a

-- | Replace layout syntax with explicit layout tokens.
resolveLayout :: Bool -> [Token] -> [Token]
type Position = Posn
type Line = Int
type Column = Int

-- | Entry of the layout stack.
data Block

-- | An implicit layout block with its start column.
Implicit :: LayoutDelimiters -> Status -> Column -> Block
Explicit :: Block

-- | Get current indentation. 0 if we are in an explicit block.
indentation :: Block -> Column

-- | Check if s block is implicit.
isImplicit :: Block -> Bool
data Status

-- | A layout column that has not been confirmed by a line break
Tentative :: Status

-- | A layout column that has been confirmed by a line break.
Definitive :: Status

-- | Add a new implicit layout block.
addImplicit :: LayoutDelimiters -> Position -> Position -> [Block] -> [Block]

-- | Confirm tentative blocks that are not more indented than <tt>col</tt>.
confirm :: Column -> [Block] -> [Block]

-- | Get the position immediately to the right of the given token. If no
--   token is given, gets the first position in the file.
afterPrev :: Maybe Token -> Position

-- | Get the position immediately to the right of the given token.
nextPos :: Token -> Position

-- | Get the number of characters in the token.
tokenLength :: Token -> Int

-- | Create a position symbol token.
sToken :: Position -> TokSymbol -> Token

-- | Get the line number of a token.
line :: Token -> Line

-- | Get the column number of a token.
column :: Token -> Column

-- | Is the following token on a new line?
newLine :: Maybe Token -> Token -> Bool

-- | Check if a word is a layout start token.
isLayout :: Token -> Maybe LayoutDelimiters

-- | Check if a token is one of the given symbols.
isTokenIn :: [TokSymbol] -> Token -> Bool

-- | Check if a token is a layout stop token.
isStop :: Token -> Bool

-- | Check if a token is the layout open token.
isLayoutOpen :: Token -> Bool

-- | Check if a token is the layout separator token.
isLayoutSep :: Token -> Bool

-- | Check if a token is the layout close token.
isLayoutClose :: Token -> Bool

-- | Check if a token is an opening parenthesis.
isParenOpen :: Token -> Bool

-- | Check if a token is a closing parenthesis.
isParenClose :: Token -> Bool

module Language.Lambda.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pProgram :: [Token] -> Err Program
pCommand :: [Token] -> Err Command
pListCommand :: [Token] -> Err [Command]
pTerm :: [Token] -> Err Term
pTerm1 :: [Token] -> Err Term
pTerm2 :: [Token] -> Err Term
pListTerm :: [Token] -> Err [Term]
pScopedTerm :: [Token] -> Err ScopedTerm
pPattern :: [Token] -> Err Pattern
pBinder :: [Token] -> Err Binder
pListBinder :: [Token] -> Err [Binder]
pMetaSubst :: [Token] -> Err MetaSubst
pUnificationConstraint :: [Token] -> Err UnificationConstraint
pListVarIdent :: [Token] -> Err [VarIdent]
pType :: [Token] -> Err Type
pType1 :: [Token] -> Err Type


-- | Pretty-printer for Language.
module Language.Lambda.Syntax.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.Binder
instance Language.Lambda.Syntax.Print.Print GHC.Types.Char
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.Command
instance Language.Lambda.Syntax.Print.Print GHC.Types.Double
instance Language.Lambda.Syntax.Print.Print GHC.Num.Integer.Integer
instance Language.Lambda.Syntax.Print.Print a => Language.Lambda.Syntax.Print.Print [a]
instance Language.Lambda.Syntax.Print.Print GHC.Base.String
instance Language.Lambda.Syntax.Print.Print [Language.Lambda.Syntax.Abs.Command]
instance Language.Lambda.Syntax.Print.Print [Language.Lambda.Syntax.Abs.Term]
instance Language.Lambda.Syntax.Print.Print [Language.Lambda.Syntax.Abs.Binder]
instance Language.Lambda.Syntax.Print.Print [Language.Lambda.Syntax.Abs.VarIdent]
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.MetaSubst
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.MetaVarIdent
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.Pattern
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.Program
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.ScopedTerm
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.Term
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.Type
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.UnificationConstraint
instance Language.Lambda.Syntax.Print.Print Language.Lambda.Syntax.Abs.VarIdent


-- | Free foil implementation of the (lambda)-calculus (with pairs).
--   
--   Free foil provides <b>general</b> definitions or implementations for
--   the following:
--   
--   <ol>
--   <li>Freely generated (from a simple signature) scope-safe AST.</li>
--   <li>Correct capture-avoiding substitution (see
--   <a>substitute</a>).</li>
--   <li>Correct α-equivalence checks (see <a>alphaEquiv</a> and
--   <a>alphaEquivRefreshed</a>) as well as α-normalization (see
--   <a>refreshAST</a>).</li>
--   <li>Conversion helpers (see <a>convertToAST</a> and
--   <a>convertFromAST</a>).</li>
--   </ol>
--   
--   The following is <b>generated</b> using Template Haskell:
--   
--   <ol>
--   <li>Convenient pattern synonyms.</li>
--   <li><tt>ZipMatch</tt> instances (enabling general α-equivalence).</li>
--   <li>Conversion between scope-safe and raw term representation.</li>
--   </ol>
--   
--   The following is implemented <b>manually</b> in this module:
--   
--   <ol>
--   <li>Computation of weak head normal form (WHNF), see <a>whnf</a>.</li>
--   <li>Entry point, gluing everything together. See
--   <tt>defaultMain</tt>.</li>
--   </ol>
--   
--   <b>Note:</b> free foil does not (easily) support patterns at the
--   moment, so only wildcard patterns and variable patterns are handled in
--   this implementation.
module Language.Lambda.Impl

-- | <i>Generated</i> with <a>mkSignature</a>. A signature bifunctor,
--   specifying the nodes of a syntax tree corresponding to <a>Term</a>.
data TermSig scope term

-- | Corresponds to <a>Lam</a>.
LamSig :: Type -> scope -> TermSig scope term

-- | Corresponds to <a>Let</a>.
LetSig :: term -> scope -> TermSig scope term

-- | Corresponds to <a>App</a>.
AppSig :: term -> term -> TermSig scope term

-- | Corresponds to <a>MetaVar</a>.
MetaVarSig :: MetaVarIdent -> [term] -> TermSig scope term

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>MetaVarSig</a>.
pattern MetaVar :: MetaVarIdent -> [AST binder TermSig n] -> AST binder TermSig n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>AppSig</a>.
pattern App :: AST binder TermSig n -> AST binder TermSig n -> AST binder TermSig n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>LetSig</a>.
pattern Let :: () => AST binder TermSig n -> binder n l1 -> AST binder TermSig l1 -> AST binder TermSig n

-- | <i>Generated</i> with <a>mkPatternSynonyms</a>. Pattern synonym for an
--   <a>AST</a> node of type <a>LamSig</a>.
pattern Lam :: () => Type -> binder n l1 -> AST binder TermSig l1 -> AST binder TermSig n

-- | <i>Generated</i> with <a>mkConvertToSig</a>. Perform one step of
--   converting <a>Term</a>, peeling off one node of type <a>TermSig</a>.
convertToTermSig :: Term -> Either VarIdent (TermSig (Pattern, ScopedTerm) Term)

-- | <i>Generated</i> with <a>mkGetPatternBinder</a>. Extract at most one
--   binder from a pattern or <b>crash</b>.
getPatternBinder :: Pattern -> Maybe VarIdent

-- | <i>Generated</i> with <a>mkGetScopedTerm</a>. Extract scoped term or
--   <b>crash</b>.
getTermFromScopedTerm :: ScopedTerm -> Term

-- | <i>Generated</i> with <a>mkConvertFromSig</a>. Perform one step of
--   converting <a>Term</a>, peeling off one node of type <a>TermSig</a>.
convertFromTermSig :: TermSig (Pattern, ScopedTerm) Term -> Term

-- | <i>Generated</i> with <a>mkFoilPattern</a>. A scope-safe version of
--   <a>Pattern</a>.
data FoilPattern (n :: S) (l :: S)

-- | Corresponds to <a>APattern</a>.
[FoilAPattern] :: forall (n :: S) (l :: S). NameBinder n l -> FoilPattern n l

-- | <i>Generated</i> with <a>mkToFoilPattern</a>. Convert a raw pattern
--   into a scope-safe pattern.
toFoilPattern :: forall (n :: S) r. Distinct n => Scope n -> Map VarIdent (Name n) -> Pattern -> (forall (l :: S). DExt n l => FoilPattern n l -> Map VarIdent (Name l) -> r) -> r

-- | <i>Generated</i> with <a>mkFromFoilPattern</a>. Convert a scope-safe
--   pattern into a raw pattern.
fromFoilPattern :: forall (n :: S) (l :: S). (Int -> VarIdent) -> FoilPattern n l -> Pattern
pattern App' :: forall binder (q :: Type -> Type -> Type) n. AST binder (Sum TermSig q) n -> AST binder (Sum TermSig q) n -> AST binder (Sum TermSig q) n
pattern Lam' :: forall binder n (q :: Type -> Type -> Type) l. () => Type -> binder n l -> AST binder (Sum TermSig q) l -> AST binder (Sum TermSig q) n
pattern Let' :: forall binder (q :: Type -> Type -> Type) n l. () => AST binder (Sum TermSig q) n -> binder n l -> AST binder (Sum TermSig q) l -> AST binder (Sum TermSig q) n
pattern MetaVar' :: forall binder (q :: Type -> Type -> Type) n. MetaVarIdent -> [AST binder (Sum TermSig q) n] -> AST binder (Sum TermSig q) n
type AST' = AST FoilPattern

-- | Scope-safe λ-term representation in scope <tt>n</tt>.
type Term = AST' TermSig
type MetaTerm metavar (n :: S) = SOAS FoilPattern metavar TermSig n
nfMetaTerm :: forall (n :: S) metavar. Distinct n => Scope n -> MetaTerm metavar n -> MetaTerm metavar n
nfMetaTermWithEmptyScope :: SOAS FoilPattern metavar TermSig 'VoidS -> SOAS FoilPattern metavar TermSig 'VoidS
nameMapToSubsts :: forall (i :: S) e (o :: S). NameMap i (e o) -> Substitution e i o
toMetaSubst :: MetaSubst -> MetaSubst'
withMetaSubstVars :: forall (n :: S) (i :: S) r. Distinct n => [Binder] -> Scope n -> Map VarIdent (Name n) -> NameBinderList i n -> NameMap n Type -> (forall (l :: S). Distinct l => Scope l -> Map VarIdent (Name l) -> NameBinderList i l -> NameMap l Type -> r) -> r
type MetaSubst' = MetaSubst FoilPattern TermSig MetaVarIdent MetaAppSig MetaVarIdent Type
type MetaSubsts' = MetaSubsts FoilPattern TermSig MetaVarIdent MetaAppSig MetaVarIdent Type
fromMetaSubst :: MetaSubst' -> MetaSubst
toBinders :: forall (i :: S) (n :: S). Distinct i => NameBinderList i n -> NameMap n Type -> [Binder]
data UnificationConstraint
[UnificationConstraint] :: forall (n :: S). Distinct n => Scope n -> NameBinderList 'VoidS n -> NameMap n Type -> MetaTerm MetaVarIdent n -> MetaTerm MetaVarIdent n -> UnificationConstraint
toUnificationConstraint :: UnificationConstraint -> UnificationConstraint
fromUnificationConstraint :: UnificationConstraint -> UnificationConstraint
toMetaTerm :: forall (n :: S). Term n -> MetaTerm MetaVarIdent n
fromMetaTerm :: forall (n :: S). MetaTerm MetaVarIdent n -> Term n

-- | Convert <a>Term'</a> into a scope-safe term. This is a special case of
--   <a>convertToAST</a>.
toTerm :: forall (n :: S). Distinct n => Scope n -> Map VarIdent (Name n) -> Term -> Term n

-- | Convert <a>Term'</a> into a closed scope-safe term. This is a special
--   case of <tt>toTerm'</tt>.
toTermClosed :: Term -> Term 'VoidS
fromTerm :: forall (n :: S). Term n -> Term
lam :: forall (n :: S). Distinct n => Type -> Scope n -> (forall (l :: S). DExt n l => Name l -> Term l) -> Term n
lam' :: forall (n :: S) metavar. Distinct n => Type -> Scope n -> (forall (l :: S). DExt n l => Name l -> MetaTerm metavar l) -> MetaTerm metavar n
unsafeParseTerm :: String -> Term 'VoidS
parseMetaSubst :: String -> Either String MetaSubst'
unsafeParseMetaSubst :: String -> MetaSubst'
unsafeParseUnificationConstraint :: String -> UnificationConstraint

-- | Match a pattern against an term.
matchPattern :: forall t (n :: S) (l :: S). InjectName t => FoilPattern n l -> t n -> Substitution t l n
whnf :: forall (n :: S). Distinct n => Scope n -> Term n -> Term n
nf :: forall (n :: S). Distinct n => Scope n -> Term n -> Term n
interpretCommand :: Command -> IO ()
interpretProgram :: Program -> IO ()
solveUnificationConstraint :: MetaSubsts FoilPattern TermSig MetaVarIdent (MetaAppSig MetaVarIdent) Type -> UnificationConstraint -> UnificationConstraint
isSolved :: UnificationConstraint -> Bool
data Config
Config :: Text -> Text -> [Problem] -> Config
[configLanguage] :: Config -> Text
[configFragment] :: Config -> Text
[configProblems] :: Config -> [Problem]
data Problem
Problem :: [UnificationConstraint] -> [Solution] -> Problem
[problemConstraints] :: Problem -> [UnificationConstraint]
[problemSolutions] :: Problem -> [Solution]
data Solution
Solution :: Text -> [MetaSubst'] -> Solution
[solutionName] :: Solution -> Text
[solutionSubstitutions] :: Solution -> [MetaSubst']
configCodec :: TomlCodec Config
problemCodec :: TomlCodec Problem
parseTextToEither :: (String -> Either String a) -> Text -> Either Text a
solutionCodec :: TomlCodec Solution
toCodec :: Show a => (String -> Either String a) -> Key -> TomlCodec a
validateProblem :: Problem -> ([(Solution, [UnificationConstraint])], [Solution])
validateSolution :: [UnificationConstraint] -> Solution -> Either (Solution, [UnificationConstraint]) Solution
printInvalidSolutionsWithConstraint :: (Foldable t, Show a) => (Solution, t a) -> IO ()
parseConfigAndValidate :: IO ()
main :: IO ()
instance Data.Bifoldable.Bifoldable Language.Lambda.Impl.TermSig
instance Data.Bifunctor.Bifunctor Language.Lambda.Impl.TermSig
instance Data.Bitraversable.Bitraversable Language.Lambda.Impl.TermSig
instance Control.Monad.Foil.Internal.CoSinkable Language.Lambda.Impl.FoilPattern
instance Data.Foldable.Foldable (Language.Lambda.Impl.TermSig scope)
instance GHC.Base.Functor (Language.Lambda.Impl.TermSig scope)
instance Generics.Kind.GenericK (Language.Lambda.Impl.FoilPattern n)
instance Generics.Kind.GenericK Language.Lambda.Impl.FoilPattern
instance Generics.Kind.GenericK (Language.Lambda.Impl.TermSig scope)
instance Generics.Kind.GenericK Language.Lambda.Impl.TermSig
instance Generics.Kind.GenericK (Language.Lambda.Impl.FoilPattern n l)
instance Generics.Kind.GenericK (Language.Lambda.Impl.TermSig scope term)
instance GHC.Generics.Generic Language.Lambda.Impl.Config
instance GHC.Generics.Generic Language.Lambda.Impl.Problem
instance GHC.Generics.Generic Language.Lambda.Impl.Solution
instance GHC.Generics.Generic (Language.Lambda.Impl.TermSig scope term)
instance Data.String.IsString (Language.Lambda.Impl.MetaTerm Language.Lambda.Syntax.Abs.MetaVarIdent 'Control.Monad.Foil.Internal.VoidS)
instance Data.String.IsString (Language.Lambda.Impl.Term 'Control.Monad.Foil.Internal.VoidS)
instance Data.String.IsString Language.Lambda.Impl.MetaSubst'
instance Data.String.IsString Language.Lambda.Impl.UnificationConstraint
instance GHC.Show.Show (Language.Lambda.Impl.MetaTerm Language.Lambda.Syntax.Abs.MetaVarIdent n)
instance GHC.Show.Show (Language.Lambda.Impl.Term n)
instance GHC.Show.Show Language.Lambda.Impl.Config
instance GHC.Show.Show Language.Lambda.Impl.MetaSubst'
instance GHC.Show.Show Language.Lambda.Impl.MetaSubsts'
instance GHC.Show.Show Language.Lambda.Impl.Problem
instance GHC.Show.Show Language.Lambda.Impl.Solution
instance GHC.Show.Show Language.Lambda.Impl.UnificationConstraint
instance Control.Monad.Foil.Internal.SinkableK Language.Lambda.Impl.FoilPattern
instance Data.Traversable.Traversable (Language.Lambda.Impl.TermSig scope)
instance Control.Monad.Foil.Internal.UnifiablePattern Language.Lambda.Impl.FoilPattern
instance Data.ZipMatchK.Generic.ZipMatchK Language.Lambda.Impl.TermSig
instance Data.ZipMatchK.Generic.ZipMatchK Language.Lambda.Syntax.Abs.MetaVarIdent
instance Data.ZipMatchK.Generic.ZipMatchK Language.Lambda.Syntax.Abs.Type
instance Data.ZipMatchK.Generic.ZipMatchK Language.Lambda.Syntax.Abs.VarIdent

module Language.Lambda.Typed
data Type
Base :: String -> Type
Function :: Type -> Type -> Type
newtype Variable
Variable :: String -> Variable
newtype Metavariable
Metavariable :: String -> Metavariable
data Atom
AVar :: Variable -> Atom
AMetavar :: Metavariable -> Atom
data Expression
Atom :: Atom -> Expression
Application :: Expression -> Expression -> Expression
Lambda :: Variable -> Type -> Expression -> Expression
pattern Var :: Variable -> Expression
pattern Metavar :: Metavariable -> Expression
typeOf :: (Atom -> Maybe Type) -> Expression -> Maybe Type
data Heading head
Heading :: [(Variable, Type)] -> head -> Heading head
[binder] :: Heading head -> [(Variable, Type)]
[head] :: Heading head -> head
data NormalTerm' head
NormalTerm :: Heading head -> [NormalTerm] -> Type -> NormalTerm' head
[heading] :: NormalTerm' head -> Heading head
[arguments] :: NormalTerm' head -> [NormalTerm]
[returnType] :: NormalTerm' head -> Type
type NormalTerm = NormalTerm' Atom
type RigidTerm = NormalTerm' Variable
type FlexibleTerm = NormalTerm' Metavariable
asNormalTerm :: (Atom -> Maybe Type) -> Expression -> Maybe NormalTerm
newtype DisagreementSet
DisagreementSet :: [(NormalTerm, NormalTerm)] -> DisagreementSet
data Stream a
Stream :: a -> Stream a -> Stream a
someVariables :: Stream Variable
someMetavariables :: Stream Metavariable
solve :: DisagreementSet -> Stream Variable -> Stream Metavariable -> [(Substitutions, DisagreementSet)]
instance GHC.Classes.Eq Language.Lambda.Typed.Atom
instance GHC.Classes.Eq Language.Lambda.Typed.DisagreementSet
instance GHC.Classes.Eq Language.Lambda.Typed.Expression
instance GHC.Classes.Eq head => GHC.Classes.Eq (Language.Lambda.Typed.Heading head)
instance GHC.Classes.Eq Language.Lambda.Typed.Metavariable
instance GHC.Classes.Eq head => GHC.Classes.Eq (Language.Lambda.Typed.NormalTerm' head)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Lambda.Typed.Stream a)
instance GHC.Classes.Eq Language.Lambda.Typed.Substitutions
instance GHC.Classes.Eq Language.Lambda.Typed.Type
instance GHC.Classes.Eq Language.Lambda.Typed.Variable
instance GHC.Base.Functor Language.Lambda.Typed.Stream
instance GHC.Show.Show Language.Lambda.Typed.Atom
instance GHC.Show.Show Language.Lambda.Typed.DisagreementSet
instance GHC.Show.Show Language.Lambda.Typed.Expression
instance GHC.Show.Show head => GHC.Show.Show (Language.Lambda.Typed.Heading head)
instance GHC.Show.Show Language.Lambda.Typed.Metavariable
instance GHC.Show.Show head => GHC.Show.Show (Language.Lambda.Typed.NormalTerm' head)
instance GHC.Show.Show a => GHC.Show.Show (Language.Lambda.Typed.Stream a)
instance GHC.Show.Show Language.Lambda.Typed.Substitutions
instance GHC.Show.Show Language.Lambda.Typed.Type
instance GHC.Show.Show Language.Lambda.Typed.Variable
