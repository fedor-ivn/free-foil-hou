-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bidirectional TOML serialization
--   
--   Implementation of bidirectional TOML serialization. Simple codecs look
--   like this:
--   
--   <pre>
--   <b>data</b> User = User
--       { userName :: Text
--       , userAge  :: Int
--       }
--   
--   userCodec :: TomlCodec User
--   userCodec = User
--       &lt;$&gt; Toml.text "name" .= userName
--       &lt;*&gt; Toml.int  "age"  .= userAge
--   </pre>
--   
--   The following blog post has more details about library design:
--   
--   <ul>
--   <li><a>tomland: Bidirectional TOML serialization</a></li>
--   </ul>
@package tomland
@version 1.3.3.3


-- | Core functions for TOML parser.
module Toml.Parser.Core

-- | The parser <tt><a>try</a> p</tt> behaves like the parser <tt>p</tt>,
--   except that it backtracks the parser state when <tt>p</tt> fails
--   (either consuming input or not).
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   if the first parser failed while consuming input.
--   
--   For example, here is a parser that is supposed to parse the word “let”
--   or the word “lexical”:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string "let" &lt;|&gt; string "lexical") "lexical"
--   1:1:
--   unexpected "lex"
--   expecting "let"
--   </pre>
--   
--   What happens here? The first parser consumes “le” and fails (because
--   it doesn't see a “t”). The second parser, however, isn't tried, since
--   the first parser has already consumed some input! <a>try</a> fixes
--   this behavior and allows backtracking to work:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "lexical"
--   "lexical"
--   </pre>
--   
--   <a>try</a> also improves error messages in case of overlapping
--   alternatives, because Megaparsec's hint system can be used:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "le"
--   1:1:
--   unexpected "le"
--   expecting "let" or "lexical"
--   </pre>
--   
--   <b>Note</b> that as of Megaparsec 4.4.0, <a>string</a> backtracks
--   automatically (see <a>tokens</a>), so it does not need <a>try</a>.
--   However, the examples above demonstrate the idea behind <a>try</a> so
--   well that it was decided to keep them. You still need to use
--   <a>try</a> when your alternatives are complex, composite parsers.
try :: MonadParsec e s m => m a -> m a

-- | This parser only succeeds at the end of input.
eof :: MonadParsec e s m => m ()

-- | The parser <tt><a>satisfy</a> f</tt> succeeds for any token for which
--   the supplied function <tt>f</tt> returns <a>True</a>.
--   
--   <pre>
--   digitChar = satisfy isDigit &lt;?&gt; "digit"
--   oneOf cs  = satisfy (`elem` cs)
--   </pre>
--   
--   <b>Performance note</b>: when you need to parse a single token, it is
--   often a good idea to use <a>satisfy</a> with the right predicate
--   function instead of creating a complex parser using the combinators.
--   
--   See also: <a>anySingle</a>, <a>anySingleBut</a>, <a>oneOf</a>,
--   <a>noneOf</a>.
satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)

-- | Return both the result of a parse and a chunk of input that was
--   consumed during parsing. This relies on the change of the
--   <a>stateOffset</a> value to evaluate how many tokens were consumed. If
--   you mess with it manually in the argument parser, prepare for
--   troubles.
match :: MonadParsec e s m => m a -> m (Tokens s, a)

-- | Pretty-print a <a>ParseErrorBundle</a>. All <a>ParseError</a>s in the
--   bundle will be pretty-printed in order together with the corresponding
--   offending lines by doing a single pass over the input stream. The
--   rendered <a>String</a> always ends with a newline.
errorBundlePretty :: (VisualStream s, TraversableStream s, ShowErrorComponent e) => ParseErrorBundle s e -> String

-- | <a>Parsec</a> is a non-transformer variant of the more general
--   <a>ParsecT</a> monad transformer.
type Parsec e s = ParsecT e s Identity

-- | <tt><a>parse</a> p file input</tt> runs parser <tt>p</tt> over
--   <a>Identity</a> (see <a>runParserT</a> if you're using the
--   <a>ParsecT</a> monad transformer; <a>parse</a> itself is just a
--   synonym for <a>runParser</a>). It returns either a
--   <a>ParseErrorBundle</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>). <a>errorBundlePretty</a> can be used to turn
--   <a>ParseErrorBundle</a> into the string representation of the error
--   message. See <a>Text.Megaparsec.Error</a> if you need to do more
--   advanced error analysis.
--   
--   <pre>
--   main = case parse numbers "" "11,2,43" of
--            Left bundle -&gt; putStr (errorBundlePretty bundle)
--            Right xs -&gt; print (sum xs)
--   
--   numbers = decimal `sepBy` char ','
--   </pre>
--   
--   <a>parse</a> is the same as <a>runParser</a>.
parse :: Parsec e s a -> String -> s -> Either (ParseErrorBundle s e) a

-- | Parse and return a single token. It's a good idea to attach a
--   <a>label</a> to this parser.
--   
--   <pre>
--   anySingle = satisfy (const True)
--   </pre>
--   
--   See also: <a>satisfy</a>, <a>anySingleBut</a>.
anySingle :: MonadParsec e s m => m (Token s)

-- | A synonym for <a>label</a> in the form of an operator.
(<?>) :: MonadParsec e s m => m a -> String -> m a
infix 0 <?>

-- | A type-constrained version of <a>single</a>.
--   
--   <pre>
--   semicolon = char ';'
--   </pre>
char :: (MonadParsec e s m, Token s ~ Char) => Token s -> m (Token s)

-- | A synonym for <a>chunk</a>.
string :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | Skip <i>one</i> or more white space characters.
--   
--   See also: <a>skipSome</a> and <a>spaceChar</a>.
space1 :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Skip <i>zero</i> or more white space characters.
--   
--   See also: <a>skipMany</a> and <a>spaceChar</a>.
space :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Parse a CRLF (see <a>crlf</a>) or LF (see <a>newline</a>) end of line.
--   Return the sequence of characters parsed.
eol :: (MonadParsec e s m, Token s ~ Char) => m (Tokens s)

-- | Parse a tab character.
tab :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an alphabetic or numeric digit Unicode characters.
--   
--   Note that the numeric digits outside the ASCII range are parsed by
--   this parser but not by <a>digitChar</a>. Such digits may be part of
--   identifiers but are not used by the printer and reader to represent
--   numbers.
alphaNumChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an ASCII digit, i.e between “0” and “9”.
digitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a binary digit, i.e. "0" or "1".
binDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an octal digit, i.e. between “0” and “7”.
octDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a hexadecimal digit, i.e. between “0” and “9”, or “a” and “f”,
--   or “A” and “F”.
hexDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an integer in binary representation. The binary number is
--   expected to be a non-empty sequence of zeroes “0” and ones “1”.
--   
--   You could of course parse some prefix before the actual number:
--   
--   <pre>
--   binary = char '0' &gt;&gt; char' 'b' &gt;&gt; L.binary
--   </pre>
--   
--   <b>Warning</b>: this function does not perform range checks.
binary :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | This is a helper to parse symbols, i.e. verbatim strings. You pass the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and then you can use the resulting function to parse
--   strings:
--   
--   <pre>
--   symbol    = L.symbol spaceConsumer
--   
--   parens    = between (symbol "(") (symbol ")")
--   braces    = between (symbol "{") (symbol "}")
--   angles    = between (symbol "&lt;") (symbol "&gt;")
--   brackets  = between (symbol "[") (symbol "]")
--   semicolon = symbol ";"
--   comma     = symbol ","
--   colon     = symbol ":"
--   dot       = symbol "."
--   </pre>
symbol :: MonadParsec e s m => m () -> Tokens s -> m (Tokens s)

-- | Given a comment prefix this function returns a parser that skips line
--   comments. Note that it stops just before the newline character but
--   doesn't consume the newline. Newline is either supposed to be consumed
--   by <a>space</a> parser or picked up manually.
skipLineComment :: (MonadParsec e s m, Token s ~ Char) => Tokens s -> m ()

-- | Parse an integer in the octal representation. The format of the octal
--   number is expected to be according to the Haskell report except for
--   the fact that this parser doesn't parse “0o” or “0O” prefix. It is a
--   responsibility of the programmer to parse correct prefix before
--   parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   octal = char '0' &gt;&gt; char' 'o' &gt;&gt; L.octal
--   </pre>
--   
--   <b>Note</b>: before version <i>6.0.0</i> the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Warning</b>: this function does not perform range checks.
octal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in the hexadecimal representation. The format of the
--   hexadecimal number is expected to be according to the Haskell report
--   except for the fact that this parser doesn't parse “0x” or “0X”
--   prefix. It is a responsibility of the programmer to parse correct
--   prefix before parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   hexadecimal = char '0' &gt;&gt; char' 'x' &gt;&gt; L.hexadecimal
--   </pre>
--   
--   <b>Note</b>: before version <i>6.0.0</i> the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Warning</b>: this function does not perform range checks.
hexadecimal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse a floating point number according to the syntax for floating
--   point literals described in the Haskell report.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
--   
--   <b>Note</b>: before version <i>6.0.0</i> the function returned
--   <a>Double</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Note</b>: in versions <i>6.0.0</i>–<i>6.1.1</i> this function
--   accepted plain integers.
float :: (MonadParsec e s m, Token s ~ Char, RealFloat a) => m a

-- | <tt><a>signed</a> space p</tt> parses an optional sign character (“+”
--   or “-”), then if there is a sign it consumes optional white space
--   (using the <tt>space</tt> parser), then it runs the parser <tt>p</tt>
--   which should return a number. Sign of the number is changed according
--   to the previously parsed sign character.
--   
--   For example, to parse signed integer you can write:
--   
--   <pre>
--   lexeme        = L.lexeme spaceConsumer
--   integer       = lexeme L.decimal
--   signedInteger = L.signed spaceConsumer integer
--   </pre>
signed :: (MonadParsec e s m, Token s ~ Char, Num a) => m () -> m a -> m a

-- | The parser
type Parser = Parsec Void Text

-- | Wrapper for consuming spaces after every lexeme (not before it!).
--   Consumes all characters according to <a>sc</a> parser.
lexeme :: Parser a -> Parser a

-- | Space and comment consumer. Currently also consumes newlines.
sc :: Parser ()

-- | <a>Parser</a> for "fixed" string.
text :: Text -> Parser Text


-- | Parsers for strings in TOML format, including basic and literal
--   strings both singleline and multiline.
module Toml.Parser.String

-- | Parser for TOML text. Includes:
--   
--   <ol>
--   <li>Basic single-line string.</li>
--   <li>Literal single-line string.</li>
--   <li>Basic multiline string.</li>
--   <li>Literal multiline string.</li>
--   </ol>
textP :: Parser Text

-- | Parser for basic string in double quotes.
basicStringP :: Parser Text

-- | Parser for literal string in single quotes.
literalStringP :: Parser Text


-- | Implementation of key type. The type is used for key-value pairs and
--   table names.
module Toml.Type.Key

-- | Key of value in <tt>key = val</tt> pair. Represents as non-empty list
--   of key components — <a>Piece</a>s. Key like
--   
--   <pre>
--   site."google.com"
--   </pre>
--   
--   is represented like
--   
--   <pre>
--   Key (Piece "site" :| [Piece "\"google.com\""])
--   </pre>
newtype Key
Key :: NonEmpty Piece -> Key
[unKey] :: Key -> NonEmpty Piece

-- | Type synonym for <a>Key</a>.
type Prefix = Key

-- | Represents the key piece of some layer.
newtype Piece
Piece :: Text -> Piece
[unPiece] :: Piece -> Text

-- | Bidirectional pattern synonym for constructing and deconstructing
--   <a>Key</a>s.
pattern (:||) :: Piece -> [Piece] -> Key

-- | Prepends <a>Piece</a> to the beginning of the <a>Key</a>.
(<|) :: Piece -> Key -> Key

-- | Data represent difference between two keys.
data KeysDiff

-- | Keys are equal
Equal :: KeysDiff

-- | Keys don't have any common part.
NoPrefix :: KeysDiff

-- | The first key is the prefix of the second one.
FstIsPref :: !Key -> KeysDiff

-- | The second key is the prefix of the first one.
SndIsPref :: !Key -> KeysDiff

-- | Key have a common prefix.
Diff :: !Key -> !Key -> !Key -> KeysDiff

-- | Find key difference between two keys.
keysDiff :: Key -> Key -> KeysDiff
instance GHC.Classes.Eq Toml.Type.Key.Key
instance GHC.Classes.Eq Toml.Type.Key.KeysDiff
instance GHC.Classes.Eq Toml.Type.Key.Piece
instance GHC.Generics.Generic Toml.Type.Key.Key
instance GHC.Generics.Generic Toml.Type.Key.Piece
instance Data.Hashable.Class.Hashable Toml.Type.Key.Key
instance Data.Hashable.Class.Hashable Toml.Type.Key.Piece
instance Data.String.IsString Toml.Type.Key.Key
instance Data.String.IsString Toml.Type.Key.Piece
instance Control.DeepSeq.NFData Toml.Type.Key.Key
instance Control.DeepSeq.NFData Toml.Type.Key.Piece
instance GHC.Classes.Ord Toml.Type.Key.Key
instance GHC.Classes.Ord Toml.Type.Key.Piece
instance GHC.Base.Semigroup Toml.Type.Key.Key
instance GHC.Show.Show Toml.Type.Key.Key
instance GHC.Show.Show Toml.Type.Key.KeysDiff
instance GHC.Show.Show Toml.Type.Key.Piece


-- | Parsers for keys and table names.
module Toml.Parser.Key

-- | Parser for <a>Key</a>: dot-separated list of <a>Piece</a>.
keyP :: Parser Key

-- | Parser for table name: <a>Key</a> inside <tt>[]</tt>.
tableNameP :: Parser Key

-- | Parser for array of tables name: <a>Key</a> inside <tt>[[]]</tt>.
tableArrayNameP :: Parser Key


-- | Implementation of prefix tree for TOML AST.
module Toml.Type.PrefixTree

-- | Data structure to represent table tree for <tt>toml</tt>.
data PrefixTree a

-- | End of a key.
Leaf :: !Key -> !a -> PrefixTree a

-- | Values along pieces of a key.
Branch :: !Prefix -> !Maybe a -> !PrefixMap a -> PrefixTree a

-- | Creates a <a>PrefixTree</a> of one key-value element.
singleT :: Key -> a -> PrefixTree a

-- | Inserts key-value element into the given <a>PrefixTree</a>.
insertT :: Key -> a -> PrefixTree a -> PrefixTree a

-- | Looks up the value at a key in the <a>PrefixTree</a>.
lookupT :: Key -> PrefixTree a -> Maybe a

-- | Converts <a>PrefixTree</a> to the list of pairs.
toListT :: PrefixTree a -> [(Key, a)]

-- | Push <a>Prefix</a> inside the given <a>PrefixTree</a>.
addPrefixT :: Prefix -> PrefixTree a -> PrefixTree a

-- | Difference of two <a>PrefixTree</a>s. Returns elements of the first
--   <a>PrefixTree</a> that are not existing in the second one.
differenceWithT :: (a -> b -> Maybe a) -> PrefixTree a -> PrefixTree b -> Maybe (PrefixTree a)

-- | Map of layer names and corresponding <a>PrefixTree</a>s.
type PrefixMap a = HashMap Piece PrefixTree a

-- | Creates a <a>PrefixMap</a> of one key-value element.
single :: Key -> a -> PrefixMap a

-- | Inserts key-value element into the given <a>PrefixMap</a>.
insert :: Key -> a -> PrefixMap a -> PrefixMap a

-- | Looks up the value at a key in the <a>PrefixMap</a>.
lookup :: Key -> PrefixMap a -> Maybe a

-- | Constructs <a>PrefixMap</a> structure from the given list of
--   <a>Key</a> and value pairs.
fromList :: [(Key, a)] -> PrefixMap a

-- | Converts <a>PrefixMap</a> to the list of pairs.
toList :: PrefixMap a -> [(Key, a)]

-- | Difference of two <a>PrefixMap</a>s. Returns elements of the first
--   <a>PrefixMap</a> that are not existing in the second one.
differenceWith :: (a -> b -> Maybe a) -> PrefixMap a -> PrefixMap b -> PrefixMap a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Toml.Type.PrefixTree.PrefixTree a)
instance GHC.Generics.Generic (Toml.Type.PrefixTree.PrefixTree a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Toml.Type.PrefixTree.PrefixTree a)
instance GHC.Base.Semigroup (Toml.Type.PrefixTree.PrefixTree a)
instance GHC.Show.Show a => GHC.Show.Show (Toml.Type.PrefixTree.PrefixTree a)


-- | GADT value for TOML.
module Toml.Type.Value

-- | Needed for GADT parameterization
data TValue
TBool :: TValue
TInteger :: TValue
TDouble :: TValue
TText :: TValue
TZoned :: TValue
TLocal :: TValue
TDay :: TValue
THours :: TValue
TArray :: TValue

-- | Convert <a>TValue</a> constructors to <a>String</a> without <tt>T</tt>
--   prefix.
showType :: TValue -> String

-- | Value in <tt>key = value</tt> pair.
data Value (t :: TValue)

-- | Boolean value:
--   
--   <pre>
--   bool1 = true
--   bool2 = false
--   </pre>
[Bool] :: Bool -> Value 'TBool

-- | Integer value:
--   
--   <pre>
--   int1 = +99
--   int2 = 42
--   int3 = 0
--   int4 = -17
--   int5 = 5_349_221
--   hex1 = 0xDEADBEEF  # hexadecimal
--   oct2 = 0o755  # octal, useful for Unix file permissions
--   bin1 = 0b11010110  # binary
--   </pre>
[Integer] :: Integer -> Value 'TInteger

-- | Floating point number:
--   
--   <pre>
--   # fractional
--   flt1 = +1.0
--   flt2 = 3.1415
--   flt3 = -0.01
--   
--   # exponent
--   flt4 = 5e+22
--   flt5 = 1e6
--   flt6 = -2E-2
--   
--   # both
--   flt7 = 6.626e-34
--   
--   # infinity
--   sf1 = inf  # positive infinity
--   sf2 = +inf # positive infinity
--   sf3 = -inf # negative infinity
--   
--   # not a number
--   sf4 = nan  # actual sNaN/qNaN encoding is implementation specific
--   sf5 = +nan # same as `nan`
--   sf6 = -nan # same as `nan`
--   </pre>
[Double] :: Double -> Value 'TDouble

-- | String value:
--   
--   <pre>
--   # basic string
--   name = "Orange"
--   physical.color = "orange"
--   physical.shape = "round"
--   
--   # multiline basic string
--   str1 = """
--   Roses are red
--   Violets are blue"""
--   
--   # literal string: What you see is what you get.
--   winpath  = 'C:Usersnodejstemplates'
--   winpath2 = '\ServerXadmin$system32'
--   quoted   = 'Tom "Dubs" Preston-Werner'
--   regex    = '<a>ic*s*</a>'
--   </pre>
[Text] :: Text -> Value 'TText

-- | Offset date-time:
--   
--   <pre>
--   odt1 = 1979-05-27T07:32:00Z
--   odt2 = 1979-05-27T00:32:00-07:00
--   odt3 = 1979-05-27T00:32:00.999999-07:00
--   </pre>
[Zoned] :: ZonedTime -> Value 'TZoned

-- | Local date-time (without offset):
--   
--   <pre>
--   ldt1 = 1979-05-27T07:32:00
--   ldt2 = 1979-05-27T00:32:00.999999
--   </pre>
[Local] :: LocalTime -> Value 'TLocal

-- | Local date (only day):
--   
--   <pre>
--   ld1 = 1979-05-27
--   </pre>
[Day] :: Day -> Value 'TDay

-- | Local time (time of the day):
--   
--   <pre>
--   lt1 = 07:32:00
--   lt2 = 00:32:00.999999
--   </pre>
[Hours] :: TimeOfDay -> Value 'THours

-- | Array of values. According to TOML specification all values in array
--   should have the same type. This is guaranteed statically with this
--   type.
--   
--   <pre>
--   arr1 = [ 1, 2, 3 ]
--   arr2 = [ "red", "yellow", "green" ]
--   arr3 = [ [ 1, 2 ], [3, 4, 5] ]
--   arr4 = [ "all", 'strings', """are the same""", '''type''']
--   arr5 = [ [ 1, 2 ], ["a", "b", "c"] ]
--   
--   arr6 = [ 1, 2.0 ] # INVALID
--   </pre>
[Array] :: forall (t1 :: TValue). [Value t1] -> Value 'TArray

-- | Compare list of <a>Value</a> of possibly different types.
eqValueList :: forall (a :: TValue) (b :: TValue). [Value a] -> [Value b] -> Bool

-- | Reifies type of <a>Value</a> into <a>TValue</a>. Unfortunately,
--   there's no way to guarantee that <a>valueType</a> will return
--   <tt>t</tt> for object with type <tt>Value 't</tt>.
valueType :: forall (t :: TValue). Value t -> TValue

-- | Data type that holds expected vs. actual type.
data TypeMismatchError
TypeMismatchError :: !TValue -> !TValue -> TypeMismatchError
[typeExpected] :: TypeMismatchError -> !TValue
[typeActual] :: TypeMismatchError -> !TValue

-- | Checks whether two values are the same. This function is used for type
--   checking where first argument is expected type and second argument is
--   actual type.
sameValue :: forall (a :: TValue) (b :: TValue). Value a -> Value b -> Either TypeMismatchError (a :~: b)
instance GHC.Classes.Eq Toml.Type.Value.TValue
instance GHC.Classes.Eq Toml.Type.Value.TypeMismatchError
instance GHC.Classes.Eq (Toml.Type.Value.Value t)
instance GHC.Generics.Generic Toml.Type.Value.TValue
instance (t GHC.Types.~ 'Toml.Type.Value.TText) => Data.String.IsString (Toml.Type.Value.Value t)
instance Control.DeepSeq.NFData Toml.Type.Value.TValue
instance Control.DeepSeq.NFData (Toml.Type.Value.Value t)
instance (t GHC.Types.~ 'Toml.Type.Value.TInteger) => GHC.Num.Num (Toml.Type.Value.Value t)
instance GHC.Read.Read Toml.Type.Value.TValue
instance GHC.Show.Show Toml.Type.Value.TValue
instance GHC.Show.Show Toml.Type.Value.TypeMismatchError
instance GHC.Show.Show (Toml.Type.Value.Value t)


-- | Existential wrapper over <a>Value</a> type and matching functions.
module Toml.Type.AnyValue

-- | Existential wrapper for <a>Value</a>.
data AnyValue
AnyValue :: Value t -> AnyValue

-- | Checks whether all elements inside given list of <a>AnyValue</a> have
--   the same type as given <a>Value</a>. Returns list of <tt>Value t</tt>
--   without given <a>Value</a>.
reifyAnyValues :: forall (t :: TValue). Value t -> [AnyValue] -> Either TypeMismatchError [Value t]

-- | Function for creating <a>Array</a> from list of <a>AnyValue</a>.
toMArray :: [AnyValue] -> Either MatchError (Value 'TArray)

-- | Value type mismatch error.
data MatchError
MatchError :: !TValue -> !AnyValue -> MatchError
[valueExpected] :: MatchError -> !TValue
[valueActual] :: MatchError -> !AnyValue

-- | Helper function to create <a>MatchError</a>.
mkMatchError :: forall (t :: TValue) a. TValue -> Value t -> Either MatchError a

-- | Extract <a>Bool</a> from <a>Value</a>.
matchBool :: forall (t :: TValue). Value t -> Either MatchError Bool

-- | Extract <a>Integer</a> from <a>Value</a>.
matchInteger :: forall (t :: TValue). Value t -> Either MatchError Integer

-- | Extract <a>Double</a> from <a>Value</a>.
matchDouble :: forall (t :: TValue). Value t -> Either MatchError Double

-- | Extract <a>Text</a> from <a>Value</a>.
matchText :: forall (t :: TValue). Value t -> Either MatchError Text

-- | Extract <a>ZonedTime</a> from <a>Value</a>.
matchZoned :: forall (t :: TValue). Value t -> Either MatchError ZonedTime

-- | Extract <a>LocalTime</a> from <a>Value</a>.
matchLocal :: forall (t :: TValue). Value t -> Either MatchError LocalTime

-- | Extract <a>Day</a> from <a>Value</a>.
matchDay :: forall (t :: TValue). Value t -> Either MatchError Day

-- | Extract <a>TimeOfDay</a> from <a>Value</a>.
matchHours :: forall (t :: TValue). Value t -> Either MatchError TimeOfDay

-- | Extract list of elements of type <tt>a</tt> from array.
matchArray :: forall a (t :: TValue). (AnyValue -> Either MatchError a) -> Value t -> Either MatchError [a]

-- | Make function that works with <a>AnyValue</a> also work with specific
--   <a>Value</a>.
applyAsToAny :: forall r (t :: TValue). (AnyValue -> r) -> Value t -> r
instance GHC.Classes.Eq Toml.Type.AnyValue.AnyValue
instance GHC.Classes.Eq Toml.Type.AnyValue.MatchError
instance GHC.Generics.Generic Toml.Type.AnyValue.MatchError
instance Control.DeepSeq.NFData Toml.Type.AnyValue.AnyValue
instance Control.DeepSeq.NFData Toml.Type.AnyValue.MatchError
instance GHC.Show.Show Toml.Type.AnyValue.AnyValue
instance GHC.Show.Show Toml.Type.AnyValue.MatchError


-- | Intermediate untype value representation used for parsing.
module Toml.Type.UValue

-- | Untyped value of <tt>TOML</tt>. You shouldn't use this type in your
--   code. Use <a>Value</a> instead.
data UValue
UBool :: !Bool -> UValue
UInteger :: !Integer -> UValue
UDouble :: !Double -> UValue
UText :: !Text -> UValue
UZoned :: !ZonedTime -> UValue
ULocal :: !LocalTime -> UValue
UDay :: !Day -> UValue
UHours :: !TimeOfDay -> UValue
UArray :: ![UValue] -> UValue

-- | Ensures that <a>UValue</a>s represents type-safe version of
--   <tt>toml</tt>.
typeCheck :: UValue -> Either TypeMismatchError AnyValue
instance GHC.Classes.Eq Toml.Type.UValue.UValue
instance GHC.Show.Show Toml.Type.UValue.UValue


-- | Type of TOML AST. This is intermediate representation of TOML parsed
--   from text.
module Toml.Type.TOML

-- | Represents TOML configuration value.
--   
--   For example, if we have the following <tt>TOML</tt> file:
--   
--   <pre>
--   server.port        = 8080
--   server.codes       = [ 5, 10, 42 ]
--   server.description = "This is production server."
--   
--   [mail]
--       host = "smtp.gmail.com"
--       send-if-inactive = false
--   
--   [[user]]
--       id = 42
--   
--   [[user]]
--       name = "Foo Bar"
--   </pre>
--   
--   corresponding <a>TOML</a> looks like:
--   
--   <pre>
--   TOML
--       { tomlPairs = fromList
--           [ ( "server" :| [ "port" ] , Integer 8080)
--           , ( "server" :| [ "codes" ] , Array [ Integer 5 , Integer 10 , Integer 42])
--           , ( "server" :| [ "description" ] , Text "This is production server.")
--           ]
--       , tomlTables = fromList
--           [ ( "mail"
--             , Leaf ( "mail" :| [] )
--                 ( TOML
--                     { tomlPairs = fromList
--                         [ ( "host" :| [] , Text "smtp.gmail.com")
--                         , ( "send-if-inactive" :| [] , Bool False)
--                         ]
--                     , tomlTables = fromList []
--                     , tomlTableArrays = fromList []
--                     }
--                 )
--             )
--           ]
--       , tomlTableArrays = fromList
--           [ ( "user" :| []
--             , TOML
--                 { tomlPairs = fromList [( "id" :| [] , Integer 42)]
--                 , tomlTables = fromList []
--                 , tomlTableArrays = fromList []
--                 } :|
--                 [ TOML
--                     { tomlPairs = fromList [( "name" :| [] , Text "Foo Bar")]
--                     , tomlTables = fromList []
--                     , tomlTableArrays = fromList []
--                     }
--                 ]
--             )
--           ]
--       }
--   </pre>
data TOML
TOML :: !HashMap Key AnyValue -> !PrefixMap TOML -> !HashMap Key (NonEmpty TOML) -> TOML
[tomlPairs] :: TOML -> !HashMap Key AnyValue
[tomlTables] :: TOML -> !PrefixMap TOML
[tomlTableArrays] :: TOML -> !HashMap Key (NonEmpty TOML)

-- | Inserts given key-value into the <a>TOML</a>.
insertKeyVal :: forall (a :: TValue). Key -> Value a -> TOML -> TOML

-- | Inserts given key-value into the <a>TOML</a>.
insertKeyAnyVal :: Key -> AnyValue -> TOML -> TOML

-- | Inserts given table into the <a>TOML</a>.
insertTable :: Key -> TOML -> TOML -> TOML

-- | Inserts given array of tables into the <a>TOML</a>.
insertTableArrays :: Key -> NonEmpty TOML -> TOML -> TOML

-- | Difference of two <a>TOML</a>s. Returns elements of the first
--   <a>TOML</a> that are not existing in the second one.
tomlDiff :: TOML -> TOML -> TOML
instance GHC.Classes.Eq Toml.Type.TOML.TOML
instance GHC.Generics.Generic Toml.Type.TOML.TOML
instance GHC.Base.Monoid Toml.Type.TOML.TOML
instance Control.DeepSeq.NFData Toml.Type.TOML.TOML
instance GHC.Base.Semigroup Toml.Type.TOML.TOML
instance GHC.Show.Show Toml.Type.TOML.TOML


-- | This module introduces EDSL for manually specifying <a>TOML</a> data
--   types.
--   
--   Consider the following raw TOML:
--   
--   <pre>
--   key1 = 1
--   key2 = true
--   
--   [meme-quotes]
--     quote1 = [ "Oh", "Hi", "Mark" ]
--   
--   [[arrayName]]
--     elem1 = "yes"
--   
--   [[arrayName]]
--     [arrayName.elem2]
--       deep = 7
--   
--   [[arrayName]]
--   </pre>
--   
--   using functions from this module you can specify the above TOML in
--   safer way:
--   
--   <pre>
--   exampleToml :: <a>TOML</a>
--   exampleToml = <a>mkToml</a> $ <b>do</b>
--       "key1" <a>=:</a> 1
--       "key2" <a>=:</a> Bool True
--       <a>table</a> "meme-quotes" $
--           "quote1" <a>=:</a> Array ["Oh", "Hi", "Mark"]
--       <a>tableArray</a> "arrayName" $
--           "elem1" <a>=:</a> "yes" :|
--           [ <a>table</a> "elem2" $ "deep" <a>=:</a> Integer 7
--           , <a>empty</a>
--           ]
--   </pre>
module Toml.Type.Edsl

-- | Monad for creating TOML.
type TDSL = State TOML ()

-- | Creates <a>TOML</a> from the <a>TDSL</a>.
mkToml :: TDSL -> TOML

-- | Creates an empty <a>TDSL</a>.
empty :: TDSL

-- | Adds key-value pair to the <a>TDSL</a>.
(=:) :: forall (a :: TValue). Key -> Value a -> TDSL

-- | Adds table to the <a>TDSL</a>.
table :: Key -> TDSL -> TDSL

-- | Adds array of tables to the <a>TDSL</a>.
tableArray :: Key -> NonEmpty TDSL -> TDSL


-- | Contains functions for pretty printing <tt>toml</tt> types.
module Toml.Type.Printer

-- | Configures the pretty printer.
data PrintOptions
PrintOptions :: !Maybe (Key -> Key -> Ordering) -> !Int -> !Lines -> PrintOptions

-- | How table keys should be sorted, if at all.
[printOptionsSorting] :: PrintOptions -> !Maybe (Key -> Key -> Ordering)

-- | Number of spaces by which to indent.
[printOptionsIndent] :: PrintOptions -> !Int

-- | How to print Array. OneLine:
--   
--   <pre>
--   foo = [a, b]
--   
--   </pre>
--   
--   MultiLine:
--   
--   <pre>
--   foo =
--       [ a
--       , b
--       ]
--   
--   </pre>
--   
--   Default is <a>OneLine</a>.
[printOptionsLines] :: PrintOptions -> !Lines
data Lines
OneLine :: Lines
MultiLine :: Lines

-- | Default printing options.
--   
--   <ol>
--   <li>Sorts all keys and tables by name.</li>
--   <li>Indents with 2 spaces.</li>
--   </ol>
defaultOptions :: PrintOptions

-- | Converts <a>TOML</a> type into <a>Text</a> (using
--   <a>defaultOptions</a>).
--   
--   For example, this
--   
--   <pre>
--   TOML
--       { tomlPairs  = HashMap.fromList
--             [("title", AnyValue $ Text "TOML example")]
--       , tomlTables = PrefixTree.fromList
--             [( "example" &lt;| "owner"
--              , mempty
--                    { tomlPairs  = HashMap.fromList
--                          [("name", AnyValue $ Text <a>Kowainik</a>)]
--                    }
--              )]
--       , tomlTableArrays = mempty
--       }
--   </pre>
--   
--   will be translated to this
--   
--   <pre>
--   title = "TOML Example"
--   
--   [example.owner]
--     name = "Kowainik"
--   </pre>
pretty :: TOML -> Text

-- | Converts <a>TOML</a> type into <a>Text</a> using provided
--   <a>PrintOptions</a>
prettyOptions :: PrintOptions -> TOML -> Text

-- | Converts a key to text
prettyKey :: Key -> Text


-- | Core types for TOML AST.
module Toml.Type


-- | Parser for <a>UValue</a>.
module Toml.Parser.Value

-- | Parser for array of values. This parser tries to parse first element
--   of array, pattern-matches on this element and uses parser according to
--   this first element. This allows to prevent parsing of heterogeneous
--   arrays.
arrayP :: Parser [UValue]

-- | Parser for <a>Bool</a> value.
boolP :: Parser Bool

-- | Parser for datetime values.
dateTimeP :: Parser UValue

-- | Parser for <a>Double</a> value.
doubleP :: Parser Double

-- | Parser for <a>Integer</a> value.
integerP :: Parser Integer

-- | Parser for <a>UValue</a>.
valueP :: Parser UValue

-- | Uses <a>valueP</a> and typechecks it.
anyValueP :: Parser AnyValue


-- | This module contains the definition of the <a>TomlItem</a> data type
--   which represents either key-value pair or table name. This data type
--   serves the purpose to be the intermediate representation of parsing a
--   TOML file which will be assembled to TOML AST later.
module Toml.Parser.Item

-- | One item of a TOML file. It could be either:
--   
--   <ul>
--   <li>A name of a table</li>
--   <li>A name of a table array</li>
--   <li>Key-value pair</li>
--   <li>Inline table</li>
--   <li>Inline array of tables</li>
--   </ul>
--   
--   Knowing a list of <a>TomlItem</a>s, it's possible to construct
--   <a>TOML</a> from this information.
data TomlItem
TableName :: !Key -> TomlItem
TableArrayName :: !Key -> TomlItem
KeyVal :: !Key -> !AnyValue -> TomlItem
InlineTable :: !Key -> !Table -> TomlItem
InlineTableArray :: !Key -> !NonEmpty Table -> TomlItem

-- | Table that contains only <tt>key = val</tt> pairs.
newtype Table
Table :: [(Key, AnyValue)] -> Table
[unTable] :: Table -> [(Key, AnyValue)]

-- | Changes name of table to a new one. Works only for <a>TableName</a>
--   and <a>TableArrayName</a> constructors.
setTableName :: Key -> TomlItem -> TomlItem

-- | Parser for the full content of the .toml file.
tomlP :: Parser [TomlItem]

-- | parser for <tt>"key = val"</tt> pairs; can be one of three forms:
--   
--   <ol>
--   <li>key = { ... }</li>
--   <li>key = [ {...}, {...}, ... ]</li>
--   <li>key = ...</li>
--   </ol>
keyValP :: Parser TomlItem
instance GHC.Classes.Eq Toml.Parser.Item.Table
instance GHC.Classes.Eq Toml.Parser.Item.TomlItem
instance GHC.Show.Show Toml.Parser.Item.Table
instance GHC.Show.Show Toml.Parser.Item.TomlItem


-- | This module contains functions that aggregate the result of
--   <a>tomlP</a> parser into <a>TOML</a>. This approach allows to keep
--   parser fast and simple and delegate the process of creating tree
--   structure to a separate function.
module Toml.Parser.Validate

-- | Validate list of <a>TomlItem</a>s and convert to <a>TOML</a> if not
--   validation errors are found.
validateItems :: [TomlItem] -> Either ValidationError TOML

-- | Error that happens during validating TOML which is already
--   syntactically correct. For the list of all possible validation errors
--   and their explanation, see the following issue on GitHub:
--   
--   <ul>
--   <li><a>https://github.com/kowainik/tomland/issues/5</a></li>
--   </ul>
data ValidationError
DuplicateKey :: !Key -> ValidationError
DuplicateTable :: !Key -> ValidationError
SameNameKeyTable :: !Key -> ValidationError
SameNameTableArray :: !Key -> ValidationError

-- | This function takes flat list of <a>TomlItem</a>s and groups it into
--   list of <a>Tree</a>s by putting all corresponding items inside tables
--   and table arrays. It doesn't perform any validation, just groups items
--   according to prefixes of their keys. So, for example, if you have the
--   following keys as flat list:
--   
--   <pre>
--   aaa              # ordinary key
--   aaa.bbb          # ordinary key
--   [foo]            # table nam
--   foo.bar
--   foo.baz
--   [xxx]            # table name
--   [xxx.yyy]        # table name
--   zzz
--   </pre>
--   
--   the following tree structure will be created:
--   
--   <pre>
--   aaa
--   aaa.bbb
--   [foo]
--   ├──── foo.bar
--   └──── foo.baz
--   [xxx]
--   └──── [yyy]
--         └──── zzz
--   </pre>
groupItems :: [TomlItem] -> Forest TomlItem

-- | This function groups list of TOML items into <a>Forest</a> and returns
--   list of items that are not children of specified parent.
--   
--   <b>Invariant:</b> When this function is called with <a>Nothing</a>,
--   second element in the result tuple should be empty list.
groupWithParent :: Maybe Key -> [TomlItem] -> (Forest TomlItem, [TomlItem])

-- | Construct <a>TOML</a> from the <a>Forest</a> of <a>TomlItem</a> and
--   performing validation of TOML at the same time.
validateItemForest :: Forest TomlItem -> Either ValidationError TOML
instance GHC.Classes.Eq Toml.Parser.Validate.ValidationError
instance GHC.Show.Show Toml.Parser.Validate.ValidationError


-- | Parser for text to TOML AST.
module Toml.Parser

-- | Pretty parse exception for parsing toml.
newtype TomlParseError
TomlParseError :: Text -> TomlParseError
[unTomlParseError] :: TomlParseError -> Text

-- | Parses <a>Text</a> as <a>TOML</a> AST object. If you want to convert
--   <a>Text</a> to your custom haskell data type, use <a>decode</a> or
--   <a>decodeFile</a> functions.
parse :: Text -> Either TomlParseError TOML

-- | Parse TOML <a>Key</a> from <a>Text</a>.
parseKey :: Text -> Either TomlParseError Key
instance GHC.Classes.Eq Toml.Parser.TomlParseError
instance GHC.Generics.Generic Toml.Parser.TomlParseError
instance Control.DeepSeq.NFData Toml.Parser.TomlParseError
instance GHC.Show.Show Toml.Parser.TomlParseError


-- | Implementation of <i>Tagged Partial Bidirectional Isomorphism</i>.
--   This module contains the <a>BiMap</a> type that represents conversion
--   between two types with the possibility of failure.
--   
--   See <a>Toml.Codec.BiMap.Conversion</a> for examples of <a>BiMap</a>
--   with specific types. The <a>BiMap</a> concept is general and is not
--   specific to TOML, but in this package most usages of <a>BiMap</a> are
--   between TOML values and Haskell values.
module Toml.Codec.BiMap

-- | Partial bidirectional isomorphism. <tt>BiMap a b</tt> contains two
--   function:
--   
--   <ol>
--   <li><pre>a -&gt; Either e b</pre></li>
--   <li><pre>b -&gt; Either e a</pre></li>
--   </ol>
--   
--   If you think of types as sets then this data type can be illustrated
--   by the following picture:
--   
--   
--   <a>BiMap</a> also implements <a>Category</a> typeclass. And this
--   instance can be described clearly by this illustration:
--   
data BiMap e a b
BiMap :: (a -> Either e b) -> (b -> Either e a) -> BiMap e a b
[forward] :: BiMap e a b -> a -> Either e b
[backward] :: BiMap e a b -> b -> Either e a

-- | Inverts bidirectional mapping.
invert :: BiMap e a b -> BiMap e b a

-- | Creates <a>BiMap</a> from isomorphism. Can be used in the following
--   way:
--   
--   <pre>
--   <b>newtype</b> Even = Even Integer
--   <b>newtype</b> Odd  = Odd  Integer
--   
--   succEven :: Even -&gt; Odd
--   succEven (Even n) = Odd (n + 1)
--   
--   predOdd :: Odd -&gt; Even
--   predOdd (Odd n) = Even (n - 1)
--   
--   _EvenOdd :: <a>BiMap</a> e Even Odd
--   _EvenOdd = <a>iso</a> succEven predOdd
--   </pre>
iso :: (a -> b) -> (b -> a) -> BiMap e a b

-- | Creates <a>BiMap</a> from prism-like pair of functions. This
--   combinator can be used to create <a>BiMap</a> for custom sum types
--   like this:
--   
--   <pre>
--   <b>data</b> User
--       = Admin  Integer  -- id of admin
--       | Client Text     -- name of the client
--       <b>deriving</b> (Show)
--   
--   _Admin :: <a>TomlBiMap</a> User Integer
--   _Admin = Toml.<a>prism</a> Admin $ \<b>case</b>
--       Admin i -&gt; Right i
--       other   -&gt; Toml.<a>wrongConstructor</a> "Admin" other
--   
--   _Client :: <a>TomlBiMap</a> User Text
--   _Client = Toml.<a>prism</a> Client $ \<b>case</b>
--       Client n -&gt; Right n
--       other    -&gt; Toml.<a>wrongConstructor</a> "Client" other
--   </pre>
prism :: (field -> object) -> (object -> Either error field) -> BiMap error object field

-- | <a>BiMap</a> specialized to TOML error.
type TomlBiMap = BiMap TomlBiMapError

-- | Type of errors for TOML <a>BiMap</a>.
data TomlBiMapError

-- | Error for cases with wrong constructors. For example, you're trying to
--   convert <a>Left</a> but bidirectional converter expects <a>Right</a>.
WrongConstructor :: !Text -> !Text -> TomlBiMapError

-- | Error for cases with wrong values
WrongValue :: !MatchError -> TomlBiMapError

-- | Arbitrary textual error
ArbitraryError :: !Text -> TomlBiMapError

-- | Helper to construct WrongConstuctor error.
wrongConstructor :: Show a => Text -> a -> Either TomlBiMapError b

-- | Converts <a>TomlBiMapError</a> into pretty human-readable text.
prettyBiMapError :: TomlBiMapError -> Text

-- | Smart constructor for <a>BiMap</a> from a Haskell value (some
--   primitive like <a>Int</a> or <a>Text</a>) to <a>AnyValue</a>.
mkAnyValueBiMap :: forall a (tag :: TValue). (forall (t :: TValue). () => Value t -> Either MatchError a) -> (a -> Value tag) -> TomlBiMap a AnyValue
tShow :: Show a => a -> Text
instance Control.Category.Category (Toml.Codec.BiMap.BiMap e)
instance GHC.Classes.Eq Toml.Codec.BiMap.TomlBiMapError
instance GHC.Generics.Generic Toml.Codec.BiMap.TomlBiMapError
instance Control.DeepSeq.NFData Toml.Codec.BiMap.TomlBiMapError
instance GHC.Show.Show Toml.Codec.BiMap.TomlBiMapError


-- | Core error types, including <a>TomlDecodeError</a> and
--   <a>LoadTomlException</a>.
module Toml.Codec.Error

-- | Type of exception for converting from TOML to user custom data type.
data TomlDecodeError
BiMapError :: !Key -> !TomlBiMapError -> TomlDecodeError

-- | No such key
KeyNotFound :: !Key -> TomlDecodeError

-- | No such table
TableNotFound :: !Key -> TomlDecodeError

-- | No such table array
TableArrayNotFound :: !Key -> TomlDecodeError

-- | Exception during parsing
ParseError :: !TomlParseError -> TomlDecodeError

-- | Unused field left in the decoded TOML.
NotExactDecode :: !TOML -> TomlDecodeError

-- | Converts <a>TomlDecodeError</a>s into pretty human-readable text.
prettyTomlDecodeErrors :: [TomlDecodeError] -> Text

-- | Converts <a>TomlDecodeError</a> into pretty human-readable text.
prettyTomlDecodeError :: TomlDecodeError -> Text

-- | File loading error data type.
data LoadTomlException
LoadTomlException :: !FilePath -> !Text -> LoadTomlException
instance GHC.Classes.Eq Toml.Codec.Error.TomlDecodeError
instance GHC.Exception.Type.Exception Toml.Codec.Error.LoadTomlException
instance GHC.Generics.Generic Toml.Codec.Error.TomlDecodeError
instance Control.DeepSeq.NFData Toml.Codec.Error.TomlDecodeError
instance GHC.Show.Show Toml.Codec.Error.LoadTomlException
instance GHC.Show.Show Toml.Codec.Error.TomlDecodeError


-- | Contains general underlying monad for bidirectional conversion.
module Toml.Codec.Types

-- | Specialied <a>Codec</a> type alias for bidirectional TOML
--   serialization. Keeps <a>TOML</a> object as both environment and state.
type TomlCodec a = Codec a a

-- | Immutable environment for TOML conversion.
type TomlEnv a = TOML -> Validation [TomlDecodeError] a

-- | Mutable context for TOML conversion. We are introducing our own
--   implemetation of state with <a>MonadState</a> instance due to some
--   limitation in the design connected to the usage of State.
--   
--   This newtype is equivalent to the following transformer:
--   
--   <pre>
--   MaybeT (State TOML)
--   </pre>
newtype TomlState a
TomlState :: (TOML -> (Maybe a, TOML)) -> TomlState a
[unTomlState] :: TomlState a -> TOML -> (Maybe a, TOML)

-- | Transform <a>Either</a> into <a>TomlState</a>.
eitherToTomlState :: Either e a -> TomlState a

-- | Monad for bidirectional conversion. Contains pair of functions:
--   
--   <ol>
--   <li>How to read value of type <tt>o</tt> (out) from immutable
--   environment context (<a>TomlEnv</a>)?</li>
--   <li>How to store a value of type <tt>i</tt> (in) in stateful context
--   (<a>TomlState</a>) and return a value of type <tt>o</tt>?</li>
--   </ol>
--   
--   This approach with the bunch of utility functions allows to have
--   single description for from/to <tt>TOML</tt> conversion.
--   
--   In practice this type will always be used in the following way:
--   
--   <pre>
--   type <a>TomlCodec</a> a = <a>Codec</a> a a
--   </pre>
--   
--   Type parameter <tt>i</tt> if fictional. Here some trick is used. This
--   trick is implemented in the <a>codec</a> package and described in more
--   details in related blog post:
--   <a>https://blog.poisson.chat/posts/2016-10-12-bidirectional-serialization.html</a>.
data Codec i o
Codec :: TomlEnv o -> (i -> TomlState o) -> Codec i o

-- | Extract value of type <tt>o</tt> from monadic context <a>TomlEnv</a>.
[codecRead] :: Codec i o -> TomlEnv o

-- | Store value of type <tt>i</tt> inside monadic context <a>TomlState</a>
--   and returning value of type <tt>o</tt>. Type of this function actually
--   should be <tt>o -&gt; TomlState ()</tt> but with such type it's
--   impossible to have <a>Monad</a> and other instances.
[codecWrite] :: Codec i o -> i -> TomlState o

-- | Alternative instance for function arrow but without <a>empty</a>.
(<!>) :: Alternative f => (a -> f x) -> (a -> f x) -> a -> f x
infixl 3 <!>
instance GHC.Base.Alternative (Toml.Codec.Types.Codec i)
instance GHC.Base.Alternative Toml.Codec.Types.TomlState
instance GHC.Base.Applicative (Toml.Codec.Types.Codec i)
instance GHC.Base.Applicative Toml.Codec.Types.TomlState
instance GHC.Base.Functor (Toml.Codec.Types.Codec i)
instance GHC.Base.Functor Toml.Codec.Types.TomlState
instance (s GHC.Types.~ Toml.Type.TOML.TOML) => Control.Monad.State.Class.MonadState s Toml.Codec.Types.TomlState
instance GHC.Base.Monad Toml.Codec.Types.TomlState


-- | Forward and backward mapping functions and combinators (similar to
--   profunctors).
module Toml.Codec.Di

-- | This is an instance of <tt>Profunctor</tt> for <a>Codec</a>. But since
--   there's no <tt>Profunctor</tt> type class in <tt>base</tt> or package
--   with no dependencies (and we don't want to bring extra dependencies)
--   this instance is implemented as a single top-level function.
--   
--   Useful when you want to parse <tt>newtype</tt>s. For example, if you
--   had data type like this:
--   
--   <pre>
--   <b>data</b> Example = Example
--       { foo :: Bool
--       , bar :: Text
--       }
--   </pre>
--   
--   Bidirectional TOML converter for this type will look like this:
--   
--   <pre>
--   exampleCodec :: TomlCodec Example
--   exampleCodec = Example
--       &lt;$&gt; Toml.bool "foo" <a>.=</a> foo
--       &lt;*&gt; Toml.text "bar" <a>.=</a> bar
--   </pre>
--   
--   Now if you change your type in the following way:
--   
--   <pre>
--   <b>newtype</b> Email = Email { unEmail :: Text }
--   
--   <b>data</b> Example = Example
--       { foo :: Bool
--       , bar :: Email
--       }
--   </pre>
--   
--   you need to patch your TOML codec like this:
--   
--   <pre>
--   exampleCodec :: TomlCodec Example
--   exampleCodec = Example
--       &lt;$&gt; Toml.bool "foo" <a>.=</a> foo
--       &lt;*&gt; <a>dimap</a> unEmail Email (Toml.text "bar") <a>.=</a> bar
--   </pre>
dimap :: (b -> a) -> (a -> b) -> TomlCodec a -> TomlCodec b

-- | Bidirectional converter for <tt>Maybe a</tt> values. For example,
--   given the data type:
--   
--   <pre>
--   <b>data</b> Example = Example
--       { foo :: Bool
--       , bar :: Maybe Int
--       }
--   </pre>
--   
--   the TOML codec will look like
--   
--   <pre>
--   exampleCodec :: TomlCodec Example
--   exampleCodec = Example
--       &lt;$&gt; Toml.bool "foo" <a>.=</a> foo
--       &lt;*&gt; <a>dioptional</a> (Toml.int "bar") <a>.=</a> bar
--   </pre>
dioptional :: TomlCodec a -> TomlCodec (Maybe a)

-- | Combinator used for <tt>newtype</tt> wrappers. For example, given the
--   data types:
--   
--   <pre>
--   <b>newtype</b> N = N Int
--   
--   <b>data</b> Example = Example
--       { foo :: Bool
--       , bar :: N
--       }
--   </pre>
--   
--   the TOML codec can look like
--   
--   <pre>
--   exampleCodec :: TomlCodec Example
--   exampleCodec = Example
--       &lt;$&gt; Toml.bool "foo" <a>.=</a> foo
--       &lt;*&gt; <a>diwrap</a> (Toml.int "bar") <a>.=</a> bar
--   </pre>
diwrap :: forall b a. Coercible a b => TomlCodec a -> TomlCodec b

-- | Bidirectional converter for <tt>sum types</tt>. For example, given the
--   data type:
--   
--   <pre>
--   <b>data</b> Example
--       = Foo Int
--       | Bar Bool Int
--   </pre>
--   
--   the TOML codec will look like
--   
--   <pre>
--   matchFoo :: Example -&gt; Maybe Int
--   matchFoo (Foo num) = Just num
--   matchFoo _         = Nothing
--   
--   matchBar :: Example -&gt; Maybe (Bool, Int)
--   matchBar (Bar b num) = Just (b, num)
--   matchBar _           = Nothing
--   
--   barCodec :: TomlCodec (Bool, Int)
--   barCodec = Toml.pair
--       (Toml.bool "a")
--       (Toml.int "b")
--   
--   exampleCodec :: TomlCodec Example
--   exampleCodec =
--       dimatch matchFoo Foo (Toml.int "foo")
--       &lt;|&gt; dimatch matchBar (uncurry Bar) (Toml.table barCodec "bar")
--   </pre>
dimatch :: (b -> Maybe a) -> (a -> b) -> TomlCodec a -> TomlCodec b

-- | Operator to connect two operations:
--   
--   <ol>
--   <li>How to get field from object?</li>
--   <li>How to write this field to toml?</li>
--   </ol>
--   
--   In code this should be used like this:
--   
--   <pre>
--   <b>data</b> Foo = Foo
--       { fooBar :: Int
--       , fooBaz :: String
--       }
--   
--   fooCodec :: TomlCodec Foo
--   fooCodec = Foo
--       &lt;$&gt; Toml.int "bar" <a>.=</a> fooBar
--       &lt;*&gt; Toml.str "baz" <a>.=</a> fooBaz
--   </pre>
(.=) :: Codec field a -> (object -> field) -> Codec object a
infixl 5 .=


-- | TOML-specific combinators for converting between TOML and Haskell
--   tuples. It's recommended to create your custom data types and
--   implement codecs for them, but if you need to have tuples (e.g. for
--   decoding different constructors of sum types), you can find codecs
--   from this module helpful.
--   
--   TODO: table
module Toml.Codec.Combinator.Tuple

-- | Codec for pair of values. Takes codecs for the first and for the
--   second values of the pair.
--   
--   If I have the following <tt>TOML</tt> entry
--   
--   <pre>
--   myPair = { first = 11, second = "eleven"}
--   </pre>
--   
--   and want to convert it into the Haskell tuple of two elements, I can
--   use the following codec:
--   
--   <pre>
--   myPairCodec :: <a>TomlCodec</a> (<a>Int</a>, <tt>Text</tt>)
--   myPairCodec = flip Toml.<tt>table</tt> "myPair" $ Toml.<a>pair</a>
--       (Toml.<tt>int</tt> "first")
--       (Toml.<tt>text</tt> "second")
--   </pre>
pair :: TomlCodec a -> TomlCodec b -> TomlCodec (a, b)

-- | Codec for triple of values. Takes codecs for the first, second and
--   third values of the triple.
--   
--   If I have the following <tt>TOML</tt> entry
--   
--   <pre>
--   myTriple =
--       { first = 11
--       , second = "eleven"
--       , isMyFavourite = true
--       }
--   </pre>
--   
--   and want to convert it into the Haskell tuple of three elements, I can
--   use the following codec:
--   
--   <pre>
--   myTripleCodec :: <a>TomlCodec</a> (<a>Int</a>, <tt>Text</tt>, <a>Bool</a>)
--   myTripleCodec = flip Toml.<tt>table</tt> "myTriple" $ Toml.<a>triple</a>
--       (Toml.<tt>int</tt> "first")
--       (Toml.<tt>text</tt> "second")
--       (Toml.<tt>bool</tt> "isMyFavourite")
--   </pre>
triple :: TomlCodec a -> TomlCodec b -> TomlCodec c -> TomlCodec (a, b, c)


-- | Contains TOML-specific combinators for converting between TOML and
--   user data types.
--   
--   Tables can be represented in <tt>TOML</tt> in one of the following
--   ways:
--   
--   <pre>
--   foo =
--       { x = ...
--       , y = ...
--       , ...
--       }
--   </pre>
--   
--   <b>Or</b>
--   
--   <pre>
--   [foo]
--       x = ...
--       y = ...
--       ...
--   </pre>
module Toml.Codec.Combinator.Table

-- | Codec for tables. Use it when when you have nested objects.
table :: TomlCodec a -> Key -> TomlCodec a

-- | Maps errors in tables with <a>mapTableErrors</a>
handleTableErrors :: TomlCodec a -> Key -> TOML -> Validation [TomlDecodeError] a

-- | Prepends given key to all errors that contain key. This function is
--   used to give better error messages. So when error happens we know all
--   pieces of table key, not only the last one.
mapTableErrors :: Key -> [TomlDecodeError] -> [TomlDecodeError]


-- | Conversion from textual representation of <tt>TOML</tt> values to the
--   Haskell data types by the given <a>TomlCodec</a>.
--   
--   This module includes coding functions like <a>decode</a> and
--   <a>encode</a>.
module Toml.Codec.Code

-- | Convert textual representation of <tt>TOML</tt> into user data type by
--   the provided codec.
decode :: TomlCodec a -> Text -> Either [TomlDecodeError] a

-- | Convert textual representation of <tt>TOML</tt> into user data type by
--   the provided codec.
--   
--   Unlike <a>decode</a>, this function returns <a>NotExactDecode</a>
--   error in case if given <tt>TOML</tt> has redundant fields and other
--   elements.
decodeExact :: TomlCodec a -> Text -> Either [TomlDecodeError] a

-- | Convert textual representation of <tt>TOML</tt> into user data type by
--   the provided codec.
decodeValidation :: TomlCodec a -> Text -> Validation [TomlDecodeError] a

-- | Similar to <a>decode</a>, but takes a path to a file with textual
--   <tt>TOML</tt> values from which it decodes them with the provided
--   codec.
decodeFileEither :: forall a m. MonadIO m => TomlCodec a -> FilePath -> m (Either [TomlDecodeError] a)

-- | Similar to <a>decodeFileEither</a>, throws <a>LoadTomlException</a> in
--   case of parse errors (<a>TomlDecodeError</a>).
decodeFile :: forall a m. MonadIO m => TomlCodec a -> FilePath -> m a

-- | Similar to <a>decodeExact</a>, but takes a path to a file with textual
--   <tt>TOML</tt> values from which it decodes them with the provided
--   codec.
decodeFileExact :: forall a m. MonadIO m => TomlCodec a -> FilePath -> m (Either [TomlDecodeError] a)

-- | Convert data type to the textual representation of <tt>TOML</tt>
--   values.
encode :: TomlCodec a -> a -> Text

-- | Convert data type to the textual representation of <tt>TOML</tt>
--   values. and write it info the given file.
encodeToFile :: forall a m. MonadIO m => TomlCodec a -> FilePath -> a -> m Text

-- | Convert toml into user data type.
runTomlCodec :: TomlCodec a -> TOML -> Validation [TomlDecodeError] a

-- | Runs <a>codecWrite</a> of <a>TomlCodec</a> and returns intermediate
--   TOML AST.
execTomlCodec :: TomlCodec a -> a -> TOML


-- | This module implements common utilities for writing custom codecs
--   without diving into internal implementation details. Most of the time
--   you don't need to implement your own codecs and can reuse existing
--   ones. But if you need something that library doesn't provide, you can
--   find functions in this module useful.
module Toml.Codec.Combinator.Common

-- | General function to create bidirectional converters for key-value
--   pairs. In order to use this function you need to create
--   <a>TomlBiMap</a> for your type and <a>AnyValue</a>:
--   
--   <pre>
--   _MyType :: <a>TomlBiMap</a> MyType <a>AnyValue</a>
--   </pre>
--   
--   And then you can create codec for your type using <a>match</a>
--   function:
--   
--   <pre>
--   myType :: <a>Key</a> -&gt; <a>TomlCodec</a> MyType
--   myType = <a>match</a> _MyType
--   </pre>
match :: TomlBiMap a AnyValue -> Key -> TomlCodec a

-- | Throw error on <a>Left</a>, or perform a given action with
--   <a>Right</a>.
whenLeftBiMapError :: Key -> Either TomlBiMapError a -> (a -> Validation [TomlDecodeError] b) -> Validation [TomlDecodeError] b


-- | TOML-specific combinators for converting between TOML and Haskell
--   Map-like data types.
--   
--   There are two way to represent map-like structures with the
--   <tt>tomland</tt> library.
--   
--   <ul>
--   <li>Map structure with the key and value represented as key-value
--   pairs:<pre>foo = [ {myKey = "name", myVal = 42} , {myKey =
--   "otherName", myVal = 100} ] </pre></li>
--   <li>Map structure as a table with the <tt>TOML</tt> key as the map
--   key:<pre>[foo] name = 42 otherName = 100 </pre></li>
--   </ul>
--   
--   You can find both types of the codecs in this module for different
--   map-like structures. See the following table for the heads up:
--   
--   TODO: table
--   
--   <b>Note:</b> in case of the missing key on the <tt>TOML</tt> side an
--   empty map structure is returned.
module Toml.Codec.Combinator.Map

-- | Bidirectional codec for <a>Map</a>. It takes birectional converter for
--   keys and values and produces bidirectional codec for <a>Map</a>.
--   Currently it works only with array of tables, so you need to specify
--   <a>Map</a>s in TOML files like this:
--   
--   <pre>
--   myMap =
--       [ { name = "foo", payload = 42 }
--       , { name = "bar", payload = 69 }
--       ]
--   </pre>
--   
--   <a>TomlCodec</a> for such TOML field can look like this:
--   
--   <pre>
--   Toml.<a>map</a> (Toml.<tt>text</tt> "name") (Toml.<tt>int</tt> "payload") "myMap"
--   </pre>
--   
--   If there's no key with the name <tt>"myMap"</tt> then empty <a>Map</a>
--   is returned.
map :: Ord k => TomlCodec k -> TomlCodec v -> Key -> TomlCodec (Map k v)

-- | This <a>TomlCodec</a> helps you to convert TOML key-value pairs
--   directly to <a>Map</a> using TOML keys as <a>Map</a> keys. It can be
--   convenient if your <a>Map</a> keys are types like <tt>Text</tt> or
--   <a>Int</a> and you want to work with raw TOML keys directly.
--   
--   For example, if you have TOML like this:
--   
--   <pre>
--   [colours]
--   yellow = "#FFFF00"
--   red    = { red = 255, green = 0, blue = 0 }
--   pink   = "#FFC0CB"
--   </pre>
--   
--   You want to convert such TOML configuration into the following Haskell
--   types:
--   
--   <pre>
--   <b>data</b> Rgb = Rgb
--       { rgbRed   :: Int
--       , rgbGreen :: Int
--       , rgbBlue  :: Int
--       }
--   
--   <b>data</b> Colour
--       = Hex Text
--       | RGB Rgb
--   
--   colourCodec :: <a>TomlCodec</a> Colour
--   colourCodec = ...
--   
--   <b>data</b> ColourConfig = ColourConfig
--       { configColours :: <a>Map</a> <tt>Text</tt> Colour
--       }
--   </pre>
--   
--   And you want in the result to have a <a>Map</a> like this:
--   
--   <pre>
--   <a>fromList</a>
--       [ "yellow" -&gt; Hex "#FFFF00"
--       , "pink"   -&gt; Hex "#FFC0CB"
--       , "red"    -&gt; Rgb 255 0 0
--       ]
--   </pre>
--   
--   You can use <a>tableMap</a> to define <a>TomlCodec</a> in the
--   following way:
--   
--   <pre>
--   colourConfigCodec :: <a>TomlCodec</a> ColourConfig
--   colourConfigCodec = ColourConfig
--       &lt;$&gt; Toml.<a>tableMap</a> Toml._KeyText colourCodec "colours" .= configColours
--   </pre>
--   
--   <b>Hint:</b> You can use <a>_KeyText</a> or <a>_KeyString</a> to
--   convert betwen TOML keys and <a>Map</a> keys (or you can write your
--   custom <a>TomlBiMap</a>).
--   
--   <b>NOTE</b>: Unlike the <a>map</a> codec, this codec is less flexible
--   (i.e. it doesn't allow to have arbitrary structures as <a>Key</a>s, it
--   works only for text-like keys), but can be helpful if you want to save
--   a few keystrokes during TOML configuration. A similar TOML
--   configuration, but suitable for the <a>map</a> codec will look like
--   this:
--   
--   <pre>
--   colours =
--       [ { key = "yellow", hex = "#FFFF00" }
--       , { key = "pink",   hex = "#FFC0CB" }
--       , { key = "red",    rgb = { red = 255, green = 0, blue = 0 } }
--       ]
--   </pre>
tableMap :: Ord k => TomlBiMap Key k -> (Key -> TomlCodec v) -> Key -> TomlCodec (Map k v)

-- | Bidirectional codec for <a>HashMap</a>. It takes birectional converter
--   for keys and values and produces bidirectional codec for
--   <a>HashMap</a>. It works with array of tables, so you need to specify
--   <a>HashMap</a>s in TOML files like this:
--   
--   <pre>
--   myHashMap =
--       [ { name = "foo", payload = 42 }
--       , { name = "bar", payload = 69 }
--       ]
--   </pre>
--   
--   <a>TomlCodec</a> for such TOML field can look like this:
--   
--   <pre>
--   Toml.<a>hashMap</a> (Toml.<tt>text</tt> "name") (Toml.<tt>int</tt> "payload") "myHashMap"
--   </pre>
--   
--   If there's no key with the name <tt>"myHashMap"</tt> then empty
--   <a>HashMap</a> is returned.
hashMap :: Hashable k => TomlCodec k -> TomlCodec v -> Key -> TomlCodec (HashMap k v)

-- | This <a>TomlCodec</a> helps to convert TOML key-value pairs directly
--   to <a>HashMap</a> using TOML keys as <a>HashMap</a> keys. It can be
--   convenient if your <a>HashMap</a> keys are types like <tt>Text</tt> or
--   <a>Int</a> and you want to work with raw TOML keys directly.
--   
--   For example, if you can write your <a>HashMap</a> in <tt>TOML</tt>
--   like this:
--   
--   <pre>
--   [myHashMap]
--   key1 = "value1"
--   key2 = "value2"
--   </pre>
tableHashMap :: Hashable k => TomlBiMap Key k -> (Key -> TomlCodec v) -> Key -> TomlCodec (HashMap k v)

-- | Bidirectional codec for <a>IntMap</a>. It takes birectional converter
--   for keys and values and produces bidirectional codec for
--   <a>IntMap</a>. It works with array of tables, so you need to specify
--   <a>IntMap</a>s in TOML files like this:
--   
--   <pre>
--   myIntMap =
--       [ { name = "foo", payload = 42 }
--       , { name = "bar", payload = 69 }
--       ]
--   </pre>
--   
--   <a>TomlCodec</a> for such TOML field can look like this:
--   
--   <pre>
--   Toml.<a>intMap</a> (Toml.<tt>text</tt> "name") (Toml.<tt>int</tt> "payload") "myIntMap"
--   </pre>
--   
--   If there's no key with the name <tt>"myIntMap"</tt> then empty
--   <a>IntMap</a> is returned.
intMap :: TomlCodec Int -> TomlCodec v -> Key -> TomlCodec (IntMap v)

-- | This <a>TomlCodec</a> helps to convert TOML key-value pairs directly
--   to <a>IntMap</a> using TOML <a>Int</a> keys as <a>IntMap</a> keys.
--   
--   For example, if you can write your <a>IntMap</a> in <tt>TOML</tt> like
--   this:
--   
--   <pre>
--   [myIntMap]
--   1 = "value1"
--   2 = "value2"
--   </pre>
tableIntMap :: TomlBiMap Key Int -> (Key -> TomlCodec v) -> Key -> TomlCodec (IntMap v)


-- | Implementations of <a>BiMap</a> for specific Haskell types and TOML
--   values. Usually, you use codecs from the <a>Toml.Codec.Combinator</a>
--   module. You may need to use these <a>BiMap</a>s instead of codecs in
--   the following situations:
--   
--   <ol>
--   <li>When using <a>arrayOf</a> combinator (or similar).</li>
--   <li>When using <a>tableMap</a> combinator (for keys).</li>
--   <li>When implementing custom <a>BiMap</a> for your types.</li>
--   </ol>
module Toml.Codec.BiMap.Conversion

-- | <a>Bool</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>bool</a> combinator.
_Bool :: TomlBiMap Bool AnyValue

-- | <a>Int</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>int</a> combinator.
_Int :: TomlBiMap Int AnyValue

-- | <a>Word</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>word</a> combinator.
_Word :: TomlBiMap Word AnyValue

-- | <a>Word8</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>word8</a> combinator.
_Word8 :: TomlBiMap Word8 AnyValue

-- | <a>Integer</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>integer</a> combinator.
_Integer :: TomlBiMap Integer AnyValue

-- | <a>Natural</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>natural</a> combinator.
_Natural :: TomlBiMap Natural AnyValue

-- | <a>Double</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>double</a> combinator.
_Double :: TomlBiMap Double AnyValue

-- | <a>Float</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>float</a> combinator.
_Float :: TomlBiMap Float AnyValue

-- | <a>Text</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>text</a> combinator.
_Text :: TomlBiMap Text AnyValue

-- | <a>Text</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>lazyText</a> combinator.
_LText :: TomlBiMap Text AnyValue

-- | UTF-8 encoded <a>ByteString</a> <a>BiMap</a> for <a>AnyValue</a>.
--   Usually used as the <a>byteString</a> combinator.
_ByteString :: TomlBiMap ByteString AnyValue

-- | UTF-8 encoded lazy <a>ByteString</a> <a>BiMap</a> for <a>AnyValue</a>.
--   Usually used as the <a>lazyByteString</a> combinator.
_LByteString :: TomlBiMap ByteString AnyValue

-- | <a>String</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>string</a> combinator.
_String :: TomlBiMap String AnyValue

-- | <a>ZonedTime</a> bimap for <a>AnyValue</a>. Usually used as the
--   <a>zonedTime</a> combinator.
_ZonedTime :: TomlBiMap ZonedTime AnyValue

-- | <a>LocalTime</a> bimap for <a>AnyValue</a>. Usually used as the
--   <a>localTime</a> combinator.
_LocalTime :: TomlBiMap LocalTime AnyValue

-- | <a>Day</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>day</a> combinator.
_Day :: TomlBiMap Day AnyValue

-- | <a>TimeOfDay</a> <a>BiMap</a> for <a>AnyValue</a>. Usually used as the
--   <a>timeOfDay</a> combinator.
_TimeOfDay :: TomlBiMap TimeOfDay AnyValue

-- | Takes a <a>BiMap</a> of a value and returns a <a>BiMap</a> for a list
--   of values and <a>AnyValue</a> as an array. Usually used as the
--   <a>arrayOf</a> combinator.
_Array :: TomlBiMap a AnyValue -> TomlBiMap [a] AnyValue

-- | Takes a <a>BiMap</a> of a value and returns a <a>BiMap</a> for a
--   <tt>NonEmpty</tt> list of values and <a>AnyValue</a> as an array.
--   Usually used as the <a>arrayNonEmptyOf</a> combinator.
_NonEmpty :: TomlBiMap a AnyValue -> TomlBiMap (NonEmpty a) AnyValue

-- | Takes a <a>BiMap</a> of a value and returns a <a>BiMap</a> for a
--   <tt>Set</tt> of values and <a>AnyValue</a> as an array. Usually used
--   as the <a>arraySetOf</a> combinator.
_Set :: Ord a => TomlBiMap a AnyValue -> TomlBiMap (Set a) AnyValue

-- | Takes a <a>BiMap</a> of a value and returns a <a>BiMap</a> for a
--   <tt>HashSet</tt> of values and <a>AnyValue</a> as an array. Usually
--   used as the <a>arrayHashSetOf</a> combinator.
_HashSet :: Hashable a => TomlBiMap a AnyValue -> TomlBiMap (HashSet a) AnyValue

-- | <a>IntSet</a> bimap for <a>AnyValue</a>. Usually used as the
--   <a>arrayIntSet</a> combinator.
_IntSet :: TomlBiMap IntSet AnyValue

-- | <a>ByteString</a> <a>BiMap</a> for <a>AnyValue</a> encoded as a list
--   of bytes (non-negative integers between 0 and 255). Usually used as
--   the <a>byteStringArray</a> combinator.
_ByteStringArray :: TomlBiMap ByteString AnyValue

-- | Lazy <a>ByteString</a> <a>BiMap</a> for <a>AnyValue</a> encoded as a
--   list of bytes (non-negative integers between 0 and 255). Usually used
--   as <a>lazyByteStringArray</a> combinator.
_LByteStringArray :: TomlBiMap ByteString AnyValue

-- | <a>BiMap</a> for <a>Coercible</a> values. It takes a <a>TomlBiMap</a>
--   for <tt>a</tt> type and returns a <a>TomlBiMap</a> <tt>b</tt> if these
--   types are coercible.
--   
--   It is supposed to be used to ease the work with <tt>newtypes</tt>.
--   
--   E.g.
--   
--   <pre>
--   <b>newtype</b> Foo = Foo
--       { unFoo :: <a>Int</a>
--       }
--   
--   fooBiMap :: <a>TomlBiMap</a> Foo <a>AnyValue</a>
--   fooBiMap = <a>_Coerce</a> <a>_Int</a>
--   </pre>
_Coerce :: Coercible a b => TomlBiMap a AnyValue -> TomlBiMap b AnyValue

-- | <a>BiMap</a> for nullary sum data types (enumerations) with
--   <a>Show</a>, <a>Enum</a> and <a>Bounded</a> instances. Usually used as
--   the <a>enumBounded</a> combinator.
_EnumBounded :: (Show a, Enum a, Bounded a) => TomlBiMap a AnyValue

-- | <a>BiMap</a> for <a>AnyValue</a> and values with a <a>Read</a> and
--   <a>Show</a> instances. Usually used as the <a>read</a> combinator.
_Read :: (Show a, Read a) => TomlBiMap a AnyValue

-- | Creates <a>BiMap</a> for <a>Text</a> to <a>AnyValue</a> with custom
--   functions. Usually used as the <a>textBy</a> combinator.
_TextBy :: (a -> Text) -> (Text -> Either Text a) -> TomlBiMap a AnyValue

-- | By the given <a>BiMap</a> validates it with the given predicate that
--   returns <a>Either</a> the value, if the validation is successful, or
--   the <a>Text</a> of the error that should be returned in case of
--   validation failure.
--   
--   Usually used as the <a>validate</a> or <a>validateIf</a> combinator.
_Validate :: (a -> Either Text a) -> TomlBiMap a AnyValue -> TomlBiMap a AnyValue

-- | <a>BiMap</a> for hardcoded values. It returns the same value in case
--   of success and <a>ArbitraryError</a> in other case.
_Hardcoded :: (Show a, Eq a) => a -> TomlBiMap a a

-- | Bidirectional converter between <a>Key</a> and <a>Text</a>. Usually
--   used as an argument for <a>tableMap</a>.
_KeyText :: TomlBiMap Key Text

-- | Bidirectional converter between <a>Key</a> and <a>String</a>. Usually
--   used as an argument for <a>tableMap</a>.
_KeyString :: TomlBiMap Key String

-- | Bidirectional converter between <a>Key</a> and <a>Int</a>. Usually
--   used as an argument for <a>tableIntMap</a>.
_KeyInt :: TomlBiMap Key Int

-- | <a>BiMap</a> for <a>Maybe</a> and its <a>Just</a> part.
_Just :: Show r => TomlBiMap (Maybe r) r

-- | <a>BiMap</a> for <a>Either</a> and its <a>Left</a> part.
_Left :: (Show l, Show r) => TomlBiMap (Either l r) l

-- | <a>BiMap</a> for <a>Either</a> and its <a>Right</a> part.
_Right :: (Show l, Show r) => TomlBiMap (Either l r) r

-- | Helper bimap for <a>Text</a> and <a>Text</a>.
_LTextText :: BiMap e Text Text

-- | Helper <a>BiMap</a> for <a>Natural</a> and <a>Integer</a>.
_NaturalInteger :: TomlBiMap Natural Integer

-- | Helper <a>BiMap</a> for lists and <a>NonEmpty</a>.
_NonEmptyList :: TomlBiMap (NonEmpty a) [a]

-- | Helper <a>BiMap</a> for <a>String</a> and <a>Text</a>.
_StringText :: BiMap e String Text

-- | Helper <a>BiMap</a> for <a>String</a> and types with <a>Read</a> and
--   <a>Show</a> instances.
_ReadString :: (Show a, Read a) => TomlBiMap a String

-- | Helper <a>BiMap</a> for <a>Integer</a> and integral, bounded values.
_BoundedInteger :: (Integral a, Bounded a, Show a) => TomlBiMap a Integer

-- | Helper <a>BiMap</a> for <a>_EnumBounded</a> and <a>Text</a>.
_EnumBoundedText :: (Show a, Enum a, Bounded a) => TomlBiMap a Text

-- | Helper <a>BiMap</a> for <a>Text</a> and strict <a>ByteString</a>
_ByteStringText :: TomlBiMap ByteString Text

-- | Helper <a>BiMap</a> for <a>Text</a> and lazy <a>ByteString</a>.
_LByteStringText :: TomlBiMap ByteString Text


-- | TOML-specific combinators for converting between TOML and Haskell date
--   and time data types. TOML specification describes date and time
--   primitives you can use in your configuration. <tt>tomland</tt>
--   provides mapping of those primitives to types from the <tt>time</tt>
--   library.
--   
--   TODO: table
module Toml.Codec.Combinator.Time

-- | Codec for zoned time values.
zonedTime :: Key -> TomlCodec ZonedTime

-- | Codec for local time values.
localTime :: Key -> TomlCodec LocalTime

-- | Codec for day values.
day :: Key -> TomlCodec Day

-- | Codec for time of day values.
timeOfDay :: Key -> TomlCodec TimeOfDay


-- | TOML-specific combinators for converting between TOML and Haskell
--   primitive types, e.g. <a>Int</a>, <a>ByteString</a>.
--   
--   For the overall picture you can see how different types are
--   represented by codecs in the following table:
--   
--   TODO: table
module Toml.Codec.Combinator.Primitive

-- | Codec for boolean values.
bool :: Key -> TomlCodec Bool

-- | Codec for integer values.
integer :: Key -> TomlCodec Integer

-- | Codec for integer values.
int :: Key -> TomlCodec Int

-- | Codec for natural values.
natural :: Key -> TomlCodec Natural

-- | Codec for word values.
word :: Key -> TomlCodec Word

-- | Codec for word8 values.
word8 :: Key -> TomlCodec Word8

-- | Codec for floating point values with double precision.
double :: Key -> TomlCodec Double

-- | Codec for floating point values.
float :: Key -> TomlCodec Float

-- | Codec for string values.
string :: Key -> TomlCodec String

-- | Codec for text values.
text :: Key -> TomlCodec Text

-- | Codec for lazy text values.
lazyText :: Key -> TomlCodec Text

-- | Codec for text values as <a>ByteString</a>.
byteString :: Key -> TomlCodec ByteString

-- | Codec for text values as <a>ByteString</a>.
lazyByteString :: Key -> TomlCodec ByteString

-- | Codec for positive integer array values as <a>ByteString</a>.
byteStringArray :: Key -> TomlCodec ByteString

-- | Codec for positive integer array values as lazy <a>ByteString</a>.
lazyByteStringArray :: Key -> TomlCodec ByteString


-- | TOML-specific combinators for converting between TOML and Haskell
--   <a>Monoid</a> wrapper data types. These codecs are especially handy
--   when you are implementing the <a>Partial Options Monoid</a> pattern.
--   
--   TODO: table
module Toml.Codec.Combinator.Monoid

-- | Codec for <a>All</a> wrapper for boolean values. Returns
--   <tt><a>All</a> <a>True</a></tt> on missing fields.
--   
--   Decodes to <tt><a>All</a> <a>True</a></tt> when the key is not
--   present.
all :: Key -> TomlCodec All

-- | Codec for <a>Any</a> wrapper for boolean values. Returns
--   <tt><a>Any</a> <a>False</a></tt> on missing fields.
--   
--   Decodes to <tt><a>Any</a> <a>False</a></tt> when the key is not
--   present.
any :: Key -> TomlCodec Any

-- | Codec for <a>Sum</a> wrapper for given converter's values.
--   
--   Decodes to <tt><a>Sum</a> 0</tt> when the key is not present.
sum :: Num a => (Key -> TomlCodec a) -> Key -> TomlCodec (Sum a)

-- | Codec for <a>Product</a> wrapper for given converter's values.
--   
--   Decodes to <tt><a>Product</a> 1</tt> when the key is not present.
product :: Num a => (Key -> TomlCodec a) -> Key -> TomlCodec (Product a)

-- | Codec for <a>First</a> wrapper for given converter's values.
--   
--   Decodes to <tt><a>First</a> <a>Nothing</a></tt> when the key is not
--   present.
first :: (Key -> TomlCodec a) -> Key -> TomlCodec (First a)

-- | Codec for <a>Last</a> wrapper for given converter's values.
--   
--   Decodes to <tt><a>Last</a> <a>Nothing</a></tt> when the key is not
--   present.
last :: (Key -> TomlCodec a) -> Key -> TomlCodec (Last a)


-- | TOML-specific combinators for converting between TOML and Haskell
--   list-like data types.
--   
--   There are two way to represent list-like structures with the
--   <tt>tomland</tt> library.
--   
--   <ul>
--   <li>Ordinary array lists of primitives:<pre>foo = [100, 200, 300]
--   </pre></li>
--   <li>Lists via tables:<pre>foo = [ {x = 100} , {x = 200} , {x = 300} ]
--   <b>OR</b> [[foo]] x = 100 [[foo]] x = 200 [[foo]] x = 300 </pre></li>
--   </ul>
--   
--   You can find both types of the codecs in this module for different
--   list-like structures. See the following table for the better
--   understanding:
--   
--   TODO: table
module Toml.Codec.Combinator.List

-- | Codec for list of values. Takes converter for single value and returns
--   a list of values.
--   
--   <b>Example:</b>
--   
--   Haskell <tt>[<a>Int</a>]</tt> can look like this in your <tt>TOML</tt>
--   file:
--   
--   <pre>
--   foo = [1, 2, 3]
--   </pre>
--   
--   If the key is not present in <tt>TOML</tt> the following decode error
--   will be spotted:
--   
--   <pre>
--   tomland decode error:  Key foo is not found
--   </pre>
arrayOf :: TomlBiMap a AnyValue -> Key -> TomlCodec [a]

-- | Codec for non- empty lists of values. Takes converter for single value
--   and returns a non-empty list of values.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>NonEmpty</a> <a>Int</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo = [1, 2, 3]
--   </pre>
--   
--   If you try to decode an empty <tt>TOML</tt> list you will see the
--   error:
--   
--   <pre>
--   tomland decode error:  Empty array list, but expected NonEmpty
--   </pre>
--   
--   If the key is not present in <tt>TOML</tt> the following decode error
--   will be spotted:
--   
--   <pre>
--   tomland decode error:  Key foo is not found
--   </pre>
arrayNonEmptyOf :: TomlBiMap a AnyValue -> Key -> TomlCodec (NonEmpty a)

-- | <a>Codec</a> for list of values. Represented in TOML as array of
--   tables.
--   
--   <b>Example:</b>
--   
--   Haskell <tt>[<a>Int</a>]</tt> can look like this in your <tt>TOML</tt>
--   file:
--   
--   <pre>
--   foo =
--     [ {a = 1}
--     , {a = 2}
--     , {a = 3}
--     ]
--   </pre>
--   
--   Decodes to an empty list <tt>[]</tt> when the key is not present.
list :: TomlCodec a -> Key -> TomlCodec [a]

-- | <a>Codec</a> for <a>NonEmpty</a> list of values. Represented in TOML
--   as array of tables.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>NonEmpty</a> <a>Int</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo =
--     [ {a = 1}
--     , {a = 2}
--     , {a = 3}
--     ]
--   </pre>
--   
--   If you try to decode an empty <tt>TOML</tt> list you will see the
--   error:
--   
--   <pre>
--   tomland decode error:  Table array [[foo]] is not found
--   </pre>
--   
--   or
--   
--   <pre>
--   tomland decode error:  Key foo.a is not found
--   </pre>
--   
--   If the key is not present in <tt>TOML</tt> the following decode error
--   will be spotted:
--   
--   <pre>
--   tomland decode error:  Table array [[foo]] is not found
--   </pre>
nonEmpty :: TomlCodec a -> Key -> TomlCodec (NonEmpty a)


-- | TOML-specific combinators for converting between TOML and Haskell
--   Set-like data types.
--   
--   There are two way to represent list-like structures with the
--   <tt>tomland</tt> library.
--   
--   <ul>
--   <li>Ordinary array sets of primitives:<pre>foo = [100, 200, 300]
--   </pre></li>
--   <li>Sets via tables:<pre>foo = [ {x = 100} , {x = 200} , {x = 300} ]
--   <b>OR</b> [[foo]] x = 100 [[foo]] x = 200 [[foo]] x = 300 </pre></li>
--   </ul>
--   
--   You can find both types of the codecs in this module for different
--   set-like structures. See the following table for the better
--   understanding:
--   
--   TODO: table
module Toml.Codec.Combinator.Set

-- | Codec for sets. Takes converter for single value and returns a set of
--   values.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>Set</a> <a>Int</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo = [1, 2, 3]
--   </pre>
--   
--   In case of the missing field, the following error will be seen:
--   
--   <pre>
--   tomland decode error:  Key foo is not found
--   </pre>
arraySetOf :: Ord a => TomlBiMap a AnyValue -> Key -> TomlCodec (Set a)

-- | Codec for sets of ints. Takes converter for single value and returns a
--   set of ints.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>IntSet</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo = [1, 2, 3]
--   </pre>
--   
--   In case of the missing field, the following error will be seen:
--   
--   <pre>
--   tomland decode error:  Key foo is not found
--   </pre>
arrayIntSet :: Key -> TomlCodec IntSet

-- | Codec for hash sets. Takes converter for single hashable value and
--   returns a set of hashable values.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>HashSet</a> <a>Int</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo = [1, 2, 3]
--   </pre>
--   
--   In case of the missing field, the following error will be seen:
--   
--   <pre>
--   tomland decode error:  Key foo is not found
--   </pre>
arrayHashSetOf :: Hashable a => TomlBiMap a AnyValue -> Key -> TomlCodec (HashSet a)

-- | <tt>Codec</tt> for set of values. Represented in TOML as array of
--   tables.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>Set</a> <a>Int</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo =
--     [ {a = 1}
--     , {a = 2}
--     ]
--   </pre>
--   
--   Decodes to an empty <a>Set</a> in case of the missing field in
--   <tt>TOML</tt>.
set :: Ord a => TomlCodec a -> Key -> TomlCodec (Set a)

-- | <tt>Codec</tt> for <a>IntSet</a>. Represented in TOML as an array of
--   tables.
--   
--   <b>Example:</b>
--   
--   Haskell <a>IntSet</a> can look like this in your <tt>TOML</tt> file:
--   
--   <pre>
--   foo =
--     [ {a = 1}
--     , {a = 2}
--     ]
--   </pre>
--   
--   Decodes to an empty <a>IntSet</a> in case of the missing field in
--   <tt>TOML</tt>.
intSet :: TomlCodec Int -> Key -> TomlCodec IntSet

-- | <tt>Codec</tt> for <a>HashSet</a> of values. Represented in TOML as an
--   array of tables.
--   
--   <b>Example:</b>
--   
--   Haskell <tt><a>HashSet</a> <a>Int</a></tt> can look like this in your
--   <tt>TOML</tt> file:
--   
--   <pre>
--   foo =
--     [ {a = 1}
--     , {a = 2}
--     ]
--   </pre>
--   
--   Decodes to an empty <a>HashSet</a> in case of the missing field in
--   <tt>TOML</tt>.
hashSet :: Hashable a => TomlCodec a -> Key -> TomlCodec (HashSet a)


-- | Contains TOML-specific custom combinators for converting between TOML
--   and special user data types.
--   
--   See examples below of the situations you may need the following
--   combinators.
module Toml.Codec.Combinator.Custom

-- | Codec for text values with custom error messages for parsing.
--   
--   <b>Example:</b>
--   
--   We have the following type that represents the image format:
--   
--   <pre>
--   <b>data</b> Format
--       = Jpeg
--       | Png
--       | Gif
--       <b>deriving</b> (<a>Show</a>, <a>Read</a>, <a>Enum</a>)
--   </pre>
--   
--   But we want to be able to decode and encode this data type through the
--   custom text representation, that can be formilised in the following
--   functions:
--   
--   <pre>
--   showFormat :: Format -&gt; <a>Text</a>
--   showFormat = case
--       Jpeg -&gt; ".jpeg"
--       Png  -&gt; ".png"
--       Gif  -&gt; ".gif"
--   
--   parseFormat :: <a>Text</a> -&gt; <a>Either</a> <a>Text</a> Format
--   parseFormat = <b>case</b>
--       ".jpeg" -&gt; <a>Right</a> Jpeg
--       ".png"  -&gt; <a>Right</a> Png
--       ".gif"  -&gt; <a>Right</a> Gif
--       other   -&gt; <a>Left</a> $ "Unsupported format: " &lt;&gt; other
--   </pre>
--   
--   To write the codec for <tt>Format</tt> data type using the above rules
--   we can use <a>textBy</a> combinator:
--   
--   <pre>
--   formatCodec :: <a>Key</a> -&gt; <a>TomlCodec</a> Format
--   formatCodec = <a>textBy</a> showFormat parseFormat
--   </pre>
--   
--   And now with the <tt>formatCodec "foo"</tt> we can have the following
--   line in our <tt>TOML</tt> perfectly encoded:
--   
--   <pre>
--   foo = ".gif"
--   </pre>
--   
--   But the <tt>foo = "jif"</tt> will lead to the following error:
--   
--   <pre>
--   tomland decode error:  Unsupported format: jif
--   </pre>
textBy :: (a -> Text) -> (Text -> Either Text a) -> Key -> TomlCodec a

-- | Codec for values with a <a>Read</a> and <a>Show</a> instance.
--   
--   <b>Example:</b>
--   
--   We have the following type that represents the image format:
--   
--   <pre>
--   <b>data</b> Format
--       = Jpeg
--       | Png
--       | Gif
--       deriving (Show, Read, Enum)
--   </pre>
--   
--   And we want to be able to decode and encode this data type through the
--   <a>Show</a> and <a>Read</a> instances.
--   
--   To write the codec for <tt>Format</tt> data type using the existing
--   instances we can use <a>read</a> combinator. And now with the
--   <tt>Toml.<a>read</a> "foo"</tt> we can have the following line in our
--   <tt>TOML</tt> perfectly encoded:
--   
--   <pre>
--   foo = <a>Gif</a>
--   </pre>
--   
--   But the <tt>foo = ".gif"</tt> will lead to the following error:
--   
--   <pre>
--   tomland decode error:  Prelude.read: no parse
--   </pre>
read :: (Show a, Read a) => Key -> TomlCodec a

-- | Codec for general nullary sum data types with a <a>Bounded</a>,
--   <a>Enum</a>, and <a>Show</a> instance. This codec is similar to
--   <a>read</a> but provides much better error messages than <a>read</a>
--   for nullary sum types.
--   
--   E.g. for the same <tt>Format</tt> example from <a>read</a> function,
--   but with the <tt>Toml.<a>enumBounded</a> "foo"</tt> codec the error
--   for <tt>foo = "Jif"</tt> in the <tt>TOML</tt> file will look like
--   this:
--   
--   <pre>
--   tomland decode error:  Value is <tt>Jif</tt> but expected one of: Jpeg, Png, Gif
--   </pre>
enumBounded :: (Bounded a, Enum a, Show a) => Key -> TomlCodec a

-- | Codec for hardcoded provided values and its <tt>BiMap</tt>.
--   
--   If you want to decode a single key-value pair where only one value is
--   allowed. Like in the example below:
--   
--   <pre>
--   scope = "all"
--   </pre>
--   
--   To decode that you could use the following function:
--   
--   <pre>
--   Toml.hardcoded "all" Toml._Text "scope"
--   </pre>
--   
--   in case if the value in <tt>TOML</tt> is not the same as hardcoded,
--   you will get the following error:
--   
--   <pre>
--   tomland decode error:  BiMap error in key <tt>scope</tt> : Value '"foo"' doesn't align with the hardcoded value '"all"'
--   </pre>
hardcoded :: (Show a, Eq a) => a -> TomlBiMap a AnyValue -> Key -> TomlCodec a

-- | Codec that checks the <tt>BiMap</tt> on the given predicate. The
--   predicate function returns the value, if the validation is successful,
--   or the <a>Text</a> of the error that should be returned in case of
--   validation failure.
--   
--   <b>Example:</b>
--   
--   Let's imagine that we want to have the list in <tt>TOML</tt> that
--   could only have even <a>Int</a>s inside. In this case, you can write
--   the following codec:
--   
--   <pre>
--   allEven :: [<a>Int</a>] -&gt; <a>Either</a> <a>Text</a> [<a>Int</a>]
--   allEven xs =
--       if all even xs
--       then <a>Right</a> xs
--       else <a>Left</a> "This is wrong, I asked you for even only :("
--   
--   allEvenCodec :: <a>TomlCodec</a> [<a>Int</a>]
--   allEvenCodec = Toml.<a>validate</a> allEven (Toml._Array Toml._Int) "myEvenList"
--   </pre>
--   
--   Then in your <tt>TOML</tt> file you can have:
--   
--   <pre>
--   myEvenList = [2, 4, 6]
--   </pre>
--   
--   But the following one will lead to the error:
--   
--   <pre>
--   myEvenList = [1, 2, 3]
--   </pre>
--   
--   <pre>
--   tomland decode error:  This is wrong, I asked you for even only :(
--   </pre>
validate :: (a -> Either Text a) -> TomlBiMap a AnyValue -> Key -> TomlCodec a

-- | Similar to <a>validate</a> but takes the predicate that returnes
--   <a>Bool</a>. The error in case of the validation failure looks like
--   this:
--   
--   <pre>
--   Value does not pass the validation for key: KEY_NAME
--   </pre>
--   
--   <b>Example:</b>
--   
--   Let's imagine that we want to have the <a>Text</a> field in
--   <tt>TOML</tt> that could only have 3 chars in it. In this case, you
--   can write the following codec:
--   
--   <pre>
--   my3charTextCodec :: TomlCodec Text
--   my3CharTextCodec = Toml.<a>validateIf</a> ((==) 3 . Text.length) Toml._Text "myKeyName"
--   </pre>
--   
--   The in your <tt>TOML</tt> file you can have:
--   
--   <pre>
--   myKeyName = "abc"
--   </pre>
--   
--   But the following one will lead to the error:
--   
--   <pre>
--   myKeyName = "I have more than enough"
--   </pre>
--   
--   <pre>
--   tomland decode error:  Value does not pass the validation for key: myKeyName
--   </pre>
validateIf :: (a -> Bool) -> TomlBiMap a AnyValue -> Key -> TomlCodec a


-- | Contains TOML-specific combinators for converting between TOML and
--   user data types.
module Toml.Codec.Combinator


-- | This module contains implementation of the <a>Generic</a> TOML codec.
--   If your data types are big and nested, and you want to have codecs for
--   them without writing a lot of boilerplate code, you can find this
--   module helpful. Below you can find the detailed explanation on how the
--   <a>Generic</a> codecs work.
--   
--   Consider the following Haskell data types:
--   
--   <pre>
--   <b>data</b> User = User
--       { age     :: Int
--       , address :: Address
--       , socials :: [Social]
--       } <b>deriving</b> (<a>Generic</a>)
--   
--   <b>data</b> Address = Address
--       { street :: Text
--       , house  :: Int
--       } <b>deriving</b> (<a>Generic</a>)
--   
--   <b>data</b> Social = Social
--       { name :: Text
--       , link :: Text
--       } <b>deriving</b> (<a>Generic</a>)
--   </pre>
--   
--   Value of the <tt>User</tt> type represents the following TOML:
--   
--   <pre>
--   age = 27
--   
--   [address]
--     street = "Miami Beach"
--     house  = 42
--   
--   [[socials]]
--     name = "Twitter"
--     link = "<a>https://twitter.com/foo"</a>
--   
--   [[socials]]
--     name = "GitHub"
--     link = "<a>https://github.com/bar"</a>
--   </pre>
--   
--   Normally you would write <a>TomlCodec</a> for this data type like
--   this:
--   
--   <pre>
--   userCodec :: <a>TomlCodec</a> User
--   userCodec = User
--       &lt;$&gt; Toml.int "age" .= age
--       &lt;*&gt; Toml.table addressCodec "address" .= address
--       &lt;*&gt; Toml.list  socialCodec  "socials" .= socials
--   
--   addressCodec :: <a>TomlCodec</a> Address
--   addressCodec = Address
--       &lt;$&gt; Toml.text "street" .= street
--       &lt;*&gt; Toml.int  "house"  .= house
--   
--   socialCodec :: <a>TomlCodec</a> Social
--   socialCodec = Social
--       &lt;$&gt; Toml.text "name" .= name
--       &lt;*&gt; Toml.text "link" .= link
--   </pre>
--   
--   However, if you derive <a>Generic</a> instance for your data types (as
--   we do in the example), you can write your codecs in a simpler way.
--   
--   <pre>
--   userCodec :: <a>TomlCodec</a> User
--   userCodec = <a>genericCodec</a>
--   
--   <b>instance</b> <a>HasCodec</a> Address <b>where</b>
--       hasCodec = Toml.table <a>genericCodec</a>
--   
--   <b>instance</b> <a>HasItemCodec</a> Social <b>where</b>
--       hasItemCodec = Right <a>genericCodec</a>
--   </pre>
--   
--   Several notes about the interface:
--   
--   <ol>
--   <li>Your top-level data types are always implemented as
--   <a>genericCodec</a> (or other generic codecs).</li>
--   <li>If you have a custom data type as a field of another type, you
--   need to implement the instance of the <a>HasCodec</a> typeclass.</li>
--   <li>If the data type appears as an element of a list, you need to
--   implement the instance of the <a>HasItemCodec</a> typeclass.</li>
--   </ol>
module Toml.Codec.Generic

-- | Generic codec for arbitrary data types. Uses field names as keys.
genericCodec :: (Generic a, GenericCodec (Rep a)) => TomlCodec a

-- | Generic codec with options for arbitrary data types.
genericCodecWithOptions :: (Generic a, GenericCodec (Rep a), Typeable a) => TomlOptions a -> TomlCodec a

-- | Generic codec that uses <a>stripTypeNameOptions</a>.
stripTypeNameCodec :: (Generic a, GenericCodec (Rep a), Typeable a) => TomlCodec a

-- | Options to configure various parameters of generic encoding.
--   Specifically:
--   
--   <ul>
--   <li><b><a>tomlOptionsFieldModifier</a></b>: how to translate field
--   names to TOML keys?</li>
--   </ul>
data TomlOptions (a :: k)
TomlOptions :: (Typeable a => Proxy a -> String -> String) -> TomlOptions (a :: k)
[tomlOptionsFieldModifier] :: TomlOptions (a :: k) -> Typeable a => Proxy a -> String -> String

-- | Same as <a>TomlOptions</a> but with all data type information erased.
--   This data type is used internally. Define your options using
--   <a>TomlOptions</a> data type.
newtype GenericOptions
GenericOptions :: (String -> String) -> GenericOptions
[genericOptionsFieldModifier] :: GenericOptions -> String -> String

-- | Options that use <a>stripTypeNamePrefix</a> as
--   <a>tomlOptionsFieldModifier</a>.
stripTypeNameOptions :: forall {k} (a :: k). Typeable a => TomlOptions a

-- | Strips name of the type name from field name prefix.
--   
--   <pre>
--   &gt;&gt;&gt; data UserData = UserData { userDataId :: Int, userDataShortInfo :: Text }
--   
--   &gt;&gt;&gt; stripTypeNamePrefix (Proxy @UserData) "userDataId"
--   "id"
--   
--   &gt;&gt;&gt; stripTypeNamePrefix (Proxy @UserData) "userDataShortInfo"
--   "shortInfo"
--   
--   &gt;&gt;&gt; stripTypeNamePrefix (Proxy @UserData) "udStats"
--   "stats"
--   
--   &gt;&gt;&gt; stripTypeNamePrefix (Proxy @UserData) "fooBar"
--   "bar"
--   
--   &gt;&gt;&gt; stripTypeNamePrefix (Proxy @UserData) "name"
--   "name"
--   </pre>
stripTypeNamePrefix :: forall {k} (a :: k). Typeable a => Proxy a -> String -> String

-- | Helper typeclass for generic deriving. This instance tells how the
--   data type should be coded if it's a field of another data type.
--   
--   <b>NOTE:</b> If you implement TOML codecs for your data types
--   manually, prefer more explicit <tt>Toml.int</tt> or <tt>Toml.text</tt>
--   instead of implicit <tt>Toml.hasCodec</tt>. Implement instances of
--   this typeclass only when using <a>genericCodec</a> and when your
--   custom data types are not covered here.
class HasCodec a
hasCodec :: HasCodec a => Key -> TomlCodec a

-- | This typeclass tells how the data type should be coded as an item of a
--   list. Lists in TOML can have two types: <b>primitive</b> and <b>table
--   of arrays</b>.
--   
--   <ul>
--   <li>If <a>hasItemCodec</a> returns <a>Left</a>: <b>primitive</b>
--   arrays codec is used.</li>
--   <li>If <a>hasItemCodec</a> returns 'Right:' <b>table of arrays</b>
--   codec is used.</li>
--   </ul>
class HasItemCodec a
hasItemCodec :: HasItemCodec a => Either (TomlBiMap a AnyValue) (TomlCodec a)

-- | Helper class to derive TOML codecs generically.
class GenericCodec (f :: k -> Type)
genericTomlCodec :: forall (p :: k). GenericCodec f => GenericOptions -> TomlCodec (f p)

-- | Newtype wrapper over <a>ByteString</a> to be used for text values.
newtype ByteStringAsText
ByteStringAsText :: ByteString -> ByteStringAsText
[unByteStringAsText] :: ByteStringAsText -> ByteString

-- | Newtype wrapper over <a>ByteString</a> to be used for array of
--   integers representation.
newtype ByteStringAsBytes
ByteStringAsBytes :: ByteString -> ByteStringAsBytes
[unByteStringAsBytes] :: ByteStringAsBytes -> ByteString

-- | Newtype wrapper over lazy <a>ByteString</a> to be used for text
--   values.
newtype LByteStringAsText
LByteStringAsText :: ByteString -> LByteStringAsText
[unLByteStringAsText] :: LByteStringAsText -> ByteString

-- | Newtype wrapper over lazy <a>ByteString</a> to be used for array of
--   integers representation.
newtype LByteStringAsBytes
LByteStringAsBytes :: ByteString -> LByteStringAsBytes
[unLByteStringAsBytes] :: LByteStringAsBytes -> ByteString

-- | <tt>newtype</tt> for generic deriving of <a>HasCodec</a> typeclass for
--   custom data types that should we wrapped into separate table. Use it
--   only for data types that are fields of another data types.
--   
--   <pre>
--   <b>data</b> Person = Person
--       { personName    :: !<a>Text</a>
--       , personAddress :: !Address
--       } <b>deriving</b> (<a>Generic</a>)
--   
--   data Address = Address
--       { addressStreet :: !<a>Text</a>
--       , addressHouse  :: !<a>Int</a>
--       } <b>deriving</b> (<a>Generic</a>)
--         <b>deriving</b> <a>HasCodec</a> <b>via</b> <a>TomlTable</a> Address
--   
--   personCodec :: <a>TomlCodec</a> Person
--   personCodec = <a>stripTypeNameCodec</a>
--   </pre>
--   
--   <tt>personCodec</tt> corresponds to the TOML of the following
--   structure:
--   
--   <pre>
--   name = "foo"
--   [address]
--       addressStreet = "Bar"
--       addressHouse = 42
--   </pre>
newtype TomlTable a
TomlTable :: a -> TomlTable a
[unTomlTable] :: TomlTable a -> a

-- | <tt>newtype</tt> for generic deriving of <a>HasCodec</a> typeclass for
--   custom data types that should be wrapped into a separate table.
--   
--   Similar to <a>TomlTable</a> but also strips the data type name prefix
--   from TOML keys.
--   
--   <tt>personCodec</tt> from the <a>TomlTable</a> comment corresponds to
--   the TOML of the following structure:
--   
--   <pre>
--   name = "foo"
--   [address]
--       street = "Bar"
--       house = 42
--   </pre>
newtype TomlTableStrip a
TomlTableStrip :: a -> TomlTableStrip a
[unTomlTableStrip] :: TomlTableStrip a -> a
instance GHC.Classes.Eq Toml.Codec.Generic.ByteStringAsBytes
instance GHC.Classes.Eq Toml.Codec.Generic.ByteStringAsText
instance GHC.Classes.Eq Toml.Codec.Generic.LByteStringAsBytes
instance GHC.Classes.Eq Toml.Codec.Generic.LByteStringAsText
instance forall k (f :: k -> *) (g :: k -> *). (Toml.Codec.Generic.GenericCodec f, Toml.Codec.Generic.GenericCodec g) => Toml.Codec.Generic.GenericCodec (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (TypeError ...) => Toml.Codec.Generic.GenericCodec (f GHC.Generics.:+: g)
instance (GHC.Generics.Selector s, Toml.Codec.Generic.HasCodec a) => Toml.Codec.Generic.GenericCodec (GHC.Generics.S1 s (GHC.Generics.Rec0 a))
instance forall k (f :: k -> *) (d :: GHC.Generics.Meta). Toml.Codec.Generic.GenericCodec f => Toml.Codec.Generic.GenericCodec (GHC.Generics.D1 d f)
instance forall k (f :: k -> *) (c :: GHC.Generics.Meta). Toml.Codec.Generic.GenericCodec f => Toml.Codec.Generic.GenericCodec (GHC.Generics.C1 c f)
instance Toml.Codec.Generic.HasCodec Data.Semigroup.Internal.All
instance Toml.Codec.Generic.HasCodec Data.Semigroup.Internal.Any
instance Toml.Codec.Generic.HasCodec GHC.Types.Bool
instance Toml.Codec.Generic.HasCodec Toml.Codec.Generic.ByteStringAsBytes
instance Toml.Codec.Generic.HasCodec Toml.Codec.Generic.ByteStringAsText
instance Toml.Codec.Generic.HasCodec Data.Time.Calendar.Days.Day
instance Toml.Codec.Generic.HasCodec GHC.Types.Double
instance Toml.Codec.Generic.HasCodec a => Toml.Codec.Generic.HasCodec (Data.Monoid.First a)
instance Toml.Codec.Generic.HasCodec GHC.Types.Float
instance (Data.Hashable.Class.Hashable k, Toml.Codec.Generic.HasCodec k, Toml.Codec.Generic.HasCodec v) => Toml.Codec.Generic.HasCodec (Data.HashMap.Internal.HashMap k v)
instance (Data.Hashable.Class.Hashable a, Toml.Codec.Generic.HasItemCodec a) => Toml.Codec.Generic.HasCodec (Data.HashSet.Internal.HashSet a)
instance Toml.Codec.Generic.HasCodec GHC.Types.Int
instance Toml.Codec.Generic.HasCodec v => Toml.Codec.Generic.HasCodec (Data.IntMap.Internal.IntMap v)
instance Toml.Codec.Generic.HasCodec Data.IntSet.Internal.IntSet
instance Toml.Codec.Generic.HasCodec GHC.Num.Integer.Integer
instance Toml.Codec.Generic.HasCodec Toml.Codec.Generic.LByteStringAsBytes
instance Toml.Codec.Generic.HasCodec Toml.Codec.Generic.LByteStringAsText
instance Toml.Codec.Generic.HasCodec a => Toml.Codec.Generic.HasCodec (Data.Monoid.Last a)
instance Toml.Codec.Generic.HasItemCodec a => Toml.Codec.Generic.HasCodec [a]
instance Toml.Codec.Generic.HasCodec Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance (GHC.Classes.Ord k, Toml.Codec.Generic.HasCodec k, Toml.Codec.Generic.HasCodec v) => Toml.Codec.Generic.HasCodec (Data.Map.Internal.Map k v)
instance Toml.Codec.Generic.HasCodec a => Toml.Codec.Generic.HasCodec (GHC.Maybe.Maybe a)
instance Toml.Codec.Generic.HasCodec GHC.Num.Natural.Natural
instance Toml.Codec.Generic.HasItemCodec a => Toml.Codec.Generic.HasCodec (GHC.Base.NonEmpty a)
instance (GHC.Num.Num a, Toml.Codec.Generic.HasCodec a) => Toml.Codec.Generic.HasCodec (Data.Semigroup.Internal.Product a)
instance (GHC.Classes.Ord a, Toml.Codec.Generic.HasItemCodec a) => Toml.Codec.Generic.HasCodec (Data.Set.Internal.Set a)
instance (GHC.Num.Num a, Toml.Codec.Generic.HasCodec a) => Toml.Codec.Generic.HasCodec (Data.Semigroup.Internal.Sum a)
instance Toml.Codec.Generic.HasCodec Data.Text.Internal.Lazy.Text
instance Toml.Codec.Generic.HasCodec Data.Text.Internal.Text
instance Toml.Codec.Generic.HasCodec Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance (GHC.Generics.Generic a, Toml.Codec.Generic.GenericCodec (GHC.Generics.Rep a)) => Toml.Codec.Generic.HasCodec (Toml.Codec.Generic.TomlTable a)
instance (GHC.Generics.Generic a, Toml.Codec.Generic.GenericCodec (GHC.Generics.Rep a), Data.Typeable.Internal.Typeable a) => Toml.Codec.Generic.HasCodec (Toml.Codec.Generic.TomlTableStrip a)
instance Toml.Codec.Generic.HasCodec GHC.Types.Word
instance Toml.Codec.Generic.HasCodec GHC.Word.Word8
instance Toml.Codec.Generic.HasCodec Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Toml.Codec.Generic.HasItemCodec GHC.Types.Bool
instance Toml.Codec.Generic.HasItemCodec Toml.Codec.Generic.ByteStringAsBytes
instance Toml.Codec.Generic.HasItemCodec Toml.Codec.Generic.ByteStringAsText
instance Toml.Codec.Generic.HasItemCodec Data.Time.Calendar.Days.Day
instance Toml.Codec.Generic.HasItemCodec GHC.Types.Double
instance Toml.Codec.Generic.HasItemCodec GHC.Types.Float
instance Toml.Codec.Generic.HasItemCodec GHC.Types.Int
instance Toml.Codec.Generic.HasItemCodec Data.IntSet.Internal.IntSet
instance Toml.Codec.Generic.HasItemCodec GHC.Num.Integer.Integer
instance Toml.Codec.Generic.HasItemCodec Toml.Codec.Generic.LByteStringAsBytes
instance Toml.Codec.Generic.HasItemCodec Toml.Codec.Generic.LByteStringAsText
instance (Toml.Codec.Generic.HasItemCodec a, Data.Typeable.Internal.Typeable a) => Toml.Codec.Generic.HasItemCodec [a]
instance Toml.Codec.Generic.HasItemCodec Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Toml.Codec.Generic.HasItemCodec GHC.Num.Natural.Natural
instance Toml.Codec.Generic.HasItemCodec Data.Text.Internal.Lazy.Text
instance Toml.Codec.Generic.HasItemCodec Data.Text.Internal.Text
instance Toml.Codec.Generic.HasItemCodec Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance (GHC.Generics.Generic a, Toml.Codec.Generic.GenericCodec (GHC.Generics.Rep a)) => Toml.Codec.Generic.HasItemCodec (Toml.Codec.Generic.TomlTable a)
instance (GHC.Generics.Generic a, Toml.Codec.Generic.GenericCodec (GHC.Generics.Rep a), Data.Typeable.Internal.Typeable a) => Toml.Codec.Generic.HasItemCodec (Toml.Codec.Generic.TomlTableStrip a)
instance Toml.Codec.Generic.HasItemCodec GHC.Types.Word
instance Toml.Codec.Generic.HasItemCodec GHC.Word.Word8
instance Toml.Codec.Generic.HasItemCodec Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance GHC.Show.Show Toml.Codec.Generic.ByteStringAsBytes
instance GHC.Show.Show Toml.Codec.Generic.ByteStringAsText
instance GHC.Show.Show Toml.Codec.Generic.LByteStringAsBytes
instance GHC.Show.Show Toml.Codec.Generic.LByteStringAsText


-- | This module provides utilities for implementing and using
--   bidirectional TOML codecs. The concept of bidirectional conversion in
--   <tt>tomland</tt> has two parts: <b><a>TomlBiMap</a></b> and
--   <b><a>TomlCodec</a></b>.
--   
--   <h2>General TOML description</h2>
--   
--   In the following TOML
--   
--   <pre>
--   name = "foo"
--   </pre>
--   
--   we call <tt>name</tt> as <b>key</b> and <tt>"foo"</tt> as
--   <b>value</b>.
--   
--   <h2><a>TomlBiMap</a></h2>
--   
--   <a>TomlBiMap</a> provides a bidirectional conversion between <b>TOML
--   values</b> and Haskell primitive values. TOML specification defines
--   some primitive values you can use in key-value pairs (e.g.
--   <i>integer</i>, <i>string</i>, <i>local time</i>). <a>TomlBiMap</a>
--   provides a way to convert between TOML primitives and Haskell values.
--   <a>TomlBiMap</a> doesn't know anything about TOML keys.
--   
--   <h2><a>TomlCodec</a></h2>
--   
--   <a>TomlCodec</a> describes how to convert in both ways between a
--   single or multiple key-value pairs and Haskell types. <tt>tomland</tt>
--   provides basic primitives for decoding and encoding single key-value
--   pairs, but also a way to compose multiple <a>TomlCodec</a>s into a
--   single one. So, if you have a custom data type, that has several
--   fields or several constructors, you need to define <a>TomlCodec</a>
--   for your data type.
--   
--   <h2>Encoding and decoding</h2>
--   
--   If you have a type like <tt>User</tt> then <tt>userCodec ::
--   <a>TomlCodec</a> User</tt> is an object that describes how to
--   <a>encode</a> a value of type <tt>User</tt> to TOML and <a>decode</a>
--   TOML to a value of type <tt>User</tt>.
--   
--   <ul>
--   <li>To TOML: <tt><a>encode</a> userCodec someUser</tt></li>
--   <li>From TOML: <tt><a>decode</a> userCodec someToml</tt></li>
--   </ul>
--   
--   <h2>Naming conventions</h2>
--   
--   <tt>tomland</tt> uses the following naming conventions (and encourages
--   library users to follow them as well):
--   
--   <ul>
--   <li><b>_SomeName</b>: for <a>TomlBiMap</a> (e.g. <a>_Int</a>,
--   <a>_Text</a>, <a>_Array</a>)</li>
--   <li><b>someName</b>: for basic <a>TomlCodec</a>s (e.g. <a>int</a>,
--   <a>text</a>, <a>arrayOf</a>)</li>
--   <li><b>someNameCodec</b>: for user defined codecs for custom types
--   (e.g. <tt>userCodec</tt>, <tt>configCodec</tt>,
--   <tt>serverCodec</tt>)</li>
--   </ul>
module Toml.Codec


-- | This module reexports all functionality of the <tt>tomland</tt>
--   package. It's recommended to import this module qualified, like this:
--   
--   <pre>
--   <b>import</b> <a>Toml</a> (<a>TomlCodec</a>, <a>(.=)</a>)
--   <b>import</b> <b>qualified</b> <a>Toml</a>
--   </pre>
--   
--   Simple <tt><a>TomlCodec</a></tt> for a Haskell value, that can be
--   decoded from TOML or encoded as TOML, could be written in the
--   following way:
--   
--   <pre>
--   <b>data</b> User = User
--       { userName :: Text
--       , userAge  :: Int
--       }
--   
--   userCodec :: <a>TomlCodec</a> User
--   userCodec = User
--       &lt;$&gt; Toml.<a>text</a> "name" <a>.=</a> userName
--       &lt;*&gt; Toml.<a>int</a>  "age"  <a>.=</a> userAge
--   </pre>
--   
--   A value of such type will look in TOML like this:
--   
--   <pre>
--   name = <a>Alice</a>
--   age  = 27
--   </pre>
--   
--   For more detailed examples see README.md in the repository:
--   
--   <ul>
--   <li><a>tomland/README.md</a></li>
--   </ul>
--   
--   For the details of the library implementation see blog post:
--   
--   <ul>
--   <li><a>tomland: Bidirectional TOML serialization</a></li>
--   </ul>
module Toml
