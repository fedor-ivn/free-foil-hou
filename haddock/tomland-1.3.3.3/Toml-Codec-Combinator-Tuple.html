<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Toml.Codec.Combinator.Tuple</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">tomland-1.3.3.3: Bidirectional TOML serialization</span><ul class="links" id="page-menu"><li><a href="src/Toml.Codec.Combinator.Tuple.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2018-2022 Kowainik</td></tr><tr><th>License</th><td>MPL-2.0</td></tr><tr><th>Maintainer</th><td>Kowainik &lt;xrom.xkov@gmail.com&gt;</td></tr><tr><th>Stability</th><td>Stable</td></tr><tr><th>Portability</th><td>Portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Toml.Codec.Combinator.Tuple</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>TOML-specific combinators for converting between TOML and Haskell tuples.
It's recommended to create your custom data types and implement codecs
for them, but if you need to have tuples (e.g. for decoding different
constructors of sum types), you can find codecs from this module
helpful.</p><table><thead><tr><th>Haskell Type</th><th><code>TOML</code></th><th><code><a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a></code></th></tr></thead><tbody><tr><td><strong><code>(<code><a href="../base-4.19.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code>, <code>Text</code>)</code></strong></td><td><code>[foo]</code></td><td><code><code><a href="Toml-Codec-Combinator-Tuple.html#v:pair" title="Toml.Codec.Combinator.Tuple">pair</a></code></code></td></tr><tr><td></td><td><code>&#8201;&#8201;&#8201;&#8201;a = 42</code></td><td><code>&#8201;&#8201;&#8201;&#8201;(<code><a href="Toml.html#v:int" title="Toml">int</a></code> &quot;a&quot;)</code></td></tr><tr><td></td><td><code>&#8201;&#8201;&#8201;&#8201;b = &quot;bar&quot;</code></td><td><code>&#8201;&#8201;&#8201;&#8201;(<code><a href="Toml.html#v:text" title="Toml">text</a></code> &quot;b&quot;)</code></td></tr><tr><td><strong><code>(<code><a href="../base-4.19.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code>, <code>Text</code>, <code><a href="../base-4.19.1.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>)</code></strong></td><td><code>[foo]</code></td><td><code><code><a href="Toml-Codec-Combinator-Tuple.html#v:triple" title="Toml.Codec.Combinator.Tuple">triple</a></code></code></td></tr><tr><td></td><td><code>&#8201;&#8201;&#8201;&#8201;a = 42</code></td><td><code>&#8201;&#8201;&#8201;&#8201;(<code><a href="Toml.html#v:int" title="Toml">int</a></code> &quot;a&quot;)</code></td></tr><tr><td></td><td><code>&#8201;&#8201;&#8201;&#8201;b = &quot;bar&quot;</code></td><td><code>&#8201;&#8201;&#8201;&#8201;(<code><a href="Toml.html#v:text" title="Toml">text</a></code> &quot;b&quot;)</code></td></tr><tr><td></td><td><code>&#8201;&#8201;&#8201;&#8201;c = false</code></td><td><code>&#8201;&#8201;&#8201;&#8201;(<code><a href="Toml.html#v:bool" title="Toml">bool</a></code> &quot;c&quot;)</code></td></tr></tbody></table><p><em>Since: 1.3.0.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:pair">pair</a> :: <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> a -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> b -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> (a, b)</li><li class="src short"><a href="#v:triple">triple</a> :: <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> a -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> b -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> c -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> (a, b, c)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:pair" class="def">pair</a> :: <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> a -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> b -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> (a, b) <a href="src/Toml.Codec.Combinator.Tuple.html#pair" class="link">Source</a> <a href="#v:pair" class="selflink">#</a></p><div class="doc"><p>Codec for pair of values. Takes codecs for the first and for the second
values of the pair.</p><p>If I have the following <code>TOML</code> entry</p><pre>myPair = { first = 11, second = &quot;eleven&quot;}
</pre><p>and want to convert it into the Haskell tuple of two elements, I can use the
following codec:</p><pre>myPairCodec :: <code><a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a></code> (<code><a href="../base-4.19.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code>, <code>Text</code>)
myPairCodec = flip Toml.<code>table</code> &quot;myPair&quot; $ Toml.<code><a href="Toml-Codec-Combinator-Tuple.html#v:pair" title="Toml.Codec.Combinator.Tuple">pair</a></code>
    (Toml.<code>int</code> &quot;first&quot;)
    (Toml.<code>text</code> &quot;second&quot;)
</pre><p><em>Since: 1.3.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:triple" class="def">triple</a> :: <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> a -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> b -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> c -&gt; <a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a> (a, b, c) <a href="src/Toml.Codec.Combinator.Tuple.html#triple" class="link">Source</a> <a href="#v:triple" class="selflink">#</a></p><div class="doc"><p>Codec for triple of values. Takes codecs for the first, second and third
values of the triple.</p><p>If I have the following <code>TOML</code> entry</p><pre>myTriple =
    { first = 11
    , second = &quot;eleven&quot;
    , isMyFavourite = true
    }
</pre><p>and want to convert it into the Haskell tuple of three elements, I can use the
following codec:</p><pre>myTripleCodec :: <code><a href="Toml-Codec-Types.html#t:TomlCodec" title="Toml.Codec.Types">TomlCodec</a></code> (<code><a href="../base-4.19.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code>, <code>Text</code>, <code><a href="../base-4.19.1.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>)
myTripleCodec = flip Toml.<code>table</code> &quot;myTriple&quot; $ Toml.<code><a href="Toml-Codec-Combinator-Tuple.html#v:triple" title="Toml.Codec.Combinator.Tuple">triple</a></code>
    (Toml.<code>int</code> &quot;first&quot;)
    (Toml.<code>text</code> &quot;second&quot;)
    (Toml.<code>bool</code> &quot;isMyFavourite&quot;)
</pre><p><em>Since: 1.3.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>