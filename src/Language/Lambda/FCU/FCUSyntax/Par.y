-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Lambda.FCU.FCUSyntax.Par
  ( happyError
  , myLexer
  , pTerm
  , pPattern
  , pScopedTerm
  ) where

import Prelude

import qualified Language.Lambda.FCU.FCUSyntax.Abs
import Language.Lambda.FCU.FCUSyntax.Lex

}

%name pTerm Term
%name pPattern Pattern
%name pScopedTerm ScopedTerm
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('             { PT _ (TS _ 1)             }
  ')'             { PT _ (TS _ 2)             }
  '.'             { PT _ (TS _ 3)             }
  'λ'             { PT _ (TS _ 4)             }
  L_Id            { PT _ (T_Id $$)            }
  L_MetavarId     { PT _ (T_MetavarId $$)     }
  L_ConstructorId { PT _ (T_ConstructorId $$) }

%%

Id :: { Language.Lambda.FCU.FCUSyntax.Abs.Id }
Id  : L_Id { Language.Lambda.FCU.FCUSyntax.Abs.Id $1 }

MetavarId :: { Language.Lambda.FCU.FCUSyntax.Abs.MetavarId }
MetavarId  : L_MetavarId { Language.Lambda.FCU.FCUSyntax.Abs.MetavarId $1 }

ConstructorId :: { Language.Lambda.FCU.FCUSyntax.Abs.ConstructorId }
ConstructorId  : L_ConstructorId { Language.Lambda.FCU.FCUSyntax.Abs.ConstructorId $1 }

Term :: { Language.Lambda.FCU.FCUSyntax.Abs.Term }
Term
  : MetavarId { Language.Lambda.FCU.FCUSyntax.Abs.WTerm $1 }
  | Id { Language.Lambda.FCU.FCUSyntax.Abs.OTerm $1 }
  | ConstructorId { Language.Lambda.FCU.FCUSyntax.Abs.CTerm $1 }
  | Term Term { Language.Lambda.FCU.FCUSyntax.Abs.AppTerm $1 $2 }
  | 'λ' Pattern '.' ScopedTerm { Language.Lambda.FCU.FCUSyntax.Abs.AbsTerm $2 $4 }
  | '(' Term ')' { $2 }

Pattern :: { Language.Lambda.FCU.FCUSyntax.Abs.Pattern }
Pattern : Id { Language.Lambda.FCU.FCUSyntax.Abs.PatternVar $1 }

ScopedTerm :: { Language.Lambda.FCU.FCUSyntax.Abs.ScopedTerm }
ScopedTerm
  : Term { Language.Lambda.FCU.FCUSyntax.Abs.ScopedTerm $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

