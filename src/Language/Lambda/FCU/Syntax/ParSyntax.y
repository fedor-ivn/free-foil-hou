-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParSyntax
  ( happyError
  , myLexer
  , pTerm
  , pTerm1
  , pTerm2
  ) where

import Prelude

import qualified AbsSyntax
import LexSyntax

}

%name pTerm Term
%name pTerm1 Term1
%name pTerm2 Term2
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '.'         { PT _ (TS _ 1)         }
  'λ'         { PT _ (TS _ 2)         }
  L_MetaVarId { PT _ (T_MetaVarId $$) }
  L_ConsId    { PT _ (T_ConsId $$)    }
  L_VarId     { PT _ (T_VarId $$)     }

%%

MetaVarId :: { AbsSyntax.MetaVarId }
MetaVarId  : L_MetaVarId { AbsSyntax.MetaVarId $1 }

ConsId :: { AbsSyntax.ConsId }
ConsId  : L_ConsId { AbsSyntax.ConsId $1 }

VarId :: { AbsSyntax.VarId }
VarId  : L_VarId { AbsSyntax.VarId $1 }

Term :: { AbsSyntax.Term }
Term : 'λ' VarId '.' Term1 { AbsSyntax.Lam $2 $4 }

Term1 :: { AbsSyntax.Term }
Term1 : Term1 Term2 { AbsSyntax.App $1 $2 }

Term2 :: { AbsSyntax.Term }
Term2
  : VarId { AbsSyntax.Var $1 }
  | MetaVarId { AbsSyntax.MetaVar $1 }
  | ConsId { AbsSyntax.Cons $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

